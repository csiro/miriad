c************************************************************************
	program uvjup
	implicit none
c= uvjup -- Recompute various derived quantitues in a uv data-set
c& rjs
c: uv analysis
c+
c	uvjup recomputes various derived quantities in a uv data-set.
c	This may be needed if the derived quantities are wrong for some
c	reason, or if there is a need to change a coordinate system.
c
c	NOTE: The recomputation relies on a number of parameters in the
c	data-set, such as "time". It is assumed that this information is
c	correct. Uv variables that are important are:
c	For velocity: time and latitu,longitu (or telescop is these are
c	missing).
c@ vis
c	The name of the input uv data set. No default.
c@ select
c	The normal uv selection commands. The default is to select everything.
c@ pltb
c	Blackbody temperature of the disk to subtract off. Default is 0.
c@ out
c	The name of the output uv data-set. There is no default name.
c@ options
c	This gives extra processing options. Several options can be given,
c	each separated by commas. They may be abbreviated to the minimum
c	needed to avoid ambiguity. Possible options are:
c	   'jupaxis'     Set magnetic axis as the relevant one.
c	The following options can be used to turn off calibration corrections.
c	The default is to apply any calibration present.
c	   'nocal'       Do not apply the gains table.
c	   'nopass'      Do not apply bandpass corrections.
c	   'nopol'       Do not apply polarizatiopn corrections.
c@ pmotion
c	Two Jupiter tracking files. The first gives the phase centre
c	(as a function of time) of Jupiter. The second
c	gives the phase centre of the observation (as a function of time).
c	The latter defaults to the position given in the dataset.
c	A phase shift is applied to the data to correct for differences
c	between these two.
c@ sources
c	This gives the position and flux of sources to be subtracted
c	from the visibility dataset. Many sources can be given. Each
c	source is specified by three numbers:
c	  ra dec flux
c	The RA and DEC are in normal Miriad format, and the flux is in Jy.
c--
c  History:
c------------------------------------------------------------------------
	include 'maxdim.h'
	include 'mirconst.h'
	integer MAXSCAN,MAXSRC
	parameter(MAXSCAN=1024,MAXSRC=200)
	character version*(*)
	parameter(version='uvjup: version 1.0 28-Nov-93')
c
	character out*64,ltype*16,uvflags*16
	real pltb
	integer lIn,lOut
	logical dojaxis
	integer jscan,tscan
	double precision jdata(6,MAXSCAN),tdata(6,MAXSCAN)
	integer nsrc
	double precision sra(MAXSRC),sdec(MAXSRC)
	real flux(MAXSRC)
	character jpath*64,tpath*64
c
c  Externals.
c
	logical uvDatOpn,keyprsnt
	character itoaf*8
c
c  Get the input parameters.
c
	call output(version)
	call keyini
	call GetOpt(dojaxis,uvflags)
	call uvDatInp('vis',uvflags)
	call keya('out',out,' ')
	call keyr('pltb',pltb,0.)
	call keya('pmotion',jpath,' ')
	jscan = 0
	if(jpath.ne.' ')call pathload(jpath,jdata,jscan,MAXSCAN)
	call keya('pmotion',tpath,' ')
	tscan = 0
	if(tpath.ne.' ')call pathload(tpath,tdata,tscan,MAXSCAN)
c
	nsrc = 0
	dowhile(keyprsnt('sources'))
	  nsrc = nsrc + 1
	  if(nsrc.gt.MAXSRC)call bug('f','Too many sources')
	  call keyt('sources',sra(nsrc),'hms',0.d0)
	  call keyt('sources',sdec(nsrc),'dms',0.d0)
	  call keyr('sources',flux(nsrc),0.0)
	enddo
	if(nsrc.gt.0)
     *	  call output('Number of sources read: '//itoaf(nsrc))
c
	call keyfin
c
c  Check the inputs.
c
	if(out.eq.' ')call bug('f','An output must be given')
c
c  Open the inputs and the outputs.
c
	if(.not.uvDatOpn(lIn))
     *	  call bug('f','Failed to open the input data-set')
	call uvDatGta('ltype',ltype)
	call VarInit(lIn,ltype)
c
	call uvopen(lOut,out,'new')
	call uvset(lOut,'preamble','uvw/time/baseline',0,0.,0.,0.)
	call hdcopy(lIn,lOut,'history')
	call hisopen(lOut,'append')
	call hiswrite(lOut,'UVJUP: Miriad '//version)
	call hisinput(lOut,'UVJUP')
	call hisclose(lOut)
	call VarOnit(lIn,lOut,ltype)
c
c  Do the work.
c
	call Process(lIn,lOut,pltb,dojaxis,tscan,tdata,jscan,jdata,
     *	  sra,sdec,flux,nsrc)
c
c  All said and done. Close up shop.
c
	call uvDatCls
	call uvclose(lOut)
	end
c************************************************************************
	subroutine GetOpt(dojaxis,uvflags)
c
	implicit none
	logical dojaxis
	character uvflags*(*)
c
c  Determine extra processing options.
c
c  Output:
c    uvflags
c------------------------------------------------------------------------
	integer NOPTS
	parameter(NOPTS=4)
	logical present(NOPTS)
	character opts(NOPTS)*8
c
	data opts/'jupaxis ','nocal   ','nopol   ','nopass  '/
c
	call options('options',opts,present,NOPTS)
	dojaxis = present(1)
c
c  Determine the flags to pass to the uvDat routines.
c    d - Data selection.
c    b - Input must be a single file.
c    3 - Return w (as well as u and v).
c    c - Apply gain table.
c    e - Apply leakage correction.
c    f - Apply bandpass correction.
c
	uvflags = 'db3'
	if(.not.present(2))uvflags(5:5) = 'c'
	if(.not.present(3))uvflags(6:6) = 'e'
	if(.not.present(4))uvflags(7:7) = 'f'
c
	end
c************************************************************************
	subroutine Process(lIn,lOut,pltb,dojaxis,
     *			tscan,tdata,jscan,jdata,sra,sdec,flux,nsrc)
c
	implicit none
	integer lIn,lOut
	logical dojaxis
	real pltb
	integer tscan,jscan,nsrc
	double precision tdata(6,*),jdata(6,*),sra(*),sdec(*)
	real flux(*)
c
c  Do all the real work.
c
c  Input:
c    lIn
c    lOut
c    dojaxis	Write out the position angle related to the magnetic
c		axis (not spin axis).
c    pltb	Planet brightness temperature to subtract off.
c
c------------------------------------------------------------------------
	include 'maxdim.h'
	include 'mirconst.h'
	integer JUPITER
	parameter(JUPITER=5)
	integer nchan,i,j,npol,pol,itscan,ijscan
	double precision preamble(5),sub(3)
	double precision lamIII,latitude,utc,tdb,uu,vv
	double precision tra,tdec,jra,jdec,dra,ddec
	real a,b,disk,bmaj,bmin,bpa,cospa,sinpa
	logical flags(MAXCHAN)
	double precision freq(MAXCHAN),dist
	complex data(MAXCHAN)
	double precision x(2),lmn(3),theta0
	real theta
	complex w
	integer coObj
c
c  Externals.
c
	real j1xbyx
	logical polspara
	double precision deltime
c
c  Initialise for the various recomputations.
c
	itscan = 1
	ijscan = 1
	if(pltb.gt.0)then
	  call uvputvrr(lOut,'pltb',pltb,1)
	else
	  call uvputvrr(lOut,'pltb',350.,1)
	endif
c
c  Read the first record.
c
	call uvDatRd(preamble,data,flags,MAXCHAN,nchan)
c
c  the default rest frame, if we are doing velocity recomputation
c  and a rest frame has not been given.
c
	dowhile(nchan.gt.0)
	  call uvinfo(lIn,'sfreq',freq)
c
c  Copy all the variables from the input to the output.
c
	  call uvDatGti('npol',npol)
	  if(npol.eq.0)
     *	    call bug('f','Could not determine number of polarisations')
	  call uvDatGti('pol',pol)
	  call uvputvri(lOut,'npol',npol,1)
	  call uvputvri(lOut,'pol',pol,1)
	  call VarCopy(lIn,lOut)
c
	  uu = preamble(1)
	  vv = preamble(2)
	  utc = preamble(4)
	  tdb = utc + deltime(utc,'tdb')
	  call plpar(tdb,JUPITER,sub,dist,bmaj,bmin,bpa)
c
c  Fix the phase error in Jupiter observations.
c
	  if(jscan.gt.0)then
	    if(tscan.gt.0)then
	      call GetRaDec(tscan,itscan,tdata,utc,tra,tdec)
	    else
	      call uvrdvrd(lIn,'ra',tra,0.d0)
	      call uvrdvrd(lIn,'dec',tdec,0.d0)
	    endif
	    call GetRaDec(jscan,ijscan,jdata,utc,jra,jdec)
	    dra  = (jra - tra ) * cos(jdec)
	    ddec = jdec - tdec
	    call Jupfix(preamble,freq,data,nchan,dra,ddec)
	    call uvputvrd(lOut,'ra',jra,1)
	    call uvputvrd(lOut,'dec',jdec,1)
	  else
	    call uvrdvrd(lIn,'ra',jra,0.d0)
	    call uvrdvrd(lIn,'dec',jdec,0.d0)
	  endif
c
c  Subtract off point sources, if needed.
c
	  if(nsrc.gt.0.and.polspara(pol))then
	    call coRaDec(coObj,'SIN',jra,jdec)
	    do j=1,nsrc
	      x(1) = sra(j)
	      x(2) = sdec(j)
	      call coLMN(coObj,'aw/aw',x,lmn)
	      theta0 = 2*DPI*(preamble(1)*lmn(1) +
     *			      preamble(2)*lmn(2) +
     *			      preamble(3)*(lmn(3)-1))
	      do i=1,nchan
		theta = theta0 * freq(i)
		w = flux(j)*cmplx(cos(theta),sin(theta))
		data(i) = data(i) - w
	      enddo
	    enddo
	    call coFin(coObj)
	  endif
	    
c
c  Subract the disk response if appropriate.
c
	  if(pltb.gt.0.and.polspara(pol))then
	    cospa = cos(bpa)
	    sinpa = sin(bpa)
	    b = PI * sqrt((bmaj*(uu*cospa-vv*sinpa))**2
     *                  + (bmin*(uu*sinpa+vv*cospa))**2)
	    a = 2 * pltb * (KMKS*1e18)/(CMKS*CMKS*1e-26)
     *	      * 2 * PI/4 * bmaj*bmin
	    do i=1,nchan
	      disk = a*freq(i)*freq(i)*j1xbyx(real(b*freq(i)))
	      data(i) = data(i) - disk
	    enddo
	  endif
c
c  Compute the position angle of the magnetic axis.
c
	  if(dojaxis)then
	    sub(2) = -sub(2)
	    call lmn2sph(sub,lamIII,latitude)
	    bpa = bpa - 10.*PI/180.*sin(lamIII-200.*PI/180.)
	  endif
	  call uvputvrr(lOut,'plangle',180/PI*bpa,1)
	  call uvputvrr(lOut,'plmaj',5.,1)
	  call uvputvrr(lOut,'plmin',5.,1)
c	  call uvputvrr(lOut,'plmaj',3600*180/PI*bmaj,1)
c	  call uvputvrr(lOut,'plmin',3600*180/PI*bmin,1)
c
c  All done. Loop the loop.
c
	  call uvwrite(lOut,preamble,data,flags,nchan)
	  call uvDatRd(preamble,data,flags,MAXCHAN,nchan)
	enddo
c
	end
c************************************************************************
	subroutine pathload(path,data,nscan,MAXSCAN)
c
	implicit none
	character path*(*)
	integer nscan,MAXSCAN
	double precision data(6,MAXSCAN)
c
c  The input text file gives the path of the telescope phase centre or Jupiter
c  as a sequence of records. Each record consists of
c    stime,rtime,ra,dec,prm,pdec
c  Where
c    stime -- Start time of the validity of this record, as MJD.
c    rtime -- Reference time for this record, as MJD.
c    ra    -- R.A. at reference time, in turns.
c    dec   -- DEC at reference time, in turns.
c    prm   -- Proper motion of RA in turns/day.
c    pdec  -- Proper motion of DEC in turns/day.
c
c  These are converted to times in Julian days, and angular units in
c  radians or radians/day.
c------------------------------------------------------------------------
	integer iostat,k1,k2,length,tIn,i
	character line*128,string*32
	logical ok
	double precision val
c
	include 'mirconst.h'
	double precision scale(6),offset(6)
c
c  Externals.
c
	integer len1
	character itoaf*8
c
	data scale/ 1.d0,1.d0,DTWOPI,DTWOPI,DTWOPI,DTWOPI/
	data offset/2 400 000.5d0,2 400 000.5d0,0.d0, 0.d0, 0.d0, 0.d0/
c
c  Open the input text file.
c
	call txtopen(tIn,path,'old',iostat)
	if(iostat.ne.0)call bugno('f',iostat)
c
	nscan = 0
	call txtread(tIn,line,length,iostat)
	dowhile(iostat.eq.0)
	  k1 = 1
	  k2 = len1(line(1:length))
	  if(line(1:1).ne.'#'.and.k2.gt.0)then
	    nscan = nscan + 1
	    if(nscan.gt.MAXSCAN)call bug('f','Too many scans')
	    do i=1,6
	      call getfield(line,k1,k2,string,length)
	      if(length.le.0)call bug('f','Ran out of numbers')
	      call atodf(string(1:length),val,ok)
	      if(.not.ok)call bug('f','Error decoding value')
	      data(i,nscan) = scale(i)*val + offset(i)
	    enddo
	  endif
	  call txtread(tIn,line,length,iostat)
	enddo
c
	if(iostat.ne.-1)call bugno('f',iostat)
c
	line = 'Read '//itoaf(nscan)
	length = len1(line)
	line(length+1:) = ' records from file '//path
	length = len1(line)
	call output(line(1:length))
c
	call txtclose(tIn)
	end
c************************************************************************
	subroutine GetRaDec(nscan,iscan,data,time,ra,dec)
c
	implicit none
	integer nscan,iscan
	double precision data(6,nscan),time,ra,dec
c------------------------------------------------------------------------
	if(iscan.le.nscan-1.and.time.ge.data(1,iscan).and.
     *			      time.lt.data(1,iscan+1))then
	  continue
	else if(iscan.le.nscan-2.and.time.ge.data(1,iscan+1).and.
     *			             time.lt.data(1,iscan+2))then
	  iscan = iscan + 1
	else if(time.ge.data(1,nscan))then
	  iscan = nscan
	else
	  if(time.lt.data(1,iscan))iscan = 1
	  dowhile(time.gt.data(1,iscan+1))
	    iscan = iscan + 1
	  enddo
	endif
c
	ra  = data(3,iscan) + data(5,iscan)*(time-data(2,iscan))
	dec = data(4,iscan) + data(6,iscan)*(time-data(2,iscan))
c
	end
c************************************************************************
	subroutine Jupfix(uv,freq,data,nchan,dra,ddec)
c
	implicit none
	integer nchan
	double precision uv(2),dra,ddec,freq(nchan)
	complex data(nchan)
c
c  Correct for a error in the phasing of the data. Use the small
c  angle approximation.
c
c  Input:
c    lIn	Handle of the input data-set.
c    nchan	Number of channels.
c    uv		UV coordinates, in nanosec.
c    freq	Sky frequency, in GHz.
c    dra,ddec	Shift to apply in radians.
c		True Position = Incorrect_Position + dra/ddec
c  Input/Output:
c    data	Visibility data.
c------------------------------------------------------------------------
	include 'mirconst.h'
c
	integer i
	real theta,theta0
	complex w
c
	theta0 = -2*dpi*( uv(1)*dra + uv(2)*ddec )
c
	do i=1,nchan
	  theta = theta0 * freq(i)
	  w = cmplx(cos(theta),sin(theta))
	  data(i) = w * data(i)
	enddo
c
	end
c************************************************************************
	logical function varprsnt(tno,var)
c
	implicit none
	integer tno
	character var*(*)
c
c  Determine whether a variable is present.
c------------------------------------------------------------------------
	character type*1
	logical upd
	integer n
c
	call uvprobvr(tno,var,type,n,upd)
	varprsnt = type.ne.' '
	end

