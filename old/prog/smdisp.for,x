      program smdisp
c-----------------------------------------------------------------------
c
c= SMDISP - displays and overlays images on a PGPLOT device
c& lss
c: plotting
c+
c	SMDISP displays/overlays images via contour plots, pixel map
c	representations, vectors and scaled boxes on a PGPLOT device. 
c	Upto 3 contour plots, one pixel map, one vector plot and one box 
c	display may be overlaid in multi-panel plots of multi-channel 
c	images.  In addition overlay locations (plotted as boxes, stars,
c	lines or see-through) may be specified from an ascii text file.
c
c	Manipulation of the device colour lookup table is available
c	when you display with a pixel map representation (formerly
c	called a "grey scale")
c
c@ in
c	You may input up to 7 images.  Upto 3 of these can be displayed 
c	via contour plots and 1 can be displayed via a colour pixel map 
c	representation.  1 vector amplitude image and 1 vector position
c	angle image (degrees; positive N -> E) can together be used to
c	display a vector map (e.g. polarization vectors).  1 image can
c	be displayed as small scaled boxes (see below) and 1 image may be
c	used as a mask.  
c
c	The "box" image is displayed by drawing little boxes (solid and
c	hollow for positive and negative pixels) at the location of each
c	selected pixel.  The size of the box scales with the value of the
c	pixel.  This is a useful way to display rotation measure images 
c	for example. The mask image blanking mask is logically ORed to all
c	the other image masks before they are displayed. The mask image 
c	is not displayed.
c
c	If more than one image is specified, they must have identical 
c	first and second dimensions.  However, you can overlay combinations
c	of 2-D with 3-D images (e.g. multi-channel images with a continuum 
c	image) provided all the 3-D images have the same third dimension. 
c	These images can be input in any order (see TYPE).
c	Wild card expansion is supported.    No default.
c@ type
c	Specifies the type of each image listed in the IN keyword.
c	Minimum match is supported (note that "pixel" was formerly "grey"
c	which is still supported).   Choose from:
c
c	"contour"   (contour;            up to 3 of these)
c	"pixel"     (pixel map;          up to 1 of these)
c	"amplitude" (vector amplitude;   up to 1 of these)
c	"angle"     (vector pos'n angle; up to 1 of these)
c	"box"       (box;                up to 1 of these)
c	"mask"      (mask;               up to 1 of these)
c
c	You can't give one of "amplitude" or "angle" without the other.
c	Default is "pixel" for one image, "contour" if more than one.
c@ region
c	Region of interest.  Choose only one spatial region (bounding box
c	only supported), but as many spectral regions (i.e., multiple 
c	IMAGE specifications) as you like.   Each channel (or group of 
c	channels; see CHAN below) is drawn on a new sub-plot.  
c	NOTE: the region specification applies equally to all the 
c	input images.
c	Default is full image
c@ xybin
c	Upto 4 values.  These give the spatial increment and binning
c	size in pixels for the x and y axes to be applied to the selected
c	region.   If the binning size is not unity, it must equal the 
c	increment.  For example, to bin up the image by 4 pixels in 
c	the x direction and to pick out every third pixel in the y 
c	direction, set XYBIN=4,4,3,1
c	Defaults are 1,XYBIN(1),XYBIN(1),XYBIN(3)
c@ chan
c	2 values. The first is the channel increment to step through the
c	image in, the second is the number of channels to average, for 
c	each sub-plot.  Thus CHAN=5,3  would average groups of 3 channels 
c	together, starting 5 channels apart such as: 1:3, 6:8, 11:13 ...  
c 	The channels available are those designated by the REGION keyword.
c	A new group of channels (sub-plot) is started if there is a 
c	discontinuity in the REGION selected channels (such as 
c	IMAGE(10,20),IMAGE(22,30).  The combination of REGION and CHAN 
c	determines how many sub-plots there will be.
c
c	In the case that you have input some combination of 2-D and 3-D
c	images, CHAN refers to the 3-D image(s). Note that a channel
c	is defined to be a pixel on the third axis of a cube, regardless
c	of the cube's order (xyv or vxy say).
c	Defaults are 1,1
c@ slev
c	Up to 3 pairs of values, one for contour image. First value is 
c	the type of contour level scale factor.  "p" for percentage and 
c	"a" for absolute.   Second value is the factor to scale LEVS by. 
c	Thus, SLEV=p,1  would contour levels at LEVS * 1% of the image 
c	peak intensity.  Similarly, SLEV=a,1.4e-2 would contour levels 
c	at LEVS * 1.4E-2
c	Default is no additional scaling of LEVS (i.e., "a",1.0)
c@ levs1
c	The levels to contour for the first specified contour image are 
c	LEVS1 times SLEV (either percentage of the image peak or absolute).
c	Defaults try to choose something vaguely useful.
c@ levs2
c	LEVS for the second contour image.
c@ levs3
c	LEVS for the third contour image.
c@ range
c	Upto 100 groups of 4 values (1 group per subplot). These are 
c	the image intensity range to display (min to max), the transfer 
c	function type and the colour lookup table for each subplot 
c	displayed.  The transfer function type can be one of "lin" 
c	(linear), "sqr" (square root), "log" (logarithmic), and "heq" 
c	(histogram equalization).  The colour lookup table is an integer 
c	from 1 to 8 specifying a lookup table. Valud values are 1 (b&w),
c	2 (rainbow), 3 (linear pseudo colour), 4 (floating zero colour 
c	contours), 5 (fixed zero colour contours), 6 (rgb), 7 (background)
c	8 (heat) and 9 (absolute b&w) .  If you enter a negative 
c	integer, then the reversed lookup table is displayed.  
c
c	The transfer function changes available with OPTIONS=FIDDLE 
c	are in addition (on top of) to the selections here, but the 
c	colour lookup table selections will replace those selected here.
c
c	All subplots following the last one with a specified "range"
c	will use the "range" settings from the previous subplot. In
c	this way, one group of settings can be applied to all the 
c	subplots if desired.  The multiple subplot capability is useful
c	if you have used IMCAT to put unlike images into planes of
c	a cube and you wish to display them together.
c
c	Default is linear between the image minimum and maximum with
c	a b&w lookup table.   You can default the intensity range with
c	zeros, viz. "range=0,0,log,-2" say.
c@ vecfac
c	3 values.  A scale factor to multiply the vector image lengths
c	(or box image widths) by, and the x and y increments (in pixels)
c	across the image  at which to plot the vectors (or boxes).  If 
c	you have set non unit values of XYBIN, the increments here refer 
c	to the binned pixels.  When VECFAC(1)=1, the vectors (boxes) are 
c	scaled so that the maximum amplitude (width) takes 1/20 of the 
c	(sub)plot size.  
c	Defaults are 1.0, 2, VECFAC(2)
c@ boxfac
c	3 values.  A scale factor to multiply the box image widths by, 
c	and the x and y increments (in pixels) across the image at which
c	to plot the boxes).  If have set non unit values of XYBIN, the 
c	increments here refer to the binned pixels.  When BOXFAC(1)=1, 
c	the boxes are scaled so that there is a little bit of space
c	between adjacent boxes.
c	Defaults are 1.0, 2, BOXFAC(2)
c@ device
c	The PGPLOT plot device, such as plot.plt/ps 
c	No default.
c@ nxy
c	Number of sub-plots in the x and y directions on the page. 
c	Defaults choose something depending on your telescope.
c@ labtyp
c	Up to 2 values.  The spatial label type of the x and y axes.
c	Minimum match is active.  Select from:
c
c	"hms"       the label is in H M S.S (e.g. for RA)
c	"dms"       the label is in D M S.S (e.g. for DEC)
c	"arcsec"    the label is in arcsecond offsets
c	"absdeg"    the label is in degrees
c	"reldeg"    the label is in degree offsets
c		    The above assume the pixel increment is in radians.
c	"abspix"    the label is in pixels
c	"relpix"    the label is in pixel offsets
c	"abskms"    the label is in Km/s
c	"relkms"    the label is in Km/s offsets
c	"absghz"    the label is in GHz
c	"relghz"    the label is in GHz offsets
c	"abslin"    the label is in linear coordinates as defined by 
c	            the header. You might call this the natural axis label
c	"rellin"    the label is in offset linear coordinates
c	"none"      no label and no numbers or ticks on the axis
c
c	All offsets are from the reference pixel.  
c	Defaults are "relpix", LABTYP(1)   except if LABTYP(1)="hms" when
c	LABTYP(2) defaults to "dms"  (to give RA and DEC)
c@ options
c	Task enrichment options. Minimum match of all keywords is active.
c
c	"relax" means issue warnings when image axis descriptors are
c	  inconsistent (e.g. different pixel increments) instead
c	  of a fatal error.  Use at your peril.
c
c	"full" means do full plot annotation with contour levels, pixel
c	  displa range, file names, reference values, etc.  Otherwise 
c	  more room for the plot is available. 
c	"noepoch" means don't write the epoch value into the axis labels
c
c	"fiddle" means enter a routine to allow you to interactively change
c	  the display lookup table.  You can cycle through a variety of
c	  colour lookup tables, as well as alter a linear transfer function
c	  by the cursor location, or by selecting predefined transfer 
c	  functions (linear, square root, logarithmic, histogram equalization)
c	  
c	  For hard copy devices (e.g. postscript), a keyboard driven
c	  fiddle is offered; you can cycle through different colour tables
c	  and invoke the predefined transfer functions, but the linear
c	  fiddler is not available.   Note that if you are using "smdisp"
c	  from a script, so that interactive fiddling is not appropriate,
c	  you can use the "range" keyword to specify the transfer
c	  function and colour lookup tables.
c	"single" means that when you have selected OPTIONS=FIDDLE and you
c	  you have more than one subplot per page, activate the fiddle
c	  option after each subplot rather than the default, which is
c	  to fiddle only at the end.  In the latter case, the histogram
c	  equalization, if invoked, will have been computed with the 
c	  image in the last subplot only.
c	"wedge" means that if you are drawing a pixel map, also draw
c	  and label a wedge to the right of the plot, showing the map 
c	  of intensity to colour.
c
c	"3value" means label each sub-plot with the appropriate 
c	  value of the third axis (e.g. velocity or frequency for an
c	  xyv ordered cube, position for a vxy ordered cube).
c	"3pixel" means label each sub-plot with the pixel value of
c	  the third axis.
c	  Both "3pixel" and "3value" can appear, and both will be 
c	  written on the plot.  They are the average values when
c	  the third axis is binned up with CHAN.  If the third axis
c	  is not velocity or frequency, the units type for "3VALUE" 
c	  will be chosen to be the complement of any like axis in the 
c	  first 2. E.g., the cube is in vxy order and LABTYP=ABSKMS,ARCSEC 
c	  the units for the "3VALUE" label will be arcsec.  If 
c	  LABTYP=ABSKMS,HMS the "3VALUE" label will be DMS (if the 
c	  third [y] axis is declination).
c	"noerase" means don't erase a rectangle into which the "3-axis"
c	  values and the overlay ID strings are written.
c	  
c	  
c	"beamAB", where "A" is one of "b" or "t" and 
c	                "B" is one of "l" or "r"
c	  means draw the beam FWHM on the plot in the corner indicated
c	  by the "AB" location.  The beams for all images displayed
c	  (contour and pixel map) will be drawn confocally.
c
c	"solneg1" means make negative contours solid and positive 
c	  contours dashed for the first contour image. The default, 
c	  and usual convention is the reverse.
c	"solneg2" SOLNEG1 for the second contour image.
c	"solneg3" SOLNEG1 for the third contour image.
c	"mirror" causes all specified contour levels for all images
c	  to be multiplied by -1 and added to the list of contours
c
c	"rot90" rotates vectors by an extra 90 degrees.  Useful
c	  to convert E-vectors into B-vectors
c	"signs"  Normally, when plotting vectors, SMDISP assumes that
c	  North is up and East to the left.  If OPTIONS=SIGNS, then
c	  it assumes that E and N are in the direction of increasing
c	  X and Y.
c
c	"unequal" means draw plots with unequal scales in x and y
c	  so that the plot surface is maximally filled.  The default
c	  is for equal scales in x and y.
c	"gaps" means leave gaps between sub-plots and label each 
c	  sub-plot, otherwise they will abut each other.
c@ lines
c 	Up to 6 values.  The line widths for the axes, each contour 
c       image (in the order of TYPE), the vector image, and any overlays.
c	If there are less than 3 contour images or no vector
c	image, the vector image/overlay line widths shift left.
c	Line widths must be integers.
c	Defaults are 1,1,1,1,1,1
c@ break
c	Up to 3 values. The intensity levels for the break between
c	solid and dashed contours for each contour image. 
c	Defaults are 0.0,0.0,0.0
c@ csize
c	Up to 3 values.  Character sizes in units of the PGPLOT default
c	(which is ~ 1/40 of the view surface height) for the plot axis
c	labels, the velocity/channel label, and the overlay ID string
c	(if option "write" in OLAY used) label.
c	Defaults choose something sensible.  Use 0.0 to default the 
c	first or second, but not the second or third, e.g., 0.0, 1.5
c@ scale
c	Up to 2 values.  Scales in linear axis units/mm with which to plot
c	in the 	x and y directions.  For example, if the increments 
c	per pixel are in radians, then this number would be radians/mm
c	(note that for RA axes you give radians on the sky per mm).
c	Although this choice of unit may be cumbersome, it makes no 
c	assumptions about the axis type, so is more flexible.   If you 
c	also chose OPTIONS=EQUAL then one of your scales, if you set 
c	both and differently, would be over-ruled.  If you give only 
c	one value, the second defaults to that.  
c	Defaults choose scales to fill the page optimally. To default 
c	the first but the second, use 0.0,scale(2)
c@ olay
c	The name of a file containing a list of overlay descriptions.
c	Wild card expansion is active and the default is no overlays.
c	
c	Miriad task CGCURS OPTIONS=CURSOR,LOG,CGDISP  can be used to
c	make an overlay file.
c
c	Entries in the overlay file can be white space or comma
c	delimitered or both.  All lines beginning with # are ignored.
c
c	                **** DO NOT USE TABS **** 
c
c	Double quotes " are used below to indicate a string.  The "
c	should not be put in the file.   For all the string parameters
c	discussed below, you can abbreviate them with minimum match.
c
c
c	Each line describes an overlay and should be as follows:
c
c	 ##### The first 5 columns in each line must be
c
c	  1      2       3     4    5        Column
c	--------------------------------
c	OFIG  XOTYPE  YOTYPE  ID  WRITE      where
c
c	OFIG is the type of overlay; choose from
c	 "star"    for stars (crosses; give centre and half-sizes)
c	 "circle"  for a filled in circle (give centre)
c	 "ocircle" for an open circle (give centre)
c	 "box"     for boxes (give centre and half-sizes)
c	 "line"    for line segments (give blc and trc)
c	 "clear"   for a see-through overlay -- thus you can write the
c	 	   overlay ID string (see below) without the overlay
c
c	XOTYPE and YOTYPE  give the units of the overlay location (and 
c	overlay half-sizes) contained in the file for the x- and y-
c	directions, respectively.  Choose from:
c	 "hms", "dms", "arcsec", "absdeg", "reldeg", "abspix", 
c	 "relpix", "abslin", "rellin", "absghz", "relghz", 
c	 "abskms", & "relkms"  as described in the keyword LABTYP.  
c	Note that OTYPE does not depend upon what you specified for LABTYP.
c
c	ID is an identifying overlay string which can be optionally
c	written on the overlay; it MUST be in the overlay file whether
c	you write it on the plot or not).  The ID string is written in the
c	corner for "star" and "box", in the centre for "clear" and
c	at the end for "line"
c
c	WRITE is "yes" or "no" to specify if the overlay ID is to be 
c	written in the corner of overlay figure or not.
c
c
c	 ##### Columns beyond number 5 depend upon OFIG, XOTYPE, and YOTYPE
c
c	6   7    8   9  10  11    Logical column
c	-----------------------
c	X   Y   XS  YS  CS  CE    for OFIG="box" and "star"
c	X1  Y1  X2  Y2  CS  CE    for OFIG="line"
c	X   Y   CS  CE            for OFIG="clear"
c	X   Y   S   CS  CE        for "circle" and "ocircle"
c
c	X,Y defines the center of the overlay in the nominated OTYPE
c	coordinate system (X- and Y-OTYPE can be different).  
c	(X1,Y1) & (X2,Y2) are the end points of the line segment in the
c	nominated OTYPE (mixed OTYPEs are supported here too).
c	For %OTYPE = "abspix ", "relpix", "arcsec", "absdeg", "reldeg",
c		     "absghz", "relghz", "abskms", "relkms", "abslin"
c		     and "rellin" X,Y,X1,Y1,X2,Y2 are single numbers.
c
c	For %OTYPE = "hms" or "dms", the X and/or Y location is/are replaced
c	by three numbers such as  HH MM SS.S or DD MM SS.S.  Thus if
c	XOTYPE=hms & YOTYPE=dms then the file should have lines like
c
c	  HH MM SS.S   DD MM SS.S   XS   YS  CHAN    for OFIG="box"
c
c
c	XS, YS are the overlay half-sizes in the following units.
c	%OTYPE = "abspix" and "relpix" in pixels
c		 "hms"    and "dms"    in arcseconds
c		 "arcsec"              in arcseconds
c		 "absdeg" and "reldeg" in degrees
c		 "absghz" and "relghz" in GHz
c		 "abskms" and "relkms" in Km/s
c	 	 "abslin" and "rellin" in linear coordinates
c	S is the radius of circle overlays.  It is in the units given
c	in the above list according to XOTYPE only.
c
c	CS to CE is the channel range (image planes) on which to put the 
c	overlays.  If you specify only CS than the overlay is put
c	on that channel.  If CS=0 then the overlays are put on all
c	channels. 
c
c	For OFIG="box" and "star", XS, YS are optional.  The defaults
c	are XS=2, YS=XS pixels.   In all cases, CS and CE  are optional
c	and the default is 0 (all channels)
c
c
c	#####  The OFFSET line
c
c	At any point in the overlay file, you can include an OFFSET
c	line in the format
c	
c	"OFFSET"   XOFF   YOFF
c
c	where the literal "OFFSET" (without the quotes) must appear
c	as the first thing in the line, followed by X and Y offsets,
c	which are applied to all succeeding overlay file locations.
c	       X = X + XOFF;   Y = Y + YOFF
c	These offsets must be in the same units as the %OTYPE that the
c	succeeding line(s) has(ve).  It is intended so that your overlay
c	locations can be in, say, arcsec relative to some location which
c	is not the reference pixel of the image (which is what SMDISP
c	ultimately wants).   You then specify, with the OFFSET line, the
c	offsets between the reference pixel of the contour/pixel map
c	images and the actual reference location of your overlay locations.
c
c	You can have as many OFFSET lines as you like in the file.  All
c	succeeding lines will apply these offsets until new ones are
c	defined.  If the line does not appear, naturally no additional
c	offsets are added.
c
c	The OFFSET line is not applied to ANY position fields in succeeding
c	lines that have %OTYPEs that are "hms" or "dms".    I am too lazy
c	to code it.
c
c--
c
c  History:
c    nebk 27Aug89  Original and near perfect version
c    rjs   4oct89  Fixed some nonstandard FORTRAN.
c    rjs  23oct89  Changed 'pdev' to 'device'.
c    rjs  15nov89  Changed call sequence to mkeyr.
c    pjt   2may90  Replaced maxchan by mxchan because of new maxdim.h
c    nebk  9sep90  Fixed some wrong code in dim. compat. checks.
c    nebk 12oct90  Add floating solid/dashed contour level break point
c    rjs  25oct90  Merges nebk's version with the BIMA version.
c    nebk 17dec90  Increase size of annot to 3 characters
c    nebk 09jan91  Combine plev and alev into slev. Replace chan,blc,trc
c                  by region and reduced chan. combine ofile and otype 
c		   into olay. Combine annot, aspect & part of lines into
c		   options. Interpret returned pgbegin status correctly.
c    nebk 14jan91  Deal with blanked pixels and redistribute top level code.
c    nebk 18jan91  Add second contour image
c    nebk 22jan91  Change default plot device to "?"
c    nebk 30jan91  Change data statement for contour blanking to a standard
c                  F77 syntax and speed up contouring for an unblanked image
c    nebk  5mar91  Change itoa to itoaf, atoi to atoif, atod to atodf
c                  and add epoch to annotation of plot.
c    mjs/nebk
c         10mar91  Removed concatenated char*(*) variables in sub calls
c    nebk 12mar91  Change keya to keyf for input files.
c    nebk 09apr91  Better memory management to allow bigger images.
c    nebk 24apr91  Adjust for new pgtime routines
c    nebk 05jun91  Adjust calls to pgpage
c    rjs  22jul91  Added 's' flag to BoxSet calls.
c    nebk 10aug91  Was not recognizing "lo" type overlays.
c    nebk 11aug91  Account for offset for log grey scales and cin=gin
c    nebk 04sep91  Deal with discontinously selected groups of channels.
c    nebk 11sep91  Add options=beam%% and rename from cgplot
c    nebk 20sep91  Stripped subroutines common with pgcurs into subspg.for
c    nebk/mjs
c         12nov91  Initialize ep2 if no second contour image
c    nebk/mjs
c         13mar92  Name change:  pgdisp -> cgdisp
c    nebk 07apr92  Adapt to memalloc subs. & add source name to annotation
c    nebk 29apr92  Fix problem with character size getting lost and
c                  rename *pg subroutines to *cg
c    nebk 05may92  Full annotation not showing for nxy=1 (introduced 29apr92)
c    nebk 18may92  Major road works to add extra contour & vector images
c    nebk 02jun92  Allow contour images to be the same, bring olay in-line
c		   with new labtyp & change call to chnselcg
c    nebk 06jun92  Combine overlay drawing into one subroutine and cause
c		   all lines in olay file begining with # to be ignored
c    nebk 22jun92  Put all overlay info into overlay file and impliment
c		   "line" and "clear" overlays. CHange options=equal
c		   to unequal.   
c    nebk 04jul92  Strip otopix, settr, linelev, conwrite, contents of
c		   fullann, vpchdef, chkds2 to cgsubs.for. add op=mirror
c		   & replace readc/g/v with readimcg.  Use deghmscg
c    nebk 10jul92  Go to optcg instead of options. Remove call to BOXMASK
c    nebk 17jul92  Add the overlay  offset line facility.
c    nebk 09aug92  Modify for new o2pixcg/w2pixcg code, strip code to
c		   strprpcg and omatchcg
c    nebk 01oct92  Overlay size decoding code was rubbish as of 09aug92.
c    nebk 16oct92  Add informational suggestion for options=unequal use
c    nebk 28nov92  Add velocity and frequency label types and change
c                  linear -> abslin.
c    nebk 28jan93  Remove some unnecessary code to do with opening
c                  the same file twice
c    mjs  12mar93  Use maxnax.h file instead of setting own value.
c    mjs  13mar93  pgplot subr names have less than 7 chars.
c    nebk 21apr93  Replace options=chan,vel by generic 3pix,3vel
c    nebk 20may93  Tell user to use options=relax when appropriate
c    nebk 29may93  Replace call to chtonvcg by new PG routine pgqcs
c    nebk 02jun93  Replace calls to vssizecg by new PG routine pgqvsz
c    nebk 23jun93  Add options=wedge. Use pgqcs to remove need for vpasp,
c                  change for new call to vpadjcg, rework beam plotting.
c                  Make "clear" overlays appear again !
c    nebk 15jul93  Try and make beams come out right way around again
c    nebk 24aug93  Convert overlay channel field to channel range. Add
c		   LABTYPs "absdeg" and "reldeg".  Add options=noerase
c                  and noepoch
c    nebk 17nov93  's' flag to boxset. Add labtyp="none".
c    nebk 14dec93  Add type=mask, ofig=circle. Strip limits to limitscg
c    nebk 03jan94  New call to matchcg (formerly omatchcg)
c    nebk 09jan94  Convert crpix to double precision
c    nebk 29jan94  Add options=fiddle and range transfer function types
c		   "heq" and "sqr".  Strip viewsize to vpsizcg. Allow
c                  clear overlays to fall off edge of image.
c    nebk 05feb04  Add 1 grey range/transfer f'n per subplot ability
c    nebk 02mar94  New call and location for SETLABCG
c    nebk 11mar94  Implement spatial binning and OPTIONS=SINGLE
c    nebk 16jun94  Clarify use of region keyword, add overlay type
c		   "ocircle" and change "circle" to include radius.
c		   Better locating of overlay ID string.
c    nebk 30jun94  Add image type "box", and add one more "line" 
c		   argument to make axes independent.
c    nebk 08aug94  Remove 's' from boxset which naughty robbie included 
c                  in 1991. This broke the ability to handle 
c                  discontinuous planes (for 3 years !)
c    nebk 26aug94  Change to convert overlay locations in true world
c                  coordinates to linear world coordinates for plotting.
c                  Linearize axis descriptors at the centre of the
c                  displayed region.  Call new LAB3CG which labels with true 
c                  world coords on third axis.
c    nebk 23dec94  Make sure selected region no bigger than image
c    nebk 05jan95  Use new PGIMAG in favour of PGGRAY adding support
c                  for fiddling of lookup table for hardcopy devices
c                  Make sure annotation writes reference location as 
c                  original, not linearized version
c    nebk 20feb95  Add colour table selection to keyword "range" and
c		   get pgimag to make black on white for hard copy.
c		   Move to image type "pixel" instead of "grey"
c    nebk 10apr95  Accomodate absolute b&w lookup table 
c-----------------------------------------------------------------------
      implicit none
c
      include 'maxdim.h'
      include 'maxnax.h'
      include 'mem.h'
      real wedwid, wedisp, tfdisp
      integer maxlev, maxpos, nxdef, nydef, maxcon, 
     +        maxtyp, nbins, maxgr
      parameter (maxlev = 50, maxpos = 1000, nxdef = 4, maxtyp = 14,
     +  nydef = 4, maxcon = 3, maxgr = 100, wedwid = 0.05,
     +  wedisp = 1.0, tfdisp = 0.5, nbins = 128)
c
      integer ipim, ipnim, ipim2, ipnim2, ipimm
c
      integer csize(maxnax,maxcon), gsize(maxnax), vsize(maxnax,2),
     +  msize(maxnax), bsize(maxnax), size(maxnax), cnaxis(maxcon), 
     +  gnaxis, vnaxis(2), mnaxis, bnaxis, naxis, lc(maxcon), lg, 
     +  lv(2), lm, lb, lhead
      real cepoch(maxcon), gepoch, vepoch(2), mepoch, bepoch, epoch
      double precision cdelt(maxnax), crval(maxnax),
     +  scdelt(maxnax), scrval(maxnax),
     +  ccdelt(maxnax,maxcon), ccrval(maxnax,maxcon), 
     +  gcdelt(maxnax), gcrval(maxnax), 
     +  vcdelt(maxnax,2), vcrval(maxnax,2), 
     +  mcdelt(maxnax), mcrval(maxnax),
     +  bcdelt(maxnax), bcrval(maxnax),
     +  crpix(maxnax), scrpix(maxnax), ccrpix(maxnax,maxcon), 
     +  gcrpix(maxnax), vcrpix(maxnax,2), mcrpix(maxnax),
     +  bcrpix(maxnax), opos(6,maxpos)
      logical maskc(maxcon), maskg, maskv(2), maskm, maskb
      character*9 ctype(maxnax), sctype(maxnax), cctype(maxnax,maxcon), 
     +  gctype(maxnax), vctype(maxnax,2), mctype(maxnax), bctype(maxnax)
      character cin(maxcon)*64, gin*64, vin(2)*64, mskin*64, bin*64,
     +  ltypes(maxtyp)*6
c
      real levs(maxlev,maxcon), pixr(2,maxgr), tr(6), bmin(maxcon+4), 
     +  bmaj(maxcon+4), bpa(maxcon+4), bxfac(maxcon+4),
     +  byfac(maxcon+4), scale(2), cs(3), pixr2(2), slev(maxcon),
     +  break(maxcon), vfac(2), bfac(5), tfvp(4), wdgvp(4), 
     +  cumhis(nbins), gmm(2), cmm(2,maxcon), dmm(2)
      real xmin, xmax, ymin, ymax, vxmin, vymin, vymax, vx, vy,
     +  vxsize, vysize, vxgap, vygap, ydispb, xdispl, groff, blankg,
     +  blankc, blankv, blankb, vecfac, boxfac
      real x1, x2, y1, y2
c
      integer blc(3), trc(3), win(2), lwid(maxcon+3), 
     +  vecinc(2), boxinc(2), srtlev(maxlev,maxcon), nlevs(maxcon), 
     +  grpbeg(maxchan), ngrp(maxchan), his(nbins), ibin(2), jbin(2), 
     +  kbin(2), krng(2), coltab(maxgr)
      integer  nx, ny, lpos, npos, ierr, pgbeg, ilen, igr, nlast, 
     +  ngrps, ncon, i, j, nvec, ipage, jj, npixr, wedcod
c
      character ofig(maxpos)*10, posid(maxpos)*20, labtyp(2)*6, 
     +  levtyp(maxcon)*1
      character pdev*64, xlabel*40, ylabel*40, xopts*20, yopts*20,
     +  hard*20, ofile*64, xxopts*22, yyopts*22, trfun(maxgr)*3,
     +  aline*72
c
      logical solneg(maxcon), doblv(2), bemprs(maxcon+4), owrite(maxpos)
      logical do3val, do3pix, dofull, gaps, eqscale, doblc, doblg,
     +  dobeam, beaml, beamb, relax, rot90, signs, mirror, dowedge, 
     +  doerase, doepoch, bdone, doblb, doblm, dofid, dosing
c
      data blankc, blankv, blankb /-99999999.0, -99999999.0, 
     +                             -99999999.0/
      data lc, lg, lv, lb, lm /maxcon*0, 0, 2*0, 0, 0/
      data gin, vin, bin, mskin /' ', 2*' ', ' ', ' '/
      data bdone /.false./
      data ipage /0/
      data ltypes /'hms   ', 'dms   ', 'abspix', 'relpix', 'arcsec',
     +             'absghz', 'relghz', 'abskms', 'relkms', 'abslin', 
     +             'rellin', 'absdeg', 'reldeg', 'none'/
      data dmm /2*0.0/
      data coltab /maxgr*0/
c-----------------------------------------------------------------------
      call output ('SMDisp: version 28-Jul-95')
      call output ('New absolute b&w lookup table available')
      call output (' ')
      call output ('Keyword "range" can now be used to specify the')
      call output ('colour lookup table as well the transfer function')
      call output (' ')
c
c Get user inputs
c
      call inputs (maxgr, maxlev, maxcon, maxtyp, ltypes, ncon, cin, 
     +   gin, nvec, vin, bin, mskin, ibin, jbin, kbin, levtyp, slev, 
     +   levs, nlevs, npixr, pixr, trfun, coltab, vecfac, vecinc, 
     +   boxfac, boxinc, pdev, labtyp, dofull, do3val, do3pix, eqscale, 
     +   gaps, solneg, nx, ny, lwid, break, cs, scale, ofile, dobeam, 
     +   beaml, beamb, relax, rot90, signs, mirror, dowedge, doerase, 
     +   doepoch, dofid, dosing)
c
c Open images as required
c
      call sesame (relax, maxdim, maxnax, maxcon, ncon, cin, lc, cnaxis, 
     +  csize, cepoch, maskc, ccrpix, ccdelt, ccrval, cctype, gin, lg, 
     +  gnaxis, gsize, gepoch, maskg, gcrpix, gcdelt, gcrval, gctype,
     +  vin, lv, vnaxis, vsize, vepoch, maskv, vcrpix, vcdelt, vcrval,
     +  vctype, bin, lb, bnaxis, bsize, bepoch, maskb, bcrpix, bcdelt,
     +  bcrval, bctype, mskin, lm, mnaxis, msize, mepoch, maskm, mcrpix,
     +  mcdelt, mcrval, mctype, gmm, cmm)
c
c Finish key inputs for region of interest and return generic 
c axis descriptors
c
      call region (maxcon, maxnax, ncon, cin, gin, vin, bin, lc, lg,
     +   lv, lb, cnaxis, gnaxis, vnaxis, bnaxis, csize, gsize, vsize, 
     +   bsize, ccrval, gcrval, vcrval, bcrval, ccdelt, gcdelt, vcdelt,
     +   bcdelt, ccrpix, gcrpix, vcrpix, bcrpix, cctype, gctype, vctype,
     +   bctype, cepoch, gepoch, vepoch, bepoch, naxis, size, crval, 
     +   cdelt, crpix, ctype, epoch, ibin, jbin, kbin, blc, trc, win, 
     +   maxchan, grpbeg, ngrp, ngrps, lhead)
c
c Try to allocate memory for images
c
      call memalloc (ipim,  win(1)*win(2), 'r')
      call memalloc (ipnim, win(1)*win(2), 'i')
      if (vin(1).ne.' ' .and. vin(2).ne.' ') then
        call memalloc (ipim2,  win(1)*win(2), 'r')
        call memalloc (ipnim2, win(1)*win(2), 'i')
      end if
      if (mskin.ne.' ') call memalloc (ipimm,  win(1)*win(2), 'l')
c
c Compute contour levels for each contour image
c
      if (ncon.gt.0) then
        do i = 1, ncon
          call conlevcg (mirror, maxlev, lc(i), cnaxis(i), csize(1,i), 
     +       levtyp(i), slev(i), nlevs(i), levs(1,i), srtlev(1,i))
        end do
      end if
c
c Save and linearize axis descriptors if non-pixel labels requested
c
      call savdescg (naxis, ctype, crval, crpix, cdelt, sctype,
     +               scrval, scrpix, scdelt)
      call linco (lhead, labtyp, blc, trc, grpbeg, ngrp, ctype,
     +            crval, crpix, cdelt)
c
c Work out array index limits, coordinate transformation array & labels
c
      call limitscg (labtyp, blc, trc, naxis, epoch, crpix, cdelt,
     +   crval, ctype, doepoch, xmin, xmax, ymin, ymax, ibin, jbin,
     +   tr, xlabel, ylabel)
c
c Get beam information
c
      if (dobeam) 
     +   call getbeam (maxcon, cin, lc, gin, lg, vin, lv, bin, lb,
     +      labtyp, naxis, crval, crpix, cdelt, ctype, bmin, bmaj, bpa,
     +      bxfac, byfac, dobeam, bemprs)
c
c Work out number of plots per page and number of plots
c
      call nxnycg (nxdef, nydef, ngrps, nx, ny, nlast)
      if (ngrps.eq.1 .or. nx*ny.eq.1) gaps = .true.
      npixr = min(ngrps,npixr)
c
c Work out default character sizes for axis and channel labels
c
      call defchrcg (nx, ny, cs(1))
      write (aline, 100) cs(1), cs(2)
100   format ('Character sizes (axes & velocity) are: ', f3.1, ', ', 
     +         f3.1)
      call output (aline)
c
c Open plot device 
c
      ierr = pgbeg (0, pdev, 1, 1)
      if (ierr.ne.1) then
        call pgldev
        call bug ('f', 'Error opening plot device') 
      end if
      call pgpage
      call pgscf(2)
      call pgqinf ('hardcopy', hard, ilen)
c
c Init OFM routines 
c
      if (gin.ne.' ') call ofmini
c
c Work out if wedge outside or inside subplots. Also work out
c if plotting one wedge per subplot or one wedge for all
c
      call wedgincg (hard, dofid, dowedge, nx, ny, npixr, trfun, wedcod)
c  
c Set label displacements from axes and set PGTBOX labelling 
c option strings
c
      call setlabcg (labtyp, ymin, ymax, xdispl, ydispb, xopts, yopts)
c
c Work out view port sizes and increments.
c
      call vpsizcg (dofull, dofid, ncon, gin, vin, 0, bin, maxlev,
     +   nlevs, srtlev, levs, slev, nx, ny, cs, xdispl, ydispb, 
     +   gaps, wedcod, wedwid, wedisp, tfdisp, labtyp, vxmin, vymin, 
     +   vymax, vxgap, vygap, vxsize, vysize, tfvp, wdgvp)
c
c Adjust viewport increments and start locations if equal scales 
c requested or if scales provided by user
c
      call vpadjcg (hard, eqscale, scale, vxmin, vymin, vymax, nx, ny,
     +   blc, trc, naxis, crval, crpix, cdelt, ctype, tfvp, wdgvp, 
     +   vxsize, vysize)
c
c Set viewport location of first sub-plot
c
      vx = vxmin
      vy = vymax - vysize
c
c Loop over number of sub-plots
c
      do j = 1, ngrps
         if (mod(j,nx*ny).eq.1 .or. nx*ny.eq.1) ipage = ipage + 1
         jj = j - (ipage-1)*nx*ny
         if (hard.eq.'YES') then
            write (aline, '(a,i3)') 'Beginning plane ', grpbeg(j)
            call output (aline)
         end if
c
c Read overlay positions list and decode positions into pixels appropriate
c to the channel we are currently displaying
c
         call olaydec (lhead, grpbeg(j), ngrp(j),  maxtyp, ltypes, 
     +     maxpos, lpos, ofile, ofig, npos, opos, posid, owrite)
c
c Set viewport and window for current sub-plot.  
c
         call pgsvp (vx, vx+vxsize, vy, vy+vysize)
         call pgswin (xmin, xmax, ymin, ymax)
         call pgqvp (2, x1, x2, y1, y2)
         call pgsch (cs(1))
c
c Read in mask image as required
c
         if (mskin.ne.' ') then
           if (msize(3).gt.1) then
             krng(1) = grpbeg(j)
             krng(2) = ngrp(j)
             call readbcg (.true., lm, ibin, jbin, krng, blc, trc, 
     +                     meml(ipimm), doblm)
           else
             if (.not.bdone) then
               krng(1) = 1
               krng(2) = 1
               call readbcg (.true., lm, ibin, jbin, krng, blc, trc, 
     +                       meml(ipimm), doblm)
             else
               bdone = .true.
             end if
           end if
         end if
c
c Deal with pixel map image 
c
         if (gin.ne.' ') then
           if (gsize(3).gt.1) then
             krng(1) = grpbeg(j)
             krng(2) = ngrp(j)
           else
             krng(1) = 1
             krng(2) = 1
           end if
c
c Apply transfer function to pixel range. Apply the last
c transfer function given if there aren't enough.
c
           igr = min(j,npixr)
           call grfixcg (pixr(1,igr), lg, gnaxis, gsize, 
     +                   trfun(igr), pixr2, groff, blankg)
c
c Read pixel map image and apply mask
c
           call readimcg (.true., maskg, blankg, lg, ibin, jbin, krng,
     +         blc, trc, .true., memi(ipnim), memr(ipim), doblg, gmm)
           if (mskin.ne.' ' .and. doblm) then
             call maskorcg (blankg, win, meml(ipimm), memi(ipnim),
     +                      memr(ipim))
             doblg = .true.
           end if
c
c Apply transfer function directly to image
c
           if (trfun(igr).ne.'lin') 
     +       call apptrfcg (pixr2, trfun(igr), groff, win(1)*win(2),
     +          memi(ipnim), memr(ipim), nbins, his, cumhis)
c
c Apply specified OFM or do interactive fiddle to hardcopy 
c PGPLOT devices here
c
           if (hard.eq.'YES') call hardofm (coltab(j), pixr2, dofid, j, 
     +       jj, dosing, tfvp, win, memr(ipim), memi(ipnim))
c
c Draw image
c
           call pgimag (memr(ipim), win(1), win(2), 1, win(1), 
     +                  1, win(2), pixr2(1), pixr2(2), tr)
c
c Apply user specified OFM to PGPLOT device.   
c
           if (hard.ne.'YES') call intofm (coltab(j), j, pixr)
         end if
c
c Label and draw axes before fiddle else looks silly. Also forces
c update of pixel map on screen.
c
         call pgslw(lwid(1))
         call pgsci (7)
         if (hard.eq.'YES') call pgsci (2)
c_lss_s
c  Remove tick marks
c
         if (labtyp(1).eq.'hms' .and. labtyp(2).eq.'dms') then
            xopts='BCHYZO'
            yopts='BCDYZV'
         end if
c_lss_e         
         call axlabcg (gaps, nx, ny, ngrps, nlast, j, xopts, yopts,
     +      xdispl, ydispb, labtyp, xlabel, ylabel, xxopts, yyopts)
c_lss_x     call pgtbox (xxopts, 0.0, 0, yyopts, 0.0, 0)
c_lss_s
         if (labtyp(1).eq.'hms' .and. labtyp(2).eq.'dms') then
            call mygrid(lg,blc,trc,xxopts,yyopts)
         else
            call pgtbox (xxopts, 0.0, 0, yyopts, 0.0, 0)
         end if
c_lss_e
c
c Draw wedge now so that it overwrites axis label ticks when wedge
c drawn inside subplot
c
         if (dowedge) call wedgecg (wedcod, wedwid, jj, trfun(igr),
     +     groff, nbins, cumhis, wdgvp, pixr(1,igr), pixr(2,igr))
c
c Retake complement of OFM if needed (hard copy devices only)
c
         if (hard.eq.'YES') call ofmcmp
c
c Interactive modification of OFM for interactive devices here
c
         if (hard.eq.'NO' .and. dofid .and. 
     +       ((jj.eq.nx*ny .or. j.eq.ngrps) .or. dosing))
     +     call ofmmod (tfvp, win(1)*win(2), memr(ipim), 
     +                  memi(ipnim), pixr2(1), pixr2(2))
c
c Draw contour plots
c
         if (ncon.gt.0) then
           do i = 1, ncon
             if (csize(3,i).gt.1) then
               krng(1) = grpbeg(j)
               krng(2) = ngrp(j)
             else
               krng(1) = 1
               krng(2) = 1
             end if
             call readimcg (.true., maskc, blankc, lc(i), ibin, jbin, 
     +         krng, blc, trc, .true., memi(ipnim), memr(ipim), doblc,
     +         cmm(1,i))
             if (mskin.ne.' ' .and. doblm) then
               call maskorcg (blankc, win, meml(ipimm), memi(ipnim), 
     +                        memr(ipim))
               doblc = .true.
             end if
c
             call pgslw (lwid(i+1))
             call pgsci (7+i-1)
             call conturcg (blankc, solneg(i), win(1), win(2), doblc,
     +          memr(ipim), nlevs(i), levs(1,i), tr, break(i))
             call pgupdt
           end do
         end if
c
c Draw vector plots
c
         if (vin(1).ne.' ' .and. vin(2).ne.' ') then
           if (vsize(3,1).gt.1) then
             krng(1) = grpbeg(j)
             krng(2) = ngrp(j)
           else
             krng(1) = 1
             krng(2) = 1
           end if
           call readimcg (.true., maskv(1), blankv, lv(1), ibin, jbin,
     +                    krng, blc, trc, .true., memi(ipnim), 
     +                    memr(ipim), doblv(1), dmm)
           if (mskin.ne.' ' .and. doblm) then
             call maskorcg (blankv, win, meml(ipimm), memi(ipnim),
     +                      memr(ipim))
             doblv(1) = .true.
           end if
           call readimcg (.true., maskv(2), blankv, lv(2), ibin, jbin,
     +                    krng, blc, trc, .true., memi(ipnim2), 
     +                    memr(ipim2), doblv(2), dmm)
           if (mskin.ne.' ' .and. doblm) then
             call maskorcg (blankv, win, meml(ipimm), memi(ipnim2),
     +                      memr(ipim2))
             doblv(2) = .true.
           end if
c
           call pgslw (lwid(ncon+2))
           call pgsci (2)
c
           call drawvec (j, tr, vecfac, vecinc, win(1), win(2), 
     +        memr(ipim), memi(ipnim), memr(ipim2), memi(ipnim2),
     +        cdelt, scale, signs, rot90, vfac, nx, ny)
         end if
c
c Draw box plots
c
         if (bin.ne.' ') then
           if (bsize(3).gt.1) then
             krng(1) = grpbeg(j)
             krng(2) = ngrp(j)
           else
             krng(1) = 1
             krng(2) = 1
           end if
           call readimcg (.true., maskb, blankb, lb, ibin, jbin,
     +                    krng, blc, trc, .true., memi(ipnim), 
     +                    memr(ipim), doblb, dmm)
           if (mskin.ne.' ' .and. doblm) then
             call maskorcg (blankb, win, meml(ipimm), memi(ipnim),
     +                      memr(ipim))
             doblb = .true.
           end if
c
           call pgsci (6)
           call drawbox (j, tr, boxfac, boxinc, win(1), win(2), 
     +        memr(ipim), memi(ipnim), cdelt, scale, bfac)
         end if
c
c Write velocity or channel label
c
         if (do3val .or. do3pix) then
           call pgslw (1)       
           call pgsch (cs(2))
           call pgsci (1)
           call lab3cg (lhead, doerase, do3val, do3pix, labtyp,
     +                  grpbeg(j), ngrp(j))
         end if
c
c Draw overlay(s)
c
         if (npos.gt.0) then
           call pgsci (3)
           call pgslw (lwid(ncon+nvec+2))
           call overl (doerase, ofig, owrite, blc, trc, npos, opos, 
     +        posid, grpbeg(j), cs(3), labtyp, naxis, crval, crpix, 
     +        cdelt, ctype)
         end if
c
c Draw beam(s)
c
         if (dobeam) then
           call pgsci (4)
           call beampl (maxcon, beaml, beamb, bmin, bmaj, bpa,
     +                  bxfac, byfac, bemprs)
         end if
c
c Plot annotation
c
         if (dofull .and. (jj.eq.nx*ny .or. j.eq.ngrps)) then
           call pgslw (1)
           call pgsci (1)
           if (hard.eq.'NO') call pgsci (7)
           call fullann (maxcon, ncon, cin, gin, vin, bin, lc, lg,
     +        lv, lb, maxlev, nlevs, levs, srtlev, slev, npixr,
     +        trfun, pixr, vfac, bfac, naxis, size, scrval, scrpix,
     +        scdelt, sctype, vymin, blc, trc, cs, ydispb, ibin, 
     +        jbin, kbin, labtyp, gmm, cmm)
           call pgsci (1)
         end if  
c
c Increment sub-plot viewport locations and row counter and
c reinit data min and maxesc
c
         call subinccg (j, nx, ny, vxmin, vymax, vxsize, vysize, 
     +                  vxgap, vygap, vx, vy)
         call mmini (maxcon, gmm, cmm)
c
c Page plot device
c
         if (jj.eq.nx*ny .and. j.lt.ngrps) call pgpage
       end do
c
c Close up
c
      call pgend
c
      call memfree (ipim,  win(1)*win(2), 'r')
      call memfree (ipnim, win(1)*win(2), 'i')
      if (vin(1).ne.' '  .and. vin(2).ne.' ') then
        call memfree (ipim2,  win(1)*win(2), 'r')
        call memfree (ipnim2, win(1)*win(2), 'i')
      end if     
      if (mskin.ne.' ') call memfree (ipimm, win(1)*win(2), 'i')
c
      do i = 1, ncon
        call xyclose (lc(i))
      end do
      if (gin.ne.' ') call xyclose (lg)
      if (vin(1).ne.' ') call xyclose (lv(1))
      if (vin(2).ne.' ') call xyclose (lv(2))
      if (mskin.ne.' ') call xyclose (lm)
c
      end
c
c  
      subroutine beamfac (in, lin, labtyp, naxis, crval, crpix, cdelt,
     +                    ctype, bmin, bmaj, bpa, bxfac, byfac, pres)
c-----------------------------------------------------------------------
c     Work out factors to convert radians to world coordinates
c     for each axis for plotting of beam.
c
c  Input
c   in          Image name
c   lin         Image handle
c   labtyp      Label types
c   naxis       Number of axes in image
c   cdelt       Axis increments
c   crval       Reference values
c   ctype       Axis types
c   crpix       Axis reference pixels
c  Output
c   bmin        FWHMin of beam in image 
c   bmaj        FWHMax of beam
c   bpa         p.a. of beam
c               All in radians
c   bx,yfac     Factors to scale the x and y axes of the beam so that it
c               comes out plotted in world coordinates of the type
c               labeling the plot
c   pres        True if beam present in header
c-----------------------------------------------------------------------
      implicit none
c
      integer lin, naxis
      real bmin, bmaj, bpa, bxfac, byfac
      double precision crval(naxis), cdelt(naxis), crpix(naxis)
      character*(*) labtyp(2), ctype(naxis), in
      logical pres
cc
      character line*80
      integer il, len1, irad1, irad2
c-----------------------------------------------------------------------
      call rdhdr (lin, 'bmin', bmin,  -1.0)
      call rdhdr (lin, 'bmaj', bmaj,  -1.0)
      call rdhdr (lin, 'bpa',  bpa,  999.0)
c
      if (bmin.gt.0.0 .and. bmaj.gt.0.0) then
c
c Find if axes are those that have radian pixel increments. These are
c the only ones for which we can convert the beam size in radians 
c to world coordinates
c
        call axfndcg ('RAD', 1, ctype(1), irad1)
        call axfndcg ('RAD', 1, ctype(2), irad2)
c
        if (irad1*irad2.ne.0) then
          call beamfc2 (1, labtyp(1), naxis, ctype, cdelt, crval, 
     +                  crpix, bxfac)
          call beamfc2 (2, labtyp(2), naxis, ctype, cdelt, crval, 
     +                  crpix, byfac)
          pres = .true.
        else
          il = len1(in)
          line = 'Axes for image '//in(1:il)//
     +           ' are not recognized as having'
          call bug ('w', line)
          call bug ('w', 'increments in radians. Cannot plot beam')
        end if
      end if
c
      end
c
c
      subroutine beamfc2 (iax, labtyp, naxis, ctype, cdelt, crval,
     +                    crpix, fac)
c-----------------------------------------------------------------------
c  Find factor that converts radians to world coordinates
c
c  Input
c    iax       Axis we are interested in
c    labtyp    Axis label type for this axis
c    naxis     Number of axes in image
c    ctype     Axis types
c    cdelt     Axis increment
c    crval     Reference values for all axes
c  Output
c    fac       factor to convert from radians to world coords
c
c-----------------------------------------------------------------------
      implicit none
c
      integer iax, naxis
      character*(*) labtyp, ctype(naxis)
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      real fac
cc
      double precision delw
      logical ok
c-----------------------------------------------------------------------
      call pixi2wcg (.false., iax, labtyp, naxis, crval, crpix,
     +               cdelt, ctype, delw, ok)
      fac = delw / cdelt(iax)
c
      end
c
c
      subroutine beampl (maxcon, beaml, beamb, bmin, bmaj, bpa, bxfac,
     +                   byfac, bemprs)
c-----------------------------------------------------------------------
c     Draw one beam for each image being displayed.  They are drawn
c     confocally with different line styles in the designated corner.
c
c  Input
c    maxcon          Maximum number of contour images
c    beaml,beamb     True if the beam is to be drawn on the left
c                    or at the bottom (else right and top)
c    bmin,maj,pa     Beam FWHMin, FWHMax and p.a. for pixel map and
c                    contour 1 and 2 images (rad).
c    bx,yfac         Factors converting radians to world coordinates 
c                    on the x and y axes
c    bemprs          True if beam present for maxcon contours, pixel map
c                    and 2 vector images
c
c-----------------------------------------------------------------------   
      implicit none
c
      integer maxcon
      logical beaml, beamb, bemprs(maxcon+4)
      real bmin(maxcon+4), bmaj(maxcon+4), bpa(maxcon+4), 
     +  bxfac(maxcon+4), byfac(maxcon+4)
cc
      integer i
      logical fill
      real xcen, ycen
c-----------------------------------------------------------------------
c
c Find location of centre of biggest beam.  They will be plotted
c with the same centre.
c
      call beamxy (maxcon, beaml, beamb, bemprs, bmin, bmaj, bpa, bxfac,
     +             byfac, xcen, ycen, fill)
c
c Draw the beam(s)
c
      do i = 1, maxcon+4
        if (bemprs(i)) then
          call beampl2 (xcen, ycen, bmin(i), bmaj(i), bpa(i),
     +                  bxfac(i), byfac(i), fill)
        end if
      end do
c
      end
c
c
      subroutine beampl2 (xcen, ycen, bmin, bmaj, bpa, bxfac,
     +                    byfac, fill)
c-----------------------------------------------------------------------
c     Draw one beam in the designated corner of the sub-plot.
c
c  Input
c    x,ycen          World coordinates of beam centre
c                    or at the bottom (else right and top)
c    bmin,maj,pa     Beam FWHMin, FWHMax and p.a. for pixel map and
c                    contour image (rad). 
c    bx,yfac         Factors converting radians to world coordinates 
c                    on the x and y axes
c    fill            If true fill beam polygon in
c-----------------------------------------------------------------------   
      implicit none
c
      logical fill
      real bmin, bmaj, bpa, bxfac, byfac, xcen, ycen
cc
      include 'mirconst.h'
      real xs(0:360), ys(0:360), pa, xx, yy, cp, sp, bbmin, bbmaj, bbpa
      integer i
c-----------------------------------------------------------------------
      bbmin = bmin / 2.0
      bbmaj = bmaj / 2.0
      bbpa = (90.0 + bpa) * dpi / 180.0
      cp = cos(bbpa)
      sp = sin(bbpa)
c
c Work out the beam polygon
c
      do i = 0, 360
        pa = i * dpi / 180.0 	  
        xx = bbmaj * cos(pa)
        yy = bbmin * sin(pa)
c
        xs(i) = xcen + ( xx*cp + yy*sp)*bxfac
        ys(i) = ycen + (-xx*sp + yy*cp)*byfac
      end do
c
c  Draw the beam with the desired line style and fill style
c
      if (fill) then
        call pgsfs (1)
      else
        call pgslw (2)
        call pgsfs (2)
      end if
c
      call pgpoly (361, xs(0), ys(0))
c
      end
c
c
      subroutine beamxy (maxcon, beaml, beamb, bemprs, bmin, bmaj, 
     +                   bpa, bxfac, byfac, xcen, ycen, fill)
c-----------------------------------------------------------------------
c     We want to draw the beams, if there are more than one, with
c     the same centre.  Find the biggest x and y offsets from all
c     the beams and compute the centre with that.
c
c  Input
c    maxcon          Maximum number of contour images
c    beaml,beamb     True if the beam is to be drawn on the left
c                    or at the bottom (else right and top)
c    bemprs          True if beam present for pixel map and contour images
c    bmin,maj,pa     Beam FWHMin, FWHMax and p.a. for pixel map and
c                    contour image (rad). 
c    bx,yfac         Factors converting radians to world coordinates 
c                    on the x and y axes
c  Output
c    x,ycen          World coordiate of beam centres
c    fill            If true fill in the beam patch, else just outline
c-----------------------------------------------------------------------   
      implicit none
c
      integer maxcon
      logical beaml, beamb, bemprs(maxcon+4), fill
      real bmin(maxcon+4), bmaj(maxcon+4), bpa(maxcon+4), 
     +  bxfac(maxcon+4), byfac(maxcon+4), xcen, ycen
cc
      include 'mirconst.h'
      real  x, y, xmin, xmax, ymin, ymax, xoff, yoff, pa, xx, yy,
     +  cp, sp, bbmin, bbmaj, bbpa, xlo, xhi, ylo, yhi, xwmax, ywmax,
     +  bmino, bmajo, bpao
      integer i, j, sx, sy
      logical const
c-----------------------------------------------------------------------
      xwmax = -1.0e30
      ywmax = -1.0e30
      const = .true.
c
c Find first beam
c
      do i = 1, maxcon+4
        if (bemprs(i)) then
          bmino = bmin(i)
          bmajo = bmaj(i)
          bpao  = bpa(i)
        end if
      end do
c
c  Loop over beams
c 
      do j = 1, maxcon+4
        if (bemprs(j)) then
c
c  Make check to see if all beams the same, so can set fill style
c
          if (bmin(j).ne.bmino .or. bmaj(j).ne.bmajo .or. 
     +        bpa(j).ne.bpao) const = .false.
c
c  Calculate useful factors for beam
c
          bbmin = bmin(j) / 2.0
          bbmaj = bmaj(j) / 2.0
          bbpa = (90.0 + bpa(j)) * dpi / 180.0
          cp = cos(bbpa)
          sp = sin(bbpa)
c
c  Find height and width of ellipse empirically, because it is
c  too late to do the algebra
c
          xmin = 1.0e30
          xmax = -1.0e30
          ymin = 1.0e30
          ymax = -1.e30
c
          do i = 0, 360, 4
            pa = i * dpi / 180.0 	  
            xx = bbmaj * cos(pa)
            yy = bbmin * sin(pa)
c
            x = ( xx*cp + yy*sp)*bxfac(j)
            y = (-xx*sp + yy*cp)*byfac(j)
c  
            xmin = min(x,xmin)
            xmax = max(x,xmax)
            ymin = min(y,ymin)
            ymax = max(y,ymax)
          end do
c
c  Work out biggest x,y sizes
c
          xwmax = max(abs(xmax - xmin),xwmax)
          ywmax = max(abs(ymax - ymin),ywmax)
c
c Update
c
          bmino = bmin(j)
          bmajo = bmaj(j)
          bpao  = bpa(j)
        end if
      end do
c
c Fill beam plot ?
c
      fill = .false.
      if (const) fill = .true.
c
c  Find world coordinates of plotted window
c
      call pgqwin (xlo, xhi, ylo, yhi)
      sx = 1
      if (xlo.gt.xhi) sx = -1
      sy = 1
      if (ylo.gt.yhi) sy = -1
c
c  Work out ellipse centre.  Ellipse comes no close than 2.5%
c  of the width of the plot from the boundary.
c
      xoff = abs(0.025*(xhi-xlo))
      yoff = abs(0.025*(yhi-ylo))
c
      if (beaml) then
        xcen = xlo + sx*(xoff + xwmax/2.0)
      else
        xcen = xhi - sx*(xoff + xwmax/2.0)
      end if
c
      if (beamb) then
        ycen = ylo + sy*(yoff + ywmax/2.0)
      else
        ycen = yhi - sy*(yoff + ywmax/2.0)
      end if
c
      end
c
c
      subroutine chkdes (relax, im1, im2, size1, size2, crpix1, crpix2,
     +   cdelt1, cdelt2, crval1, crval2, epoch1, epoch2, ctype1, ctype2)
c-----------------------------------------------------------------------
c     Compare axis descriptors for the first three axes
c
c  Input:
c   im1,2        Images
c   size1,2      Sizes of each dimension
c   crpix1,2     Reference pixels
c   cdelt1,2     Increments
c   crval1,2     Refernce values
c   ctype1,2     types of axes
c   epoch1,2     Epochs
c-----------------------------------------------------------------------
      implicit none
c
      integer size1(3), size2(3)
      character*(*) im1, im2, ctype1(3), ctype2(3)
      double precision crval1(3), crval2(3), cdelt1(3), cdelt2(3),
     +  crpix1(3), crpix2(3)
      real epoch1, epoch2
      logical relax
cc
      integer k, l1, l2, len1, maxis
      logical got23
      character line*130
c-----------------------------------------------------------------------
      l1 = len1(im1)
      l2 = len1(im2)
c
c Allow 2-D with 3-D, but two 3-D cubes must be the same size
c
      if (size1(1).ne.size2(1)) then
        line = 'Unequal dimensions for images '//im1(1:l1)//
     +         ' & '//im2(1:l2)//' on axis 1'
        call bug ('f', line)
      end if
      if (size1(2).ne.size2(2)) then
        line = 'Unequal dimensions for images '//im1(1:l1)//
     +         ' & '//im2(1:l2)//' on axis 2'
        call bug ('f', line)
      end if
      if (size1(3).gt.1.and.size2(3).gt.1.and.size1(3).ne.size2(3)) then
        line = 'Inconsistent dimensions for images '//im1(1:l1)//
     +         ' & '//im2(1:l2)//' on axis 3'
        call bug ('f', line)
      end if
c
      if (epoch1.ne.epoch2) then
        line = 'Unequal epochs for images '//im1(1:l1)//' & '//im2(1:l2)
        if (relax) then
          call bug ('w', line)
        else
          call bug ('i', 'Try, with care, options=relax')
          call bug ('f', line)
        end if
      end if
c
c See if we have 2-D with 3-D
c
      got23 = .false.
      if ( (size1(3).eq.1 .and. size2(3).gt.1) .or.
     +     (size1(3).gt.1 .and. size2(3).eq.1)) got23 = .true.
c
c Loop over axes of interest
c
      maxis = 3
      if (size1(3).eq.1 .and. size2(3).eq.1) maxis = 2
      do k = 1, maxis
        if ( (k.eq.3 .and. .not.got23) .or. k.le.2) then
          call chkdescg (relax, 'cdelt', k, im1(1:l1), im2(1:l2), 
     +                   cdelt1(k), cdelt2(k))
          call chkdescg (relax, 'crpix', k, im1(1:l1), im2(1:l2), 
     +                   crpix1(k), crpix2(k))
          call chkdescg (relax, 'crval', k, im1(1:l1), im2(1:l2), 
     +                   crval1(k), crval2(k))
c
          if (ctype1(k).ne.ctype2(k)) then
            write (line, 10) im1(1:l1), im2(1:l2), k
10          format ('Unequal ctype for images ', a, ' & ', a, 
     +              ' on axis ', i1)
            if (relax) then
              call bug ('w', line)
            else
              call bug ('i', 'Try, with care, options=relax')
              call bug ('f', line)
            end if
          end if
        end if
      end do
c
      end
c
c
      subroutine chkim (maxnax, ncon, cin, csize, cepoch, ccrpix, 
     +   ccdelt, ccrval, cctype, gin, gsize, gepoch, gcrpix, gcdelt,
     +   gcrval, gctype, vin, vsize, vepoch, vcrpix, vcdelt, vcrval,
     +   vctype, bin, bsize, bepoch, bcrpix, bcdelt, bcrval, bctype, 
     +   mskin, msize, mepoch, mcrpix, mcdelt, mcrval, mctype, relax)
c-----------------------------------------------------------------------
c     Check all the images for internal consistency
c
c   Input:
c     maxnax     Maximum number of allowed dimenions for image
c     ncon       Number of contour images
c     relax      Only warnings instead of fatal errror for inconsistent
c                axis descriptors
c     *in        Input image names
c     *size      Size of each dimensions of images
c     *epoch     Epochs of images
c     *crpix     Reference pixels
c     *cdelt     Increments
c     *crval     Reference values
c     *ctype     Axis types
c
c-----------------------------------------------------------------------
      implicit none
c
      integer maxnax, ncon, csize(maxnax,*), gsize(maxnax), 
     +  vsize(maxnax,2), bsize(maxnax), msize(maxnax)
      double precision 
     +  ccrval(maxnax,*), ccdelt(maxnax,*), ccrpix(maxnax,*),
     +  gcrval(maxnax),   gcdelt(maxnax),   gcrpix(maxnax),
     +  vcrval(maxnax,2), vcdelt(maxnax,2), vcrpix(maxnax,2),
     +  bcrval(maxnax),   bcdelt(maxnax),   bcrpix(maxnax),
     +  mcrval(maxnax),   mcdelt(maxnax),   mcrpix(maxnax,*)
      real cepoch(*), gepoch, vepoch(2), bepoch, mepoch
      character*(*) cin(*), gin, vin(2), bin, mskin, 
     +  cctype(maxnax,*), gctype(maxnax), vctype(maxnax,2), 
     +  bctype(maxnax), mctype(maxnax)
      logical relax
cc
      integer i, j
c-----------------------------------------------------------------------
c
c Check contour images for self consistency 
c
      if (ncon.gt.1) then
        do i = 1, ncon-1
          do j = i+1, ncon
            call chkdes (relax, cin(i), cin(j), csize(1,i), csize(1,j),
     +         ccrpix(1,i), ccrpix(1,j), ccdelt(1,i), ccdelt(1,j), 
     +         ccrval(1,i), ccrval(1,j), cepoch(i), cepoch(j), 
     +         cctype(1,j), cctype(1,j))
          end do
        end do
      end if
c
c Check vector images for self consistency
c
      if (vin(1).ne.' ') call chkdes (relax, vin(1), vin(2), vsize(1,1),
     +   vsize(1,2), vcrpix(1,1), vcrpix(1,2), vcdelt(1,1), vcdelt(1,2),
     +   vcrval(1,1), vcrval(1,2), vepoch(1), vepoch(2), vctype(1,1), 
     +   vctype(1,2))
c
c Check first contour image for consistency with other images
c
      if (ncon.gt.0) then
        if (gin.ne.' ') call chkdes (relax, cin, gin, csize, gsize,
     +         ccrpix, gcrpix, ccdelt, gcdelt, ccrval, gcrval, 
     +         cepoch, gepoch, cctype, gctype)
        if (vin(1).ne.' ') call chkdes (relax, cin, vin, csize, vsize,
     +         ccrpix, vcrpix, ccdelt, vcdelt, ccrval, vcrval, 
     +         cepoch, vepoch, cctype, vctype)
        if (bin.ne.' ') call chkdes (relax, cin, bin, csize, bsize,
     +         ccrpix, bcrpix, ccdelt, bcdelt, ccrval, bcrval, 
     +         cepoch, bepoch, cctype, bctype)
        if (mskin.ne.' ') call chkdes (relax, cin, mskin, csize, msize,
     +         ccrpix, mcrpix, ccdelt, mcdelt, ccrval, mcrval, 
     +         cepoch, mepoch, cctype, mctype)
      end if
c
c Check pixel map images for consistency with other images
c
      if (gin.ne.' ') then
        if (vin(1).ne.' ') call chkdes (relax, gin, vin, gsize, vsize,
     +         gcrpix, vcrpix, gcdelt, vcdelt, gcrval, vcrval, 
     +         gepoch, vepoch, gctype, vctype)
        if (bin.ne.' ') call chkdes (relax, gin, bin, gsize, bsize,
     +         gcrpix, bcrpix, gcdelt, bcdelt, gcrval, bcrval, 
     +         gepoch, bepoch, gctype, bctype)
        if (mskin.ne.' ') call chkdes (relax, gin, mskin, gsize, msize,
     +         gcrpix, mcrpix, gcdelt, mcdelt, gcrval, mcrval, 
     +         gepoch, mepoch, gctype, mctype)
      end if
c
c Check vector images for consistency with other images
c
      if (vin(1).ne.' ') then
        if (bin.ne.' ') call chkdes (relax, vin, bin, vsize, bsize,
     +         vcrpix, bcrpix, vcdelt, bcdelt, vcrval, bcrval, 
     +         vepoch, bepoch, vctype, bctype)
        if (mskin.ne.' ') call chkdes (relax, vin, mskin, vsize, msize,
     +         vcrpix, mcrpix, vcdelt, mcdelt, vcrval, mcrval, 
     +         vepoch, mepoch, vctype, mctype)
      end if
c
c Check box image for consistency with other images
c
      if (bin.ne.' ') then
        if (mskin.ne.' ') call chkdes (relax, bin, mskin, bsize, msize,
     +         bcrpix, mcrpix, bcdelt, mcdelt, bcrval, mcrval, 
     +         bepoch, mepoch, bctype, mctype)
      end if
c
      end
c
c
      subroutine decopt  (dofull, do3val, do3pix, eqscale, gaps, solneg,
     +   beambl, beambr, beamtl, beamtr, relax, rot90, signs, 
     +   mirror, dowedge, doerase, doepoch, dofid, dosing)
c----------------------------------------------------------------------
c     Decode options array into named variables.
c
c   Output:
c     dofull    True means do full annotaiton of plot
c     do3val    True means label sub-plots with value of third axis
c     do3pix    True means label sub-plots with pixel of third axis
c     doerase   True means erase rectangle into which 3-axis label written
c     eqscale   True means plot with x and y scales
c     gaps      True menas put space bewteen adjacent sub-plots
c     solneg    True means plot negative contours with solid line
c               style and positive contours with dashed line style
c               One for each contour image
c     beam%%    Beam location
c     relax     If true issue warnings about mismatched axis
c               descriptors between images instead of fatal error
c     rot90     Rotate vectors by 90 degrees
c     signs     WHen plotting vectors, assume N and E are in
c               the direction of increasing X and Y, else N and E
c               are to the top and left
c     mirror    Multiply contours by -1 and add to list
c     dowedge   Draw wedge on pixel map image
c     doepoch   Write epoch into axis labels
c     dofid     Interactive fiddle
c     dosing    FIddle after every subplot
c-----------------------------------------------------------------------
      implicit none
c
      logical dofull, do3val, do3pix, eqscale, gaps, solneg(*),
     +  beambl, beambr, beamtl, beamtr, relax, rot90, signs,
     +  mirror, dowedge, doerase, doepoch, dofid, dosing
cc
      integer maxopt
      parameter (maxopt = 21)
c
      character opshuns(maxopt)*8
      logical present(maxopt)
      data opshuns /'full    ', '3value  ', '3pixel  ', 'unequal ', 
     +              'gaps    ', 'solneg1 ', 'solneg2 ', 'solneg3 ',
     +              'beambl  ', 'beambr  ', 'beamtl  ', 'beamtr  ',
     +              'relax   ', 'rot90   ', 'signs   ', 'mirror',
     +              'wedge   ', 'noerase ', 'noepoch ', 'fiddle',
     +              'single  '/
c-----------------------------------------------------------------------
      call optcg ('options', opshuns, present, maxopt)
c
      dofull    =      present(1)
      do3val    =      present(2)
      do3pix    =      present(3)
      eqscale   = .not.present(4) 
      gaps      =      present(5)
      solneg(1) =      present(6)
      solneg(2) =      present(7)
      solneg(3) =      present(8)
      beambl    =      present(9)
      beambr    =      present(10)
      beamtl    =      present(11)
      beamtr    =      present(12)
      relax     =      present(13)
      rot90     =      present(14)
      signs     =      present(15)
      mirror    =      present(16)
      dowedge   =      present(17)
      doerase   = .not.present(18)
      doepoch   = .not.present(19)
      dofid     =      present(20)
      dosing    =      present(21)
c
      end
c
c
      subroutine drawbox (iplot, tr, boxfac, boxinc, npixx, npixy, 
     +   image, nimage, cdelt, scale, bfac)
c-----------------------------------------------------------------------
c     Draw boxes.  The boxes will come out square only if the pixel
c     increment is the and the user has requested equal scales.
c
c  Input
c    iplot    sub-plot number.  Only work out vector length scale
c             factors from first sub-plot so that the correct number
c             get written into the plot annotation at the end
c             of each page
c    tr       Transformation matrix from pixels to world coordinates
c    boxfac   Multiply box widths by this factor after self-scaling
c    boxinc   Increment through image in these steps
c    npixx,y  Size of images in pixles
c    image    Image
c    nimage   Normalization image
c    cdelt    Array of pixel increments
c    scale    Scale in linear coords per mm.  For RA axes radians on
c             the sky per mm
c  Input/output:
c    bfac     (1)   Maximum value of pixles in region of first subplot
c             (2:3) Scale factors, in x and y, to convert pixel value
c                   into box width in world coordinates
c             (4:5) Scale factors, in x and y, giving box widths per mm
c	            E.g. if pixel units are rad/m/m, then these scale 
c                   factors you have b(4) & b(5) rad/m/m per mm
c
c-----------------------------------------------------------------------
      implicit none
c
      integer boxinc(2), iplot, npixx, npixy, nimage(npixx,npixy)
      double precision cdelt(*)
      real boxfac, image(npixx,npixy), tr(6), scale(2), bfac(5)
cc
      real xb(4), yb(4), x, y, x1, x2, y1, y2, vx1, vx2, vy1, vy2
      integer i, j
      real delx, dely, s
c-----------------------------------------------------------------------
      call pgqwin (x1, x2, y1, y2)
      call pgqvp (2, vx1, vx2, vy1, vy2)
c
c Find maximum selected pixel from first sub-plot
c
      if (iplot.eq.1) then
        bfac(1) = -1.0e30
        do j = 1, npixy, boxinc(2)
          do i = 1, npixx, boxinc(1)
            if (nimage(i,j).gt.0) bfac(1) = max(bfac(1),abs(image(i,j)))
          end do
        end do
c
c Make maximum box width on the plot equal to 99% of the selected
c pixel increment, multiplied by the users factor. 
c
         bfac(2) = boxfac * 0.99*boxinc(1) * abs(tr(2)/bfac(1))
         bfac(3) = boxfac * 0.99*boxinc(2) * abs(tr(6)/bfac(1))
c
c Find out the scale in world coordinates per mm in x and y and then
c work out the scale of the boxes in image units per mm 
c (rad/m/m per mm) in x and y
c
         s = tr(2) * scale(1) / cdelt(1)
         bfac(4) = abs(s / bfac(2))
c
         s = tr(6) * scale(2) / cdelt(2)
         bfac(5) = abs(s / bfac(3))
      end if
c
c Loop over image
c
      do j = 1, npixy, boxinc(2)
        do i = 1, npixx, boxinc(1)
          if (nimage(i,j).gt.0) then
c
c World coordinates of pixel
c
            x = tr(1) + tr(2)*i 
            y = tr(4) + tr(6)*j
c
c Find half width of box in world coordinates.
c
            delx =  bfac(2) * image(i,j) / 2.0
            dely =  bfac(3) * image(i,j) / 2.0
c
c Draw it. Solid boxes for positive values, hollow for negative
c 
            xb(1) = x - delx
            xb(2) = x + delx
            xb(3) = xb(2)
            xb(4) = xb(1)
            yb(1) = y - dely
            yb(2) = yb(1)
            yb(3) = y + dely
            yb(4) = yb(3)
c
            call pgsfs (2)
            if (image(i,j).gt.0) call pgsfs (1)
            call pgpoly (4, xb, yb) 
          end if
        end do
      end do
      call pgsfs (2)
c
      end
c
c
      subroutine drawvec (iplot, tr, vecfac, vecinc, npixx, npixy, amp,
     +   namp, pa, npa, cdelt, scale, signs, rot90, vfac, nx, ny)
c-----------------------------------------------------------------------
c     Draw vectors.   The vector position angle must come out
c     correctly on the plot regardless of the x and y scales,
c     it is not tied to the world coordinate scales.
c
c  Input
c    iplot    sub-plot number.  Only work out vector length scale
c             factors from first sub-plot so that the correct number
c             get written into the plot annotation at the end
c             of each page
c    tr       Transformation matrix from pixels to world coordinates
c    vecfac   Multiply amplitudes by this factor after self-scaling
c    vecinc   Increment through image in these steps
c    npixx,y  Size of images in pixles
c    amp,pa   Amplitude and position angle images
c    namp,npa Normalization images
c    cdelt    Array of pixel increments
c    scale    Scale in linear coords per mm.  For RA axes radians on
c             the sky per mm
c    signs    True means increasing X and Y = E and N, else
c             E and N to the left and top
c    rot90    Add 90 if true to position angle
c    nx,ny    Number of subplots in x and y directions
c  Input/output:
c    vfac     Maximum vector amplitude and the vector scale in
c             pixel units per mm (e.g. Jy/beam per mm).  Set on first
c             sub-plot
c
c-----------------------------------------------------------------------
      implicit none
c
      logical rot90, signs
      integer vecinc(2), nx, ny, iplot, npixx, npixy, namp(npixx,npixy),
     +  npa(npixx,npixy)
      double precision cdelt(*)
      real vecfac, amp(npixx,npixy), pa(npixx,npixy), tr(6), scale(2), 
     +  vfac(2)
cc
      include 'mirconst.h'
      real xv(2), yv(2), x, y
      integer i, j, pas
      real delx, dely, theta, sx, sy, x1, x2, y1, y2, vsizmax
      double precision dr
      parameter (dr = dpi / 180.0)
c-----------------------------------------------------------------------
c
c Find maximum selected vector amplitude for first sub-plot
c
      if (iplot.eq.1) then
        vfac(1) = -1.0e30
        do j = 1, npixy, vecinc(2)
          do i = 1, npixx, vecinc(1)
            if (namp(i,j).gt.0 .and. npa(i,j).gt.0) 
     +         vfac(1) = max(vfac(1), abs(amp(i,j)))
          end do
        end do
c
c Make maximum amplitude on the plot 1/20 of min(width,height)
c of the plot, multipled by the users factor.  Scale in mm.
c
        call pgqvsz (2, x1, x2, y1, y2)
        vsizmax = min((x2-x1)/nx, (y2-y1)/ny) / 20.0
        vfac(2) = abs(vfac(1) / vecfac / vsizmax)
      end if
c
c Convert scale in linear coords per mm to world coords per mm
c
      sx = tr(2) * abs(scale(1) / cdelt(1)) 
      sy = tr(6) * abs(scale(2) / cdelt(2))
c
c Which way are N and E ?   N up and E left same as N down E right
c N down E left same as N up E right as vectors have no arrow head.
c
      pas = 1
      if (signs .and. cdelt(1)*cdelt(2).gt.0.0) pas = -1
c
c Loop over image
c
      do j = 1, npixy, vecinc(2)
        do i = 1, npixx, vecinc(1)
          if (namp(i,j).gt.0 .and. npa(i,j).gt.0 .and.
     +        amp(i,j).gt.0.0) then
c
c World coordinates of pixel
c
            x = tr(1) + tr(2)*i 
            y = tr(4) + tr(6)*j
c
c Position angle of vectors in radians
c
            theta = pas * pa(i,j) * dr
            if (rot90) theta = theta + pi/2.0
c
c Find half size of vectors in world coordinates.
c
            delx = -amp(i,j) * sin(theta) * sx / 2.0 / vfac(2)
            dely =  amp(i,j) * cos(theta) * sy / 2.0 / vfac(2)
c
c Draw it
c 
            xv(1) = x - delx
            xv(2) = x + delx
            yv(1) = y - dely
            yv(2) = y + dely
            call pgline (2, xv, yv) 
          end if
        end do
      end do
c
      end
c
c
      subroutine fullann (maxcon, ncon, cin, gin, vin, bin, lc, lg, lv,
     +   lb, maxlev, nlevs, levs, srtlev, slev, npixr, trfun, pixr, 
     +   vfac, bfac, naxis, size, crval, crpix, cdelt, ctype, vymin, 
     +   blc, trc, pcs, ydispb, ibin, jbin, kbin, labtyp, gmm, cmm)
c-----------------------------------------------------------------------
c     Full annotation of plot with contour levels, RA and DEC etc.
c
c     Input
c       ncon       Number of contour images
c       *in        Image names
c       l*         Handles for images
c       nlevs      Number of contour levels for each image
c       levs       Contour levels for each image
c       srtlev     Index array gvbing order of increasing contour levels
c       slev       Contour level scale factors for each image
c       trfun      Transfer function applied to image
c       npixr      Number of pixel map ranges
c       pixr       pixel map intensity range
c       vfac       Maximum vector amplitude and scale in mm/amp
c       bfac       Maximum box width and scale in mm/width
c       naxis      Number of axes 
c       size       Size of axes
c       crval      Array of image reference values
c       crpix      Array of reference pixels
c       cdelt      Array of pixel increments
c       ctype      Array of axis types
c       vymin      y viewsurface normalized device coordinate
c                  at which the lowest sub-plot x-axis is drawn
c       blc,trc    Image window in pixels
c       pcs        PGPLOT character size parameters for plot labels
c       ydispb     Displacement of x-axis label in character heights
c       i,jbin     Spatial inc and bin
c       kbin       CHannel increments and average
c       labtyp     Axis label types
c       *mm        Image min and max
c----------------------------------------------------------------------- 
      implicit none
c
      integer maxcon, maxlev, ncon, nlevs(maxcon), blc(*), trc(*), 
     +  lc(maxcon), lg, lv(2), lb, srtlev(maxlev,maxcon), ibin(2), 
     +  jbin(2), kbin(2), naxis, size(naxis), npixr
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      real levs(maxlev,maxcon), vymin, slev(maxcon), pixr(2), pcs, 
     +  ydispb, vfac(2), bfac(5), gmm(2), cmm(2,maxcon)
      character*(*) cin(maxcon), gin, vin(2), bin, ctype(naxis), trfun, 
     +  labtyp(2)
cc
      real xpos, ypos, yinc
      integer i
c-----------------------------------------------------------------------
c
c Setup chores and and annotate with reference values
c
      call anninicg (.false., naxis, crpix, crval, cdelt, ctype, vymin,
     +               pcs, ydispb, labtyp, xpos, ypos, yinc)
c
c Write spatial window in pixels and channel inc. if possible
c
      call annwincg (blc, trc, ibin, jbin, kbin, naxis, size, cdelt,
     +               ctype, yinc, xpos, ypos)
c
c Write imaging information
c
      if (gin.ne.' ') call anngrscg (lg, gin, npixr, pixr, trfun, gmm,
     +                               yinc, xpos, ypos)
c
c Write contour image information
c
      if (ncon.gt.0) then
        do i = 1, ncon
          call annconcg (lc(i), cin(i), slev(i), nlevs(i), levs(1,i),
     +       srtlev(1,i), cmm(1,i), yinc, xpos, ypos)
        end do
      end if
c
c Write vector information
c
      if (vin(1).ne.' ' .and. vin(2).ne.' ') 
     +   call annveccg (lv, vin, vfac, yinc, xpos, ypos)
c
c Write box information
c
      if (bin.ne.' ') 
     +   call annboxcg (lb, bin, bfac, yinc, xpos, ypos)
c
      end
c
c
      subroutine getbeam (maxcon, cin, lc, gin, lg, vin, lv, bin, lb,
     +   labtyp, naxis, crval, crpix, cdelt, ctype, bmin, bmaj, bpa, 
     +   bxfac, byfac, dobeam, bemprs)
c-----------------------------------------------------------------------
c     Get beam information from headers
c
c  Input
c   maxcon     Maximum number of allowed contour images
c   *in        Image names
c   l*         Image handles
c   labtyp     Label types
c   naxis      NUmber of axes in image
c   crval      Axis reference values
c   cdelt      Axis increments
c  Output
c   bmin       FWHMin for maxcon contours, pixel map, two vectors
c              and box images
c   bmaj       FWHMax
c   bpa        p.a. 
c              These are all in radians
c   bx,yfac    Factors to scale the x and y axes so that the beam
c              comes out plotted in world coordinates of the type
c              labelling the plot
c   bemprs     True if beam present for that image
c Input/output:
c  dobeam      If no beams to plot, this is set to false
c-----------------------------------------------------------------------
      implicit none
c
      integer maxcon, naxis
      character*(*) labtyp(2), ctype(naxis), cin(maxcon), gin, vin(2), 
     +  bin
      logical dobeam, bemprs(maxcon+4)
      integer lc(maxcon), lg, lv(2), lb
      double precision crval(naxis), cdelt(naxis), crpix(naxis)
      real bmin(maxcon+4), bmaj(maxcon+4), bpa(maxcon+4), 
     +  bxfac(maxcon+4), byfac(maxcon+4)
cc
      integer i
c-----------------------------------------------------------------------
c
c Contour images
c
      do i = 1, maxcon
       if (lc(i).ne.0) then
         call beamfac (cin(i), lc(i), labtyp, naxis, crval, crpix, 
     +      cdelt, ctype, bmin(i), bmaj(i), bpa(i), bxfac(i), 
     +      byfac(i), bemprs(i))
       else
         bemprs(i) = .false.
       end if
      end do
c
c Pixel map image
c
      i = maxcon + 1
      bemprs(i) = .false.
      if (lg.ne.0) call beamfac (gin, lg, labtyp, naxis, crval, crpix,
     +  cdelt, ctype, bmin(i),  bmaj(i), bpa(i), bxfac(i), 
     +  byfac(i), bemprs(i))
c
c Vector images
c
      i = maxcon + 2
      bemprs(i) = .false.
      bemprs(i+1) = .false.
      if (lv(1).ne.0 .and. lv(2).ne.0) then
        call beamfac (vin(1), lv(1), labtyp, naxis, crval, crpix, 
     +     cdelt, ctype, bmin(i), bmaj(i), bpa(i), bxfac(i), 
     +     byfac(i), bemprs(i))
c
        i = i + 1
        call beamfac (vin(2), lv(2), labtyp, naxis, crval, crpix, 
     +     cdelt, ctype, bmin(i), bmaj(i), bpa(i), bxfac(i), 
     +     byfac(i), bemprs(i))
      end if
c
c Box image 
c
      i = maxcon + 4
      bemprs(i) = .false.
      if (lb.ne.0) call beamfac (bin, lb, labtyp, naxis, crval, crpix,
     +  cdelt, ctype, bmin(i),  bmaj(i), bpa(i), bxfac(i), 
     +  byfac(i), bemprs(i))
c
      dobeam = .false.
      do i = 1, maxcon+4
        if (bemprs(i)) dobeam = .true.
      end do
      if (.not.dobeam) call bug ('w', 'No beam(s) to plot')
c
      end
c
c
      subroutine hardofm (coltab, pixr2, dofid, j, jj, dosing, tfvp, 
     +                    win, image, nimage)
c-----------------------------------------------------------------------
      implicit none
      integer coltab, j, jj, win(2), nimage(*)
      real tfvp(4), image(*), pixr2(2)
      logical dofid, dosing
c-----------------------------------------------------------------------
c
c Apply user specified OFM to PGPLOT device.   
c
      if (coltab.eq.0) then
c
c The user has not specified an OFM with the "range" keyword.  If first 
c subplot on first page, apply b&w as default.  Otherwise, leave OFM at 
c whatever it was last set to for the previous subplot.
c
        if (j.eq.1) call ofmcol (1, pixr2(1), pixr2(2))
      else 
c
c The user has given an OFM with the "range" keyword for this subplot.
c
        call ofmcol (coltab, pixr2(1), pixr2(2))
      end if
c
c Interactive modification of OFM for hardcopy devices here; must be 
c done before PGIMAG called.  Any change of lookup table here will
c overwrite that done with call to ofmcol above
c
      if (dofid .and. (jj.eq.1 .or. dosing))
     +  call ofmmod (tfvp, win(1)*win(2), image, nimage, 
     +               pixr2(1), pixr2(2))
c
c If we are going to use either the b&w or the absolute b&w transfer function
c we must account for the fact that the output will probably be printed
c on paper, so we want black on white instead of white on black. So
c make the OFM the complement of itself here.  Only works for b&w OFMs
c
      call ofmcmp
c
      end
c
c
      subroutine intofm (coltab, j, pixr2)
c-----------------------------------------------------------------------
      implicit none
      integer coltab, j
      real pixr2(2)
c------------------------------------------------------------------------
      if (coltab.eq.0) then
c
c The user has not specified an OFM with the "range" keyword.  If first 
c subplot on first page, apply b&w as default.  Otherwise, leave OFM at 
c whatever it was last set to for the previous subplot.
c
        if (j.eq.1) call ofmcol (1, pixr2(1), pixr2(2))
      else 
c
c The user has given an OFM with the "range" keyword for this subplot.
c
        call ofmcol (coltab, pixr2(1), pixr2(2))
      end if
c
      end
c
c
      subroutine inputs (maxgr, maxlev, maxcon, maxtyp, ltypes, ncon, 
     +   cin, gin, nvec, vin, bin, mskin, ibin, jbin, kbin, levtyp, 
     +   slev, levs, nlevs, npixr, pixr, trfun, coltab, vecfac, vecinc, 
     +   boxfac, boxinc, pdev, labtyp, dofull, do3val, do3pix, eqscale, 
     +   gaps, solneg, nx, ny, lwid, break, cs, scale, ofile, dobeam, 
     +   beaml, beamb, relax, rot90, signs, mirror, dowedge, doerase, 
     +   doepoch, dofid, dosing)
c-----------------------------------------------------------------------
c     Get the unfortunate user's long list of inputs
c
c  Input:
c   maxgr      Maximum number of pixel map scale intensity ranges and 
c              transfer functions allowed.  The user can input one group 
c              per sub-plot up to this maximum so that differnt subplots 
c              can be displayed optimally.   If there are more subplots
c              that intebsity ranegs given, the extra ones use the values
c              for the previous subplot.
c   maxlev     Maximum number of allowed contour levels
c   maxcon     Maximum number of contour images
c   maxtyp     Maximum number of label types
c   ltypes     Possible label types
c  Output:
c   ncon       Number of contour images
c   nvec       Number of pairs of vector images, 0 or 1
c   c,g,v,b,msk-in 
c              Contour, pixel map, vector (amp & pa), box & mask image names
c   i,j,kbin   X, y and z pixel increment and average
c   levtyp     Type of contour levels scale factors for each contour
c              image:  'p'(ercentage) or 'a'(bsolute)
c   slev       Contour levels scale factors (absolute or percentage)
c              for each contour image
c   levs       Contour levels for each contour image.   Will be scaled 
c              by SLEV for contouring
c   nlevs      Number of contour levels for each contour image
c   npixr      Number of pixr/trfun groups returned.
c   pixr       Pixel map intensity range for each of the NPIXR subplot
c   trfun      Type of pixel map transfer function: 'log', 'lin',
c              'heq' or 'sqr' for each of the NPIXR subplots
c   coltab     COlour lookup table number
c   vecfac     Vector amplitude scale factor and
c   vecinc     Vector x,y pixel incrememts
c   boxfac     Box width scale factor and
c   boxinc     Box x,y pixel incrememts
c   pdev       PGPLOT plot device/type
c   labtyp     Type of labels for x and y axes
c   dofull     True means do full annotaiton of plot
c   do3val     True means label sub-plots with value of third axis
c   do3pix     True means label sub-plots with pixel of third axis
c   doerase    Erase rectabngle into which 3-axis label written
c   eqscale    True means plot with x and y scales
c   gaps       True menas put space bewteen adjacent sub-plots
c   solneg     True means plot negative contours with solid line
c              style and positive contours with dashed line style
c              One for each contour image
c   nx,ny      Number of sub-plots per page
c   lwid       PGPLOT line widths 
c   break      Level for break between solid and dashed contours
c              for each contour image
c   cs         PGPLOT character sizes for the plot axis labels, the
c	       velocity/channel label, and the overlay ID string
c   scale      Scales for plot in x and y directions ( per mm)
c   ofile      Overlay box/star file name
c   dobeam     Draw the a little beam on each sub-plot
c   beaml      True if beam on left of sub-plot, else right
c   beamb      True if beam at bottom of sub-plot, else top
c   relax      Only issue warnings instead of fatal eror when
c              axis descriptors don;t agree between images
c   rot90      Rotate vectors by a further 90 degrees
c   signs      WHen plotting vectors, assume N and E are in
c              the direction of increasing X and Y
c   mirror     Multiply contours by -1 and add to list
c   dowedge    Draw a wedge on the pixel map
c   doepoch    Write epoch into axis labels
c   dofid      Interactive fiddle
c   dosing     Fiddle after each subplot
c-----------------------------------------------------------------------
      implicit none
c
      integer maxlev, maxcon, maxtyp, maxgr, ncon, nvec, npixr
      real levs(maxlev,maxcon), pixr(2,maxgr), scale(2), cs(3),
     +  slev(maxcon), break(maxcon), vecfac, boxfac
      integer nx, ny, nlevs(maxcon), lwid(maxcon+3), vecinc(2), 
     +  boxinc(2), ibin(2), jbin(2), kbin(2), coltab(maxgr)
      character*(*) labtyp(2), cin(maxcon), gin, vin(2), bin, mskin,
     +  pdev, ofile, trfun(maxgr), levtyp(maxcon), ltypes(maxtyp)
      logical do3val, do3pix, dofull, gaps, eqscale, solneg(maxcon),
     +  dobeam, beaml, beamb, relax, rot90, signs, mirror, dowedge,
     +  doerase, doepoch, dofid, dosing
cc
      integer nmaxim
      parameter (nmaxim = 8)
c
      integer nim, nimtype, i, j, nlab
      character images(nmaxim)*64, imtype(nmaxim)*9
      character*1 str, itoaf
      logical beambl, beambr, beamtl, beamtr, present, keyprsnt
c
      integer ntype
      parameter (ntype = 7)
      character type(ntype)*9
      data type  /'contour', 'pixel', 'amplitude', 'angle', 
     +            'box', 'mask', 'grey'/
c-----------------------------------------------------------------------
      call keyini
c
c Sort out input images
c
      call mkeyf ('in', images, nmaxim, nim)
      if (nim.eq.0) call bug ('f', 'No images given')
      call keymatch ('type', ntype, type, nmaxim, imtype, nimtype)
c
      ncon = 0
      nvec = 0
      do i = 1, nim
c
c Default is "pixel" if one image, else "contour"
c
        if (imtype(i).eq.' ') then
          if (nim.eq.1) then
            imtype(i) = 'pixel'
          else
            imtype(i) = 'contour'
          end if
        end if
c
c Find user given type of image
c
        if (imtype(i).eq.'contour') then
          if (ncon.ge.maxcon) then
            call bug ('f', 'Too many contour images given')
          else
            ncon = ncon + 1
            cin(ncon) = images(i)
          end if
        else if (imtype(i).eq.'pixel' .or. imtype(i).eq.'grey') then
          if (gin.ne.' ') then
            call bug ('f', 'More than one pixel map image given')
          else
            gin = images(i)
          end if
        else if (imtype(i).eq.'amplitude') then
          if (vin(1).ne.' ') then
            call bug ('f', 'More than one vector amplitude image given')
          else
            vin(1) = images(i)
          end if
        else if (imtype(i).eq.'angle') then
          if (vin(2).ne.' ') then
            call bug ('f', 
     +         'More than one vector position angle image given')
          else
            vin(2) = images(i)
            nvec = 1
          end if
        else if (imtype(i).eq.'box') then
          if (bin.ne.' ') then
            call bug ('f', 'More than one box image given')
          else
            bin = images(i)
          end if
        else if (imtype(i).eq.'mask') then
          if (mskin.ne.' ') then
            call bug ('f', 'More than one mask image given')
          else
            mskin = images(i)
          end if
        else
          call bug ('f', 'Unrecognized image type')
        end if
      end do
c
      if ( (vin(1).ne.' ' .and. vin(2).eq.' ') .or.
     +     (vin(1).eq.' ' .and. vin(2).ne.' ') ) call bug ('f', 
     +   'You must give both vector amplitude & position angle images')
c
c Get on with the rest
c
      call keyi ('xybin', ibin(1), 1)
      call keyi ('xybin', ibin(2), ibin(1))
      if (ibin(2).ne.1 .and. ibin(2).ne.ibin(1)) call bug ('f',
     +  'Non-unit x spatial averaging must be equal to increment')
      ibin(1) = max(ibin(1), 1)
      ibin(2) = max(ibin(2), 1)
c
      call keyi ('xybin', jbin(1), ibin(1))
      call keyi ('xybin', jbin(2), jbin(1))
      if (jbin(2).ne.1 .and. jbin(2).ne.jbin(1)) call bug ('f',
     +  'Non-unit y spatial averaging must be equal to increment')
      jbin(1) = max(jbin(1), 1)
      jbin(2) = max(jbin(2), 1)
c
      call keyi ('chan', kbin(1), 1) 
      call keyi ('chan', kbin(2), 1) 
      kbin(1) = max(kbin(1), 1)
      kbin(2) = max(kbin(2), 1)
      if (kbin(2).gt.kbin(1)) kbin(2) = kbin(1)
c
      call keya ('slev', levtyp(1), 'a')
      call lcase (levtyp(1))
      if (levtyp(1).ne.'p' .and. levtyp(1).ne.'a') call bug ('f', 
     +   'Unrecognized contour level scale type; must be "p" or "a"')
      call keyr ('slev', slev(1), 0.0)
c      
      if (ncon.gt.1) then
        do i = 2, ncon
          call keya ('slev', levtyp(i), 'a')
          call lcase (levtyp(i))
          if (levtyp(i).ne.'p' .and. levtyp(i).ne.'a') call bug ('f', 
     +     'Unrecognized contour level scale type; must be "p" or "a"')
c
          call keyr ('slev', slev(i), 0.0)
        end do
      end if
      do i = 1, maxcon
        str = itoaf(i)
        call mkeyr ('levs'//str,  levs(1,i), maxlev, nlevs(i))
      end do
c
c Get pixel map ranges and transfer functions for each subplot
c
      pixr(1,1) = 0.0
      pixr(2,1) = 0.0
      trfun(1) = 'lin'
      coltab(1) = 1
      present = keyprsnt ('range')
      i = 0
c
      do while (present .and. i.lt.maxgr)
        present = keyprsnt ('range')
        if (present) then
c
c Get new group; just first value present is enough
c
          i = i + 1
          call keyr ('range', pixr(1,i), 0.0)
          call keyr ('range', pixr(2,i), 0.0)
          call keya ('range', trfun(i), 'lin')
          call lcase (trfun)
          call keyi ('range', coltab(i), 1)
c
          if (gin.ne.' ' .and. trfun(i).ne.'lin' .and. 
     +        trfun(i).ne.'log' .and. trfun(i).ne.'heq' .and.
     +        trfun(i).ne.'sqr') then
            call bug ('w',
     +        'Unrecognized image transfer function, setting linear')
            trfun(i) = 'lin'
          end if
        end if
      end do
      npixr = max(i,1)
c
      call keyr ('vecfac', vecfac, 1.0)
      if (vecfac.le.0.0) vecfac = 1.0      
      call keyi ('vecfac', vecinc(1), 2)
      if (vecinc(1).le.0) vecinc(1) = 2
      call keyi ('vecfac', vecinc(2), vecinc(1))
      if (vecinc(2).le.0) vecinc(2) = 2
c
      call keyr ('boxfac', boxfac, 1.0)
      if (boxfac.le.0.0) boxfac = 1.0
      call keyi ('boxfac', boxinc(1), 2)
      if (boxinc(1).le.0) boxinc(1) = 2
      call keyi ('boxfac', boxinc(2), boxinc(1))
      if (boxinc(2).eq.0) boxinc(2) = 2
c
      call keya ('device', pdev, ' ')
c
      call decopt (dofull, do3val, do3pix, eqscale, gaps, solneg,
     +   beambl, beambr, beamtl, beamtr, relax, rot90, signs, 
     +   mirror, dowedge, doerase, doepoch, dofid, dosing)
c
      if (gin.eq.' ') then
        dowedge = .false.
        dofid = .false.
      end if
c
      call keymatch ('labtyp', maxtyp, ltypes, 2, labtyp, nlab)
      if (nlab.eq.0) then
        labtyp(1) = 'relpix'
        labtyp(2) = 'relpix'
      else if (nlab.eq.1) then
        if (labtyp(1).eq.'hms') then
          labtyp(2) = 'dms'
        else
          labtyp(2) = labtyp(1)
        end if
      end if
      if ( (index(labtyp(1),'lin').ne.0  .and. 
     +      index(labtyp(2),'lin').eq.0) .or.
     +     (index(labtyp(2),'lin').ne.0  .and. 
     +      index(labtyp(1),'lin').eq.0) .or.
     +     (index(labtyp(1),'kms').ne.0  .and. 
     +      index(labtyp(2),'kms').eq.0) .or.
     +     (index(labtyp(2),'ghz').ne.0  .and. 
     +      index(labtyp(1),'ghz').eq.0) ) then
        if (eqscale) call bug ('i', 
     +  'You might consider options=unequal with these axis LABTYPs')
      end if
c
      if (vin(1).ne.' ' .and. vin(2).ne.' ') then
        if (signs) then
          call output 
     +       ('Assuming E & N in the direction of increasing X & Y')
        else
          call output ('Assuming E & N to the left and top')
        end if
      end if
c
      dobeam = beambl .or. beambr .or. beamtl .or. beamtr
      if (beambl) then
        beamb = .true.
        beaml = .true.
      else if (beamtl) then
        beamb = .false.
        beaml = .true.
      else if (beambr) then
        beamb = .true.
        beaml = .false.
      else if (beamtr) then
        beamb = .false.
        beaml = .false.
      end if
c
      call keyf ('olay', ofile, ' ')
      if (ofile.ne.' ' .and. (labtyp(1).eq.'none' .or. 
     +    labtyp(2).eq.'none')) call bug ('f', 
     +    'Overlays not allowed with labtyp=none')
c
      call keyi ('nxy', nx, 0)
      call keyi ('nxy', ny, nx)
c
      call keyi ('lines', lwid(1), 1)
      if (lwid(1).le.0) lwid(1) = 1
c
      j = 2
      if (ncon.gt.0) then
        do i = 1, ncon
          call keyi ('lines', lwid(j), 1)
          if (lwid(j).le.0) lwid(j) = 1
          call keyr ('break', break(i), 0.0)
          j = j + 1
        end do
      end if
      if (vin(1).ne.' ') then
        call keyi ('lines', lwid(j), 1)
        j = j + 1
      end if
      if (ofile.ne.' ') call keyi ('lines', lwid(j), 1)
c
      call keyr ('csize', cs(1), 0.0)
      call keyr ('csize', cs(2), 0.0)
      call keyr ('csize', cs(3), 0.0)
c
      call keyr ('scale', scale(1), 0.0)
      call keyr ('scale', scale(2), scale(1))
      if (scale(1).lt.0.0) scale(1) = 0.0
      if (scale(2).lt.0.0) scale(2) = 0.0
c
      end
c
c
      subroutine mmini (maxcon, gmm, cmm)
c-----------------------------------------------------------------------
      implicit none
      integer maxcon
      real gmm(2), cmm(2,maxcon)
cc
      integer i
c-----------------------------------------------------------------------
      gmm(1) =  1.0e30
      gmm(2) = -1.0e30
      do i = 1, maxcon
        cmm(1,i) =  1.0e30
        cmm(2,i) = -1.0e30
      end do
c
      end
c
c
      subroutine olaydec (lun, pl1, npl, maxtyp, ltypes, maxpos, lpos,
     +                    ofile, ofig, npos, opos, posid, owrite)
c-----------------------------------------------------------------------
c     Read overlay positions list file and decode.  The positions in
c     true world coordinates are converted to absolute image pixels
c     taking into account what value of the third axis we have. This
c     is because cdelt is frequency dependent in Miriad so a source
c     moves with frequency through a cube.
c
c   Inputs
c     lun      Handle of image
c     pl1,npl  Start chan & number of chans displayed for this subplot
c     maxtyp   Maximum number of label types
c     ltypes   Possible label types
c     maxpos   Maximum number of allowed overlays
c     lpos     Handle for overlay positions list file
c     ofile    Overlay file name
c  Outputs
c     ofig     Overlay figure type for each overlay
c     npos     Number of overlays
c     opos     Array containing overlay locations
c     posid    Array containing overlay I.D. strings
c     owrite   Write overlay ID on overlay ?
c------------------------------------------------------------------------
      implicit none
c
      integer lpos, maxpos, maxtyp, npos, lun, pl1, npl
      double precision opos(6,maxpos)
      character ltypes(maxtyp)*(*), ofile*(*), posid(maxpos)*(*), 
     +  ofig(maxpos)*(*)
      logical owrite(maxpos)
cc
      integer iostat, ilen
      character aline*100
c
      integer len1
      character itoaf*4
      double precision xoff, yoff, pix3
c------------------------------------------------------------------------
      if (ofile.eq.' ') then
        npos = 0
      else
        call txtopen (lpos, ofile, 'old', iostat)
        if (iostat.ne.0) call bug ('f', 'Error opening positions file')
        call initco (lun)
c
c Read and decode locations.  # means comment
c
        xoff = 0.0
        yoff = 0.0
        npos = 0
        iostat = 0
        pix3 = dble(2*pl1+npl-1) / 2.0
c
        do while (iostat.ne.-1)
          aline = ' '
          call txtread (lpos, aline, ilen, iostat) 
          if (iostat.eq.0) then
            if (aline(1:1).ne.'#' .and. aline.ne.' ') then
              if (index(aline,'OFFSET').ne.0 .or. 
     +            index(aline,'offset').ne.0) then
c
c Fish out offset to be applied to all succeeding overlay locations
c
                call posdec1 (aline, xoff, yoff)
              else
c
c Fish out overlay location and type
c
                if (npos.eq.maxpos) then
                  call bug ('w', 'Reducing no. overlays to max. '//
     +                           'allowed = '//itoaf(maxpos))
                  iostat = -1
                else
                  npos = npos + 1
                  ilen = len1(aline)
                  call posdec2 (lun, pix3, maxtyp, ltypes, npos, 
     +              xoff, yoff, aline(1:ilen), ofig(npos), 
     +              opos(1,npos), posid(npos), owrite(npos))
                end if
              end if
            end if
          else
            if (iostat.ne.-1) call bug ('f', 
     +         'Error reading from overlay file')
          end if
        end do
c
        call finco (lun)
        call txtclose (lpos)
      end if
c
      end
c
c
      subroutine ols2pix (lun, otype, widthx, widthy, pos, widthp)
c-----------------------------------------------------------------------
c     Convert overlay widths into pixels.
c
c  Input
c   lun    Handle of image
c   otype  The overlay units type for this axis
c   widthx,y
c          The overlay widths in units specified by OTYPE
c   pos(1:)The centre of the overlay in absolute pixels
c  Output
c   widthp The overlay widths in pixels
c
c------------------------------------------------------------------------
      implicit none
      integer lun
      character*6 otype(2)
      double precision pos(2), widthx, widthy, widthp(2)
cc
      double precision win(2), wout(2), pixin(2)
      integer i
      character*6 typei(2), typeo(2)
c------------------------------------------------------------------------
c
c Convert centre of overlay to true offset coordinates of
c the type indicated by the OTYPE
c
      do i = 1, 2
        typei(i) = 'abspix'
        pixin(i) = pos(i)
        win(i) = pixin(i)
c
        if (otype(i).eq.'hms' .or. otype(i).eq.'dms' .or.
     +      otype(i).eq.'arcsec') then 
          typeo(i) = 'arcsec'
        else
          typeo(i) = 'rel'//otype(i)(4:6)
        end if
      end do
      call w2wco (lun, 2, typei, ' ', win, typeo, ' ', wout)
c
c Now add the overlay width to the offset coordinate and convert
c to absolute pixels. For circles we just have a radius so we
c only make the conversions for the x axis
c
      win(1) = wout(1) + widthx
      win(2) = wout(2) + widthy
      call w2wco (lun, 2, typeo, ' ', win, typei, ' ', wout)
c
c Subtract the centre of the overlay to get the overlay width in pixels.  
c
      do i = 1, 2
        widthp(i) = abs(wout(i) - pixin(i))
      end do
c
      end
c
c
      subroutine overid (doerase, ofig, x, y, xl, xr, yb, yt, str, 
     +                   csize)
c----------------------------------------------------------------------
c     Write the overlay identification string on the overlay
c
c   Input
c     doerase   True to erase background before writing string
c     ofig      Type of overlay; star, box, clear, line, 
c               circle, and ocircle
c               ID written in corner for star and box
c                             centre for clear, ocircle
c			      right  for circle and line
c     x,y       Centre of overlay in world coordinates
c     xl,xr     X left and right world coordinate of the overlay
c     yb,yt     Y bottom and top world coordinate of the overlay
c     str       Overlay identification string
c     csize     User supplied character size
c
c----------------------------------------------------------------------
      implicit none
c
      real xl, xr, yb, yt, csize, x, y
      character*(*) str, ofig
      logical doerase
cc
      real vpx1, vpx2, vpy1, vpy2, vsx1, vsx2, vsy1, vsy2, wx1, wx2, 
     +  wy1, wy2, xfr, yfr, mx, my, dx, dy, xbox(4), ybox(4), 
     +  dx2, dy2, just
      integer il
c
      integer len1
c----------------------------------------------------------------------
c
c Enquire about plot device characteristics; window in world
c coordinates, view-port in ndcs and view-surface in ndcs
c
      call pgqwin (wx1, wx2, wy1, wy2)
      call pgqvp (0, vpx1, vpx2, vpy1, vpy2)
      call pgqvsz (0, vsx1, vsx2, vsy1, vsy2)
c 
c Find the fraction of the view-surface taken up by the overlay
c        
      if (ofig.eq.'clear'.or.ofig.eq.'line') then
c
c No overlay size in these cases.  Use arbitrary fraction.
c
        xfr = 1.0 / 15.0
        yfr = xfr
      else
        xfr = abs((vpx2-vpx1) / (vsx2-vsx1) * (xr - xl) / (wx2-wx1))
        yfr = abs((vpy2-vpy1) / (vsy2-vsy1) * (yt - yb) / (wy2-wy1))
      end if
c
c Set character size so that it is 1/6 of the overlay size
c until it gets too big or small, or use value given by user
c
      if (csize.le.0.0) then
        csize = 40.0 * min(xfr,yfr) / 6.0
        csize = max(0.25, min(csize,20.0))
      end if
      il = len1(str)
      call pgsch (csize)
c
c Find widths of overlay ID string bounding box and overlay
c
      call pgqtxt (0.0, 0.0, 0.0, 0.0, str(1:il), xbox, ybox)
      dx = xbox(4) - xbox(1) 
      dy = ybox(2) - ybox(1)
      dx2 = xr - xl
      dy2 = yt - yb
c
      if (ofig.eq.'clear' .or. ofig.eq.'ocircle') then
c
c Write ID in centre of overlay; pgtext puts BLC of
c character string at (mx,my)
c
        mx = x
        my = y - dy/2.0 - ybox(1)
        just = 0.5
      else if (ofig.eq.'circle') then
c
c Write ID to side of overlay
c
        mx = xr + dx + dx2/50.0
        my = y - dy/2.0 - ybox(1)
        just = 1.0
      else if (ofig.eq.'line') then
c
c Write ID to side of overlay
c
        mx = xr + dx
        my = yt - dy
        just = 0.0
      else if (ofig.eq.'box' .or. ofig.eq.'star') then
c
c Write ID in top right corner of overlay
c
        mx = xr - xbox(4) - dx2/50.0
        my = yt - ybox(2) - dy2/50.0
        just = 0.0
      end if
c
c Optionally erase rectangle and write string
c
      call strerscg (doerase, just, str(1:il), mx, my)
c
      end
c
c
      subroutine overl (doerase, ofig, ow, blc, trc, npos, opos, posid,
     +   chan, csize, labtyp, naxis, crval, crpix, cdelt, ctype)
c--------------------------------------------------------------------------
c     Draw overlays
c
c     Input
c       doerase  Erase rectangle before writing overlay ID string
c       ofig     'star', 'box', 'clear, 'circle', 'line'
c       ow       If true write overlay ID in corner of overlay
c       blc      Blc of image being plotted in pixels
c       trc      Trc of image being plotted in pixels
c       npos     Number of overlays
c       opos     List of: 
c                       X  Y  XS YS CS CE      'box', 'star'
c                       X1 Y1 X2 Y2 CS CE      'line' 
c                       X Y ... ... CS CE      'clear'  (3&4 unused)
c                       X Y  S  ... CS CE      'circle', 'ocircle'
c                                               (4 unused)
c                All locations and half sizes are in unbinned
c		 full image pixels now except for circle overlays
c		 where the half size (radius) is in pixels according
c		 to the X axis increment.
c       posid    List of overlay I.D.'s
c       chan     Current plane being plotted
c       csize    Character size for overlay ID
c       labtyp   Axis label types
c       naxis    Number of axes
c       c*       Axis descriptors
c----------------------------------------------------------------------
      implicit none
c     
      integer npos, chan, blc(*), trc(*), naxis
      double precision opos(6,npos), crval(naxis), cdelt(naxis), 
     +  crpix(naxis)
      real csize
      character posid(npos)*(*), ofig(npos)*(*), ctype(naxis)*(*),
     +  labtyp(2)*(*)
      logical ow(npos), doerase
cc
      include 'mirconst.h'
      double precision d2r
      parameter (d2r = dpi/180.0)
c
      logical miss, ok
      character line*80
      integer i, j, k, cs, ce
      double precision x, y, xl, xr, yb, yt
      real xcirc(0:360), ycirc(0:360), rat, radx, rady
c----------------------------------------------------------------------
c
c Loop over overlays
c
      call pgsci (3)
      do i = 1, npos
c
c Only draw on specified channels
c
        cs = nint(opos(5,i))
        ce = nint(opos(6,i))
        if (cs.eq.0) ce = 0
        if (ce.eq.0) ce = cs
c
        if (cs.eq.0 .or. (chan.ge.cs .and. chan.le.ce)) then
c
c Extrema in world coordinates
c 
          if (ofig(i).eq.'line') then
            call pix2wcg (.true.,  dble(opos(1,i)), 1, labtyp(1), naxis,
     +                    crval, crpix, cdelt, ctype, xl, ok)
            call pix2wcg (.true.,  dble(opos(2,i)), 2, labtyp(2), naxis, 
     +                    crval, crpix, cdelt, ctype, yb, ok)
            call pix2wcg (.true.,  dble(opos(3,i)), 1, labtyp(1), naxis, 
     +                    crval, crpix, cdelt, ctype, xr, ok)
            call pix2wcg (.true.,  dble(opos(4,i)), 2, labtyp(2), naxis, 
     +                    crval, crpix, cdelt, ctype, yt, ok)
          else if (ofig(i).eq.'star' .or. ofig(i).eq.'box') then
            call pix2wcg (.true.,  dble(opos(1,i)-opos(3,i)), 1, 
     +         labtyp(1), naxis, crval, crpix, cdelt, ctype, xl, ok)
            call pix2wcg (.true.,  dble(opos(2,i)-opos(4,i)), 2, 
     +         labtyp(2), naxis, crval, crpix, cdelt, ctype, yb, ok)
            call pix2wcg (.true.,  dble(opos(1,i)+opos(3,i)), 1, 
     +         labtyp(1), naxis, crval, crpix, cdelt, ctype, xr, ok)
            call pix2wcg (.true.,  dble(opos(2,i)+opos(4,i)), 2, 
     +         labtyp(2), naxis, crval, crpix, cdelt, ctype, yt, ok)
          else if (ofig(i).eq.'circle' .or. ofig(i).eq.'ocircle') then
c
c Remember circle radius in x-axis pixels at this point
c
            rat = abs(cdelt(1) / cdelt(2))
            call pix2wcg (.true.,  dble(opos(1,i)-opos(3,i)), 1, 
     +         labtyp(1), naxis, crval, crpix, cdelt, ctype, xl, ok)
            call pix2wcg (.true.,  dble(opos(2,i)-rat*opos(3,i)), 2,
     +         labtyp(2), naxis, crval, crpix, cdelt, ctype, yb, ok)
            call pix2wcg (.true.,  dble(opos(1,i)+opos(3,i)), 1, 
     +         labtyp(1), naxis, crval, crpix, cdelt, ctype, xr, ok)
            call pix2wcg (.true.,  dble(opos(2,i)+rat*opos(3,i)), 2, 
     +         labtyp(2), naxis, crval, crpix, cdelt, ctype, yt, ok)
c
            radx = (xr - xl) / 2.0
            rady = (yt - yb) / 2.0
          end if
c
c Centre of overlay in world coordinates
c
          call pix2wcg (.true.,  dble(opos(1,i)), 1, labtyp(1), naxis,
     +                  crval, crpix, cdelt, ctype, x, ok)
          call pix2wcg (.true.,  dble(opos(2,i)), 2, labtyp(2), naxis,
     +                  crval, crpix, cdelt, ctype, y, ok)
c
c Draw desired type of overlay
c
          miss = .true.
          if (ofig(i).eq.'star') then
            if (opos(1,i).ge.blc(1).and.opos(1,i).le.trc(1).and.
     +          opos(2,i).ge.blc(2).and.opos(2,i).le.trc(2)) 
     +          miss = .false.
            call pgmove (real(x), real(yb))
            call pgdraw (real(x), real(yt))
            call pgmove (real(xl), real(y))
            call pgdraw (real(xr), real(y))
          else if (ofig(i).eq.'box') then
            if (opos(1,i).ge.blc(1).and.opos(1,i).le.trc(1).and.
     +          opos(2,i).ge.blc(2).and.opos(2,i).le.trc(2)) 
     +          miss = .false.
            call pgmove (real(xl), real(yb))
            call pgdraw (real(xr), real(yb))
            call pgdraw (real(xr), real(yt))
            call pgdraw (real(xl), real(yt))
            call pgdraw (real(xl), real(yb))
          else if (ofig(i).eq.'line') then
            if ((opos(1,i).ge.blc(1).and.opos(1,i).le.trc(1).and.
     +            opos(2,i).ge.blc(2).and.opos(2,i).le.trc(2)) .or.
     +           (opos(3,i).ge.blc(1).and.opos(3,i).le.trc(1).and.
     +            opos(4,i).ge.blc(2).and.opos(4,i).le.trc(2)))
     +          miss = .false.
            call pgmove (real(xl), real(yb))
            call pgdraw (real(xr), real(yt))
          else if (ofig(i).eq.'circle' .or. ofig(i).eq.'ocircle') then
            if (opos(1,i).ge.blc(1).and.opos(1,i).le.trc(1).and.
     +          opos(2,i).ge.blc(2).and.opos(2,i).le.trc(2)) 
     +          miss = .false.
c
c Generate poly-line coordinates
c
            k = 0
            do j = 0, 360
              xcirc(k) = radx*cos(real(j)*d2r) + x
              ycirc(k) = rady*sin(real(j)*d2r) + y
              k = k + 1
            end do
c
c Draw poly-line and fill if necessary
c
            call pgsfs (2)
            if (ofig(i).eq.'circle') call pgsfs (1)
            call pgpoly (k-1, xcirc(0), ycirc(0))
            call pgsfs (2)
          else if (ofig(i).eq.'clear') then
c
c Allow clear overlays anywhere
c
            miss = .false.
          end if
c
          if (miss) then
            write (line,100) i
100         format ('Overlay # ', i4, 
     +              ' does not fully fit on the image')
            call output (line)
          end if
c
c Write overlay identifying number
c
          if (ow(i)) call overid (doerase, ofig(i), real(x), real(y), 
     +                  real(xl), real(xr), real(yb), real(yt), 
     +                  posid(i), csize)
        end if
      end do
      call pgsci (1)
c
      end
c
c
      subroutine posdec1 (aline, xoff, yoff)
c---------------------------------------------------------------------
c     Decode OFFSET string into offsets
c
c     Input
c       aline    Input string
c     Output
c       x,yoff   Offsets
c
c---------------------------------------------------------------------
      implicit none
c
      double precision xoff, yoff
      character*(*) aline
cc 
      integer maxnum
      parameter (maxnum = 10)
c
      double precision nums(maxnum)
      integer lena, ipres, idx, icomm(maxnum)
      logical ok
c--------------------------------------------------------------------
c
c Find end of OFFSET string and start of numbers
c
      idx = index(aline,'OFFSET')
      if (idx.eq.0) idx = index(aline,'offset')
      if (idx.eq.0) call bug ('f', 
     +   'Error finding OFFSET in overlay offset line')
      idx = idx + 6
c
      call strprpcg (maxnum, aline(idx:), icomm, ipres, lena)
      if (ipres.lt.2) call bug ('f', 
     +   'There are insufficient fields for overlay offset line')
      lena = lena + idx - 1
c
c Now extract the numeric part of the line which remains
c
      call matodf (aline(idx:lena), nums, ipres, ok)
      if (.not.ok) then
        call bug ('f', 'Error decoding overlay offset line')
      else
        xoff = nums(1)
        yoff = nums(2)
      end if
c
      end
c
c
      subroutine posdec2 (lun, pix3, maxtyp, ltypes, iline, xoff, yoff,
     +                    aline, ofig, opos, posid, owrite)
c---------------------------------------------------------------------
c     Decode string into positions list
c
c     Input
c       lun      Handle of image
c       pix3     Pixel of third axis for subplot currently 
c                being displayed
c       maxtyp   Maximum number of axis types
c       ltypes   possible label types
c       iline    Line number being decoded
c       x,yoff   Offsets to add to decoded locations
c       aline    Input string
c     Output
c       ofig     Overlay type (star, box, clear, line)
c       opos     Overlay location, list of: 
c                         1  2   3    4   5  6
c			  --------------------
c                         X  Y  XSIZ YSIZ CS CE   'box', 'star'
c                         X1 Y1 X2   Y2   CS CE   'line'
c                         X  Y  ...  ...  CS CE   'clear' (3&4 unused)
c                         X  Y   S   ...  CS CE   'circle' and 'ocircle'
c                                                  (4 unused)
c                All locations and half sizes are in unbinned full
c		 image pixels now except for circle overlays. In this
c		 case, S is in pixels according to the X axis increment.
c       posid    Overlay ID string
c       owrite   True to write overlay ID on plot
c
c---------------------------------------------------------------------
      implicit none
c
      integer iline, maxtyp, lun
      double precision opos(6), xoff, yoff, pix3
      character*(*) aline, posid, ofig, ltypes(maxtyp)
      logical owrite
cc 
      include 'mirconst.h'
      double precision rd
      integer maxnum
      parameter (rd = 180.0/dpi, maxnum = 20)
c
      double precision nums(maxnum), off(2)
      integer i, j, slen, lena, inum, ipres, nextra, npt, ifac, emax,
     +  icomm(maxnum), dsign(2), spos, nuse
      logical ok
      character str*4, estr*80, wover*3, otype(2)*6
c
      integer len1
      character itoaf*4
c
      integer ntype1, ntype2
      parameter (ntype1 = 6, ntype2 = 2)
      character type1(ntype1)*7, type2(ntype2)*3
      data type1 /'box', 'star', 'line', 'clear', 'circle', 'ocircle'/
      data type2 /'yes', 'no'/
c----------------------------------------------------------------------
c
c Prepare string for matodf
c
      str = itoaf(iline)
      slen = len1(str)
      call strprpcg (maxnum, aline, icomm, ipres, lena)
      if (ipres.lt.7) then
        estr = 'There are insufficient fields for overlay # '//
     +          str(1:slen)
        call bug ('f', estr)
      end if
c
c Fish out OFIG, XOTYPE, YOTYPE, ID, WRITE
c
      ofig = aline(1:icomm(1)-1)
      call matchcg (iline, 'OFIG', ofig, 'overlay', ntype1, type1)
c
      otype(1) = aline(icomm(1)+1:icomm(2)-1)
      call matchcg (iline, 'XOTYPE', otype(1), 'overlay', 
     +               maxtyp, ltypes)
      otype(2) = aline(icomm(2)+1:icomm(3)-1)
      call matchcg (iline, 'YOTYPE', otype(2), 'overlay', 
     +               maxtyp, ltypes)
c
      posid = aline(icomm(3)+1:icomm(4)-1)
c
      wover = aline(icomm(4)+1:icomm(5)-1)
      call matchcg (iline, 'WRITE', wover, 'overlay', ntype2, type2)
      call ucase (wover)
      owrite = .true.
      if (wover.eq.'NO') owrite = .false.
      ipres = ipres - 5
c
c How many numbers do we expect in string.  Minimum is:
c  X  Y          for 'box' and  'star'  XS YS CS CE optional
c  X1,Y1 X2,Y2   for 'line' CS CE optional
c  X  Y          for 'clear' CS CE optional
c  X  Y S        for 'circle' and 'ocircle' CS CE optional
c
      inum = 0
      if (ofig.eq.'circle' .or. ofig.eq.'ocircle') inum = 1
      ifac = 1
      if (ofig.eq.'line') ifac = 2
      do j = 1, 2
        if (otype(j).eq.'hms' .or. otype(j).eq.'dms') then
          inum = inum + ifac*3
        else
          inum = inum + ifac*1
        end if
      end do
c
      if (ipres.lt.inum) then
        estr = 'Insufficient numbers for overlay # '//str(1:slen)
        call bug ('f', estr)
      end if
c
c Find DEC sign.  Could be on either axis
c
      dsign(1) = 1
      dsign(2) = 1
      if (otype(1).eq.'dms') then
        spos = 5
        if (aline(icomm(spos)+1:icomm(spos)+1).eq.'-') dsign(1) = -1
      end if
      if (otype(2).eq.'dms') then
        if (otype(1).eq.'hms') then
          spos = 8
        else
          spos = 6
        end if
        if (aline(icomm(spos)+1:icomm(spos)+1).eq.'-') dsign(2) = -1
      end if
c
c Now extract the numeric part of the line which remains
c
      call matodf (aline(icomm(5)+1:lena), nums, ipres, ok)
      if (.not.ok) then
        estr = 'Error decoding overlay # '//str(1:slen)
        call bug ('f', estr)
      end if
c
c Now convert the overlay locations in whatever unit to pixels
c
      off(1) = xoff
      off(2) = yoff
      call ol2pixcg (lun, pix3, ofig, otype, off, dsign, nums, 
     +               opos, nuse)
      npt = nuse + 1
c
c For circles we must fish out the mandatory radius too; we convert 
c it to X axis pixels
c
      if (ofig.eq.'circle' .or. ofig.eq.'ocircle') then
        call ols2pix (lun, otype, nums(npt), 0.0d0, opos(1), opos(3))
        opos(4) = 0.0
        npt = npt + 1
      end if
c
c We have done the mandatory columns, now deal with the optional
c  for 'box' and  'star'  XS YS CS CE optional
c  for 'line'                   CS CE optional
c  for 'clear'                  CS CE optional
c  for 'circle' and 'ocircle'   CS CE optional
c
      nextra = ipres - inum
      emax = 2
      if (ofig.eq.'box' .or. ofig.eq.'star') emax = 4
      if (nextra.gt.emax) call bug ('f', 
     +   'Too many numbers for overlay # '//str(1:slen))
c
      if (ofig.eq.'line' .or. ofig.eq.'clear') then
        if (nextra.eq.0) then
          opos(5) = 0.0
          opos(6) = 0.0
        else if (nextra.eq.1) then
          opos(5) = nums(npt)
          opos(6) = opos(5)
        else if (nextra.eq.2) then
          opos(5) = nums(npt)
          opos(6) = nums(npt+1)
        end if
      else if (ofig.eq.'box' .or. ofig.eq.'star') then
        do i = 3, 6
          opos(i) = 0.0
        end do
        if (nextra.eq.0) then
          opos(3) = 2.0
          opos(4) = 2.0
        else if (nextra.eq.1) then
          call ols2pix (lun, otype, nums(npt), 0.0d0, opos(1), opos(3))
          opos(4) = opos(3)
        else
          call ols2pix (lun, otype, nums(npt), nums(npt+1), 
     +                  opos(1), opos(3))
          if (nextra.eq.3) then
            opos(5) = nums(npt+2)
            opos(6) = opos(5)
          else if (nextra.eq.4) then
            opos(5) = nums(npt+2)
            opos(6) = nums(npt+3)
          end if
        end if
      else if (ofig.eq.'circle' .or. ofig.eq.'ocircle') then
        if (nextra.eq.0) then
          opos(5) = 0.0
          opos(6) = 0.0
        else if (nextra.eq.1) then
          opos(5) = nums(npt)
          opos(6) = opos(5)
        else if (nextra.eq.2) then
          opos(5) = nums(npt)
          opos(6) = nums(npt+1)
        end if
      end if
c
      end
c
c
      subroutine region (maxcon, maxnax, ncon, cin, gin, vin, bin, 
     +   lc, lg, lv, lb, cnaxis, gnaxis, vnaxis, bnaxis, csize, gsize, 
     +   vsize, bsize, ccrval, gcrval, vcrval, bcrval, ccdelt, gcdelt, 
     +   vcdelt, bcdelt, ccrpix, gcrpix, vcrpix, bcrpix, cctype, gctype,
     +   vctype, bctype, cepoch, gepoch, vepoch, bepoch, naxis, size, 
     +   crval, cdelt, crpix, ctype, epoch, ibin, jbin, kbin, blc, trc,
     +   win, maxgrp, grpbeg, ngrp, ngrps, lhead)
c----------------------------------------------------------------------
c     Finish key routie inputs for region of interest now.  Have to 
c     delay until here because of complexity added by mixed 2-D/3-D
c     capability.   The BOXINPUT routine must be associated with the 
c     file that, if any, has three dimensions.    Return also the
c     axis descriptors for all further positional use.  
c
c  Input:
c    maxcon        Maximum number of contour images allowed
c    maxnax        Maximum number of allowed dimenions for image
c    ncon          Number of contour images
c    *in           Image names
c    l*            Handles
c    *naxis        Number of dimensions for images
c    *size         Sizes of images
c    *crpix        Array of image reference pixels
c    *cdelt        Array of image increments 
c    *crval        Array of image reference values 
c    *ctype        Array of image axis types
c    *epoch        Array of epochs
c    i,j,kbin      x,y, and z pixel increment and binning sizes
c    maxgrp        Maximum number of allowed groups
c  Output:
c                  The following axis descriptors are used for all 
c                  subsequent axis information.  They come from whatever 
c                  cube we encounter first or the first 2-D image in 
c                  contour, pixel map, vector order.  
c    naxis         Number of axes
c    size          SIze of axes
c    crpix         Array of image reference pixels
c    cdelt         Array of image increments 
c    crval         Array of image reference values 
c    ctype         Array of image axis types
c    epoch         EPoch
c    blc,trc       3-D Hyper-rectangle surrounding region of interest
c                  in unbinned pixels
c    win           Size of BINNED region of interest for x and y directions
c    grgbeg        List of start planes for each group of channels
c                  that are to be avearged together for each sub-plot
c                  A new group is begun at every interruption to the
c                  continuity of the selected channels, or if the
c                  channel increment is reached.
c    ngrp          Number of channels in each group of channel to
c                  be averaged together for each sub-plot.
c    ngrps         Number of groups of channels.
c    lhead         This is a handle to be used by the COCVT coordinate 
c                  conversion routines (via the COSUBS interface).
c
c----------------------------------------------------------------------
      implicit none
c     
      integer maxcon, ncon, maxnax, naxis, cnaxis(maxcon), gnaxis, 
     +  vnaxis, bnaxis, size(maxnax), csize(maxnax,maxcon), 
     +  gsize(maxnax), vsize(maxnax), bsize(maxnax), blc(*), trc(*), 
     +  win(2), maxgrp, ngrp(maxgrp), grpbeg(maxgrp), ngrps, ibin(2), 
     +  jbin(2), kbin(2), lhead, lc(maxcon), lg, lv, lb
      double precision cdelt(maxnax), crval(maxnax), crpix(maxnax),
     +  ccdelt(maxnax,*), ccrval(maxnax,*), ccrpix(maxnax,*),
     +  gcdelt(maxnax),   gcrval(maxnax),   gcrpix(maxnax),
     +  bcdelt(maxnax),   bcrval(maxnax),   bcrpix(maxnax),
     +  vcdelt(maxnax),   vcrval(maxnax),   vcrpix(maxnax)
      real epoch, cepoch(*), gepoch, vepoch, bepoch
      character*(*) cin(maxcon), gin, vin, bin, ctype(maxnax),
     +  cctype(maxnax,*), gctype(maxnax), vctype(maxnax),
     +  bctype(maxnax)
cc
      include 'maxdim.h'
      integer maxbox
      parameter (maxbox = 1024)
c
      integer boxes(maxbox), i
c----------------------------------------------------------------------
c
c Use the first cube we find to set the rest of the box inputs.
c
      size(3) = 0
      if (ncon.gt.0) then
        do i = 1, ncon
          if (csize(3,i).gt.1 .and. size(3).eq.0) then
            call boxinput ('region', cin(i), boxes, maxbox)
            call boxset (boxes, cnaxis(i), csize(1,i), ' ')
            call setdescg (cnaxis(i), csize(1,i), ccrval(1,i), 
     +         ccdelt(1,i), ccrpix(1,i), cctype(1,i), cepoch(i),
     +         naxis, size, crval, cdelt, crpix, ctype, epoch)
            lhead = lc(i)
          end if
        end do
      end if
c
      if (gin.ne.' ' .and. size(3).eq.0) then
        if (gsize(3).gt.1) then
          call boxinput ('region', gin, boxes, maxbox)
          call boxset (boxes, gnaxis, gsize, ' ')
          call setdescg (gnaxis, gsize, gcrval, gcdelt, gcrpix, gctype,
     +       gepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lg
        end if
      end if
c
      if (vin.ne.' ' .and. size(3).eq.0) then
        if (vsize(3).gt.1) then
          call boxinput ('region', vin, boxes, maxbox)
          call boxset (boxes, vnaxis, vsize, ' ')
          call setdescg (vnaxis, vsize, vcrval, vcdelt, vcrpix, vctype,
     +       vepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lv
        end if
      end if
c
      if (bin.ne.' ' .and. size(3).eq.0) then
        if (bsize(3).gt.1) then
          call boxinput ('region', bin, boxes, maxbox)
          call boxset (boxes, bnaxis, bsize, ' ')
          call setdescg (bnaxis, bsize, bcrval, bcdelt, bcrpix, bctype,
     +       bepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lb
        end if
      end if
c
c If we didn't encounter a cube, then use any of the open
c 2-D images for the box routines.  They have all been
c checked for identical first and second dimensions.
c
      if (size(3).eq.0) then
        if (ncon.gt.0) then
          call boxinput ('region', cin, boxes, maxbox)
          call boxset (boxes, cnaxis, csize, ' ')
          call setdescg (cnaxis, csize, ccrval, ccdelt, ccrpix, cctype, 
     +       cepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lc(1)
        else if (gin.ne.' ') then
          call boxinput ('region', gin, boxes, maxbox)
          call boxset (boxes, gnaxis, gsize, ' ')
          call setdescg (gnaxis, gsize, gcrval, gcdelt, gcrpix, gctype,
     +       gepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lg
        else if (vin.ne.' ') then
          call boxinput ('region', vin, boxes, maxbox)
          call boxset (boxes, vnaxis, vsize, ' ')
          call setdescg (vnaxis, vsize, vcrval, vcdelt, vcrpix, vctype, 
     +       vepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lv
        else if (bin.ne.' ') then
          call boxinput ('region', bin, boxes, maxbox)
          call boxset (boxes, bnaxis, bsize, ' ')
          call setdescg (bnaxis, bsize, bcrval, bcdelt, bcrpix, bctype,
     +       bepoch, naxis, size, crval, cdelt, crpix, ctype, epoch)
          lhead = lb
        else
          call bug ('f', 'Internal logic error in REGION')
        end if
      end if
      call keyfin
c
c Find hyper-rectangle surrounding region of interest from highest 
c dimension image involved (i.e., 2-D/3-D).
c
      call boxinfo (boxes, 3, blc, trc)
      do i = 1, min(3,naxis)
        blc(i) = max(1,blc(i))
        trc(i) = min(size(i),trc(i))
      end do
c
c Adjust spatial window to fit an integral number of bins and
c find size of binned window
c
      call winfidcg (size(1), 1, ibin, blc(1), trc(1), win(1))
      call winfidcg (size(2), 2, jbin, blc(2), trc(2), win(2))
c      if (win(1).le.1 .or. win(2).le.1) call bug ('f',
c     +   'Cannot display just one spatial pixel')
c
c Find list of start channels and number of channels for each group
c of channels selected.  The BOX routines do not easily, if at all,
c allow us to deal with multiple BOXes at once (say if there were
c two differently masked cubes being plotted), so we don't AND
c in the flagging mask.
c
      call chnselcg (blc, trc, kbin, maxbox, boxes, maxgrp,
     +               grpbeg, ngrp, ngrps)
c
      end
c
c
      subroutine sesame (relax, maxdim, maxnax, maxcon, ncon, cin, lc,
     +  cnaxis, csize, cepoch, maskc, ccrpix, ccdelt, ccrval, cctype, 
     +  gin, lg, gnaxis, gsize, gepoch, maskg, gcrpix, gcdelt, gcrval, 
     +  gctype, vin, lv, vnaxis, vsize, vepoch, maskv, vcrpix, vcdelt, 
     +  vcrval, vctype, bin, lb, bnaxis, bsize, bepoch, maskb, bcrpix, 
     +  bcdelt, bcrval, bctype, mskin, lm, mnaxis, msize, mepoch, maskm,
     +  mcrpix, mcdelt, mcrval, mctype, gmm, cmm)
c-----------------------------------------------------------------------
c  Open all required images, check their self consistency and
c  return their axis descriptors and handles
c
c  Input
c   relax     Warning only on axis inconsistencies, else fatal
c   maxdim    Max allowed size of axes
c   maxnax    Max allowed number of dimensions
c   maxcon    Max allowed number of contour images
c   ncon      Number of contour images
c   *in       Image names
c  Output
c   l*        Handles
c   *naxis    Number of axes
c   *size     Size of axes
c   *epoch    Epochs
c   mask*     Masks present ?
c   *crpix    Reference pixels
c   *crval    Reference values
c   *cdelt    Axis increments
c   *ctype    Axis types
c   *mm       Data min and max for each image initialized to +/-1e30
c   
c-----------------------------------------------------------------------
      implicit none
      integer maxdim, maxnax, maxcon, ncon, csize(maxnax,maxcon), 
     +  gsize(maxnax), vsize(maxnax,2), msize(maxnax), bsize(maxnax), 
     +  cnaxis(maxcon), gnaxis, vnaxis(2), mnaxis, bnaxis, lc(maxcon), 
     +  lg, lv(2), lm, lb
      real cepoch(maxcon), gepoch, vepoch(2), mepoch, bepoch,
     +  gmm(2), cmm(2,maxcon)
      double precision 
     +  ccdelt(maxnax,maxcon), ccrval(maxnax,maxcon), 
     +  gcdelt(maxnax), gcrval(maxnax), 
     +  vcdelt(maxnax,2), vcrval(maxnax,2),  
     +  mcdelt(maxnax), mcrval(maxnax),
     +  bcdelt(maxnax), bcrval(maxnax),
     +  ccrpix(maxnax,maxcon), gcrpix(maxnax), 
     +  vcrpix(maxnax,2), mcrpix(maxnax), bcrpix(maxnax)
      logical maskc(maxcon), maskg, maskv(2), maskm, maskb, relax
      character*(*) cin(maxcon), gin, vin(2), mskin, bin
      character*9 cctype(maxnax,maxcon), gctype(maxnax),
     +  vctype(maxnax,2), mctype(maxnax), bctype(maxnax)
cc
      integer i
c-----------------------------------------------------------------------
c
c Initialize data min and max
c
      call mmini (maxcon, gmm, cmm)
c
c
c Open contour images as required 
c
      if (ncon.gt.0)  then
        do i = 1, ncon
          call opimcg (maxdim, maxnax, cin(i), lc(i), cnaxis(i), 
     +      csize(1,i), cepoch(i), maskc(i), ccrpix(1,i), ccdelt(1,i),
     +      ccrval(1,i), cctype(1,i))
        end do
      end if
c
c Open pixel map image as required
c
      if (gin.ne.' ') then
        call opimcg (maxdim, maxnax, gin, lg, gnaxis, gsize, gepoch,
     +     maskg, gcrpix, gcdelt, gcrval, gctype)
      end if
c
c Open vector images as required
c
      if (vin(1).ne.' ' .and. vin(2).ne.' ') then
        do i = 1, 2
          call opimcg (maxdim, maxnax, vin(i), lv(i), vnaxis(i), 
     +      vsize(1,i), vepoch(i), maskv(i), vcrpix(1,i), vcdelt(1,i),
     +      vcrval(1,i), vctype(1,i))
        end do
      end if
c
c Open box image as required
c
      if (bin.ne.' ') then
        call opimcg (maxdim, maxnax, bin, lb, bnaxis, bsize, bepoch,
     +     maskb, bcrpix, bcdelt, bcrval, bctype)
      end if
c
c Open mask image as required
c
      if (mskin.ne.' ') then
        call opimcg (maxdim, maxnax, mskin, lm, mnaxis, msize, mepoch, 
     +     maskm, mcrpix, mcdelt, mcrval, mctype)
        if (.not.maskm)  then
          call bug ('w', 'The mask image does not have a mask')
          call xyclose (lm)
          mskin = ' '
        end if
      end if
c
c Check consistency of input images
c
      call chkim  (maxnax, ncon, cin, csize, cepoch, ccrpix, ccdelt, 
     +   ccrval, cctype, gin, gsize, gepoch, gcrpix, gcdelt, gcrval, 
     +   gctype, vin, vsize, vepoch, vcrpix, vcdelt, vcrval, vctype, 
     +   bin, bsize, bepoch, bcrpix, bcdelt, bcrval, bctype, mskin, 
     +   msize, mepoch, mcrpix, mcdelt, mcrval, mctype, relax)
c
      end











c**********************************************************************
c     A collection of subroutines shared by the programs CGDISP,
c     CGSPEC, CGCURS, and CGSLICE. All these subroutines call PGPLOT. 
c
c  annboxcg :  Annotate information from one box image
c  annconcg :  Annotate information from one contour image
c  anndefcg :  Define size of character for annotation
c  anngrscg :  Annotate informatiobn from one grey scale image
c  anninicg :  Initialize plot annotation and write reference value
c  annspccg :  Annotate information from all spectrum images
c  annveccg :  Annotate information from one pair of vector images
c  annwincg :  Annotate plot with window and channel info 
c  axlabcg  :  Label axes
c  boxcg    :  Draw axes with optional numeric labels
c  confmtcg :  Format contour levels
c  conturcg :  Draw contour plot
c  erswincg :  Erase window
c  lab3cg   :  Label sub-plot with value and/or pixel of third axis
c  setlabcg :  Set axis label displacements 
c  strerscg :  Erase rectangle on plot and write string into it
c  strfmtcg :  Format a number into a string with PGNUMB
c  vpadjcg  :  Adjust viewport if equal scales requested
c  vpsizcg  :  Set encompassing viewport and subplot increments
c  wedgecg  :  High level routine to draw wedges (calls WEDGCG)
c  wedgcg   :  Draw grey scale wedge in specified viewport
c  yhtwcg   :  Find y-height of one character in world coordinates
c
c  History:
c     nebk   20sep91    Created from PGDISP/PGCURS
c     nebk   08nov91    Use local blc,trc in call to BOXRUNS in
c                       CHNSELPG, because they may get modified
c                       if blanked pixels exist
c     nebk   28apr92    "g" format seems to behave capriciously
c                        Try to do something better in VCLABPG
c                        Renamed subroutines to *cg from *pg 
c                        as pgdisp etc -> cgdisp etc
c     nebk   12may92     Return actual scales in VPADJCG
c     nebk   14may92     Add  LIMTRCG. Add a couple more
c                        parameters to HEDINFCG
c     nebk   18may92     Add AXFNDCG
c     nebk   04jul92     Don't modify variable (PLAV) in READIMCG. Add
c                        OTOPIXCG, SETTRCG, CONLINCG, STRERSCG, DEGHSMCG,
c			 ANN*CG, CHKDESCG, CHKDIMCG,  add argument 
c			 MIRROR to CONLEVCG 
c     nebk   08jul82     Add OPTCG and INIT/NORM to READIMCG call. FIx 
c                        bug in CHNSELCG causing groups to be redundantly
c                        specified under some circumstances
c     nebk   14jul92     Add POSOFF to OTOPIXCG. Type CDELT and CRVAL
c			 as DOUBLE PRECISION
c     nebk   07aug92     Try to instill some more modularity into all 
c                        coordinate conversions with PIX2WCG and
c                        W2PIXCG, removing SETTRCG along the way.
c     nebk   22oct92     Add units to velocity and frequency axes 
c			 in LIMTRCG.  SETLABCG was not correctly 
c                        setting the dms,hms PGTBOX strings.
c     nebk   28nov92     Add 'abs/relkms' and 'abs/relghz' label types
c                        Change "linear" to "abslin"
c     nebk   02dec92     Add pix2wfcg, sunitcg
c     nebk   24dec92     SPlit off from cgsubs.for
c     nebk   27feb93     Appease Mr T and reformat call sequence
c                        variable code
c     mjs    15mar93     pgplot names have 6 or less chars.
c     nebk   21apr93     vclabcg -> lab3cg and make it generic so that
c                        whatever is on the third axis gets labelled
c     nebk   27may93     Add YHTQCG and use it in a few places
c     nebk   29may93     Replace CHTONVCG by new PGQCS
c     nebk   02jun93     Replace VSSIZECG by new PGQVSZ
c     nebk   02jun93     Move ANNDEFCG, VPADJCG, VPASPCG here from
c			 CGSUBS.FOR as they now call PGPLOT
c     nebk   16jun93     Remove VPASPCG.  Its functions can now be done
c                        with PGQCS
c     nebk   23jun93     Rework VPADJCG because rellin/abslin for RA 
c   			 axes now gives radians of polar rotation
c                        Correctly deal with user given scales
c     nebk   25aug93     Add "absdeg" and "reldeg" axis types.
c			 Scrap DEGHMSCG in favour of new DANGLEH
c                        Add DOERASE to STRERSCG and LAB3CG
c     nebk   13nov93     Minor change to AXLABCG with options strings
c                        Better units for Amax in ANNVECCG
c     nebk   14dec93     Variety of formatting changes in ANN* routines
c     nebk   09jan94     Convert CRPIX to double precision
c     nebk   17jan94     Add fiddle viewport and grey wedge to VPADJCG
c     nebk   27jan94     Add WEDGCG, ERSWINCG and BOXCG
c     nebk   02mar94     Justification->1.0 in PGMTXT call in AXLABCG
c                        Imported SETLABCG from cgsubs.for as it now
c                        calls PGQCS to be cleverer about displacements
c     nebk   08mar94     Move WEDGECG here from CGSUBS.FOR. Variables
c                        PLINC&PLAV -> KBIN(1:2)
c     nebk   17mar94     Get rid of horrid hoop jumping in STRERSCG
c			 with new PGSTBG routine
c     nebk   15jun94     Include spatial binning info in ANNWINCG
c                        CHange LAB3CG positioning algorithm slightly
c                        Add justification to STRERSCG
c     nebk   28jun94     Add ANNBOXCG, STRFMTCG, CONFMTCG and remove
c                        CONLINCG.  Add box type images to VPSIZCG
c     nebk   12jul94     Mess about with scale algorithm in VPADJCG
c     nebk   02aug94     LAB3CG was getting value wrong when channels
c                        averaged together
c     nebk   24aug94     Change LAB3CG to use COSUBS coordinate conversion
c                        routines to label with true world value of third
c                        third axis
c     nebk   23dec94     Strings (str1:4) not long enough in ANNWINCG
c                        Increase length of STR1 in CONFMTCG
c     nebk   05jan95     Replace PGGRAY by new PGIMAG. 
c     nebk   14apr95     Label grey scales as "pixel maps" in ANNGRSCG
c**********************************************************************
c
c* annboxCG -- Annotate plot with information from a box image 
c& nebk
c: plotting
c+
      subroutine annboxcg (lb, bin, bfac, yinc, xpos, ypos)
c
      implicit none
      integer lb
      real bfac(5), yinc, xpos, ypos
      character*(*) bin
c
c  Annotate plot with box image information
c
c  Input:
c    lb      Handle for box images
c    bin     Box image
c    bfac    (1)   Maximum value if pixel in region of first subplot
c            (2-3) Scale factors, in x and y, to convert pixel value
c                  into box width in world coordinates
c            (4-5) Scale factors, in x and y, giving box widths per mm 
c                  E.g. if pixel is 50 rad/m/m, then these scale factors
c                  say you have bfac(4) and bfac(5) rad/m/m per mm
c    yinc    World increment between text lines
c    xpos    World x coordinate for text lines
c  Input/output
c    ypos    World y coordinate for next text line
c--
c-----------------------------------------------------------------------
      character src*50, str1*132, str2*132, str3*132, str4*132,
     +  units*20, btype*30, rtoaf*20
      integer len1, iu, i1, i2, i3, i4
c-----------------------------------------------------------------------
c
c File and objects
c
      call rdhda (lb, 'object', src, ' ')
      if (src.ne.' ') then
         str2 = ' ('//src(1:len1(src))//')'
         i2 = len1(str2)
      else 
         str2 = ' '
         i2 = 1
      end if
      str1 = ' Box image: '//bin(1:len1(bin))//str2(1:i2)
      i1 = len1(str1)
c
      call rdhda (lb, 'bunit', units, ' ')
      call rdbtype (lb, btype, ' ')
      if (units.eq.' ') then
        if (btype.eq.'fractional_polarization') then
          units = 'ratio'
        else if (btype.eq.'depolarization_ratio') then
          units = 'ratio'
        else if (btype.eq.'polarized_intensity') then
          units = 'Jy/beam'
        else if (btype.eq.'rotation_measure') then
          units = 'rad m\u-2\d'
        end if
      end if
      iu = max(1,len1(units))
c
c Format scale factors and peak value
c
      str2 = rtoaf(bfac(4),0,4)
      i2 = len1(str2)
      str3 = rtoaf(bfac(5),0,4)
      i3 = len1(str3)
      str4 = rtoaf(bfac(1),0,4)
      i4 = len1(str4)
c
      str1(i1+1:) = ' |B\dmax\u|='//str4(1:i4)//' '//units(1:iu)//
     +              ', x,y-scale='//str2(1:i2)//','//str3(1:i3)//' '//
     +               units(1:iu)//'/mm'
      i1 = len1(str1)
c
      call pgtext (xpos, ypos, str1(1:i1))
      ypos = ypos - yinc
c
      end
c
c* annconCG -- Annotate plot with information from a contour image
c& nebk
c: plotting
c+
      subroutine annconcg (lc, cin, slev, nlevs, levs, srtlev, dmm,
     +                     yinc, xpos, ypos)
c
      implicit none
      integer nlevs, lc, srtlev(nlevs)
      real slev, xpos, ypos, yinc, levs(nlevs), dmm(2)
      character*(*) cin
c
c  Annotate plot with contour image information
c
c  Input:
c    lc      Handle for contour image
c    cin       Contour image name
c    slev      Scale factor that levels are scaled by
c    nlevs     Number of levels
c    levs      Contour levels
c    srtlev    Array  giving levels in increasing order
c    dmm       Data min/max
c    yinc      Y increment between bases of successive lines of text
c              in normalized device coordinates
c    xpos      X location for text
c  Input/output:
c    ypos      Y location for text.  On output, is the location for
c              the next line.
c--
c-----------------------------------------------------------------------
      character str1*132, str2*132, str3*132, src*20, rtoaf*20, units*20
      integer i1, i2, i3, len1, nlines
c-----------------------------------------------------------------------
c
c Source name
c
      call rdhda (lc, 'object', src, ' ')
      if (src.ne.' ') then
        str1 = ' Contour image: '//cin(1:len1(cin))//' ('//
     +         src(1:len1(src))//')'
      else
        str1 = ' Contour image: '//cin(1:len1(cin))
      end if
      i1 = len1(str1)
c
c Write data min and max
c
      str2 = rtoaf(dmm(1),0,4)
      i2 = len1(str2)
      str3 = rtoaf(dmm(2),0,4)
      i3 = len1(str3)
      str1(i1+1:) = '  Min/max='//str2(1:i2)//
     +              '/'//str3(1:i3)
      i1 = len1(str1)
c
c Scale factors
c
      str2 = '  Contours x '//rtoaf(slev,0,4)
      i2 = len1(str2)
      if (slev.ne.1.0) str1(i1+1:) = str2(1:i2)
      i1 = len1(str1)
c
c Tack on units
c
      call rdhda (lc, 'bunit', units, ' ')
      if (units.ne.' ') str1(i1+1:) = ' '//units(1:len1(units))
      i1 = len1(str1)
c
      call pgtext (xpos, ypos, str1(1:i1))
      ypos = ypos - yinc
c
c Write out contour levels
c
      call confmtcg (xpos, ypos, yinc, nlevs, srtlev, levs, slev, 
     +               .true., nlines)
c
      end

c
c* anndefCG --Empirical definition of full annotation character size
c& nebk
c: plotting
c+
      subroutine anndefcg (cs, yinc, ygap)
c
      implicit none
      real cs, yinc, ygap
c
c  Empirical definition of size of normalized y viewsurface per 
c  character height for when doing full plot annotation. 
c  One character is defined to be 0.14 inches tall.
c
c  Output:
c    cs    The PGPLOT character size requred to make the required
c          character height
c    yinc  The distance between the bottoms of successive text 
c          lines in units of one character height
c    ygap  Gap between x label and annotaiton text in annotation
c          (CS) character heights
c--
c----------------------------------------------------------------------
      real xht, yht
c----------------------------------------------------------------------
c
c Find height of one character in mm for text written
c vertically and horizontally
c
      call pgsch (1.0)
      call pgqcs (2, xht, yht)
c
c Compute number of character heights in 3mm 
c
      cs = 3.0 / yht
c
c Set separation between text lines in character heights
c
      yinc = 1.2
c
c Gap between bottom of x-axis label and start of full annotation
c in unuts of annotation character height
c
      ygap = 0.75
c
      end
c
c* anngrsCG -- Annotate plot with information from a pixel map image
c& nebk
c: plotting
c+
      subroutine anngrscg (lg, gin, npixr, pixr, trfun, dmm,
     +                     yinc, xpos, ypos)
c
      implicit none
      integer lg, npixr
      real pixr(2), yinc, xpos, ypos, dmm(2)
      character*(*) gin, trfun
c
c  Annotate plot with pixel map image information
c
c  Input:
c    lg      Handle for pixel map image
c    gin     pixel map image
c    npixr   Number of greys scale range groups given by user
c    pixr    pixel map intensity range
c    trfun   Transfer function type
c    yinc    World increment between text lines
c    xpos    World x coordinate for text lines
c    dmm     Min and max displayed for this image
c  Input/output
c    ypos    World y coordinate for next text line
c--
c-----------------------------------------------------------------------
      character src1*50, str1*132, str2*132, str3*132, 
     +  units*9, rtoaf*20
      integer len1, i1, i2, i3
c-----------------------------------------------------------------------
c
c Write image name
c
      call rdhda (lg, 'object', src1, ' ')
      if (src1.ne.' ') then
        str1 = ' Pixel map image: '//gin(1:len1(gin))//' ('//
     +          src1(1:len1(src1))//')'
      else
        str1 = ' Pixel map image: '//gin(1:len1(gin))
      end if
      i1 = len1(str1)
c
c Write data min and max
c
      str2 = rtoaf(dmm(1),0,4)
      str3 = rtoaf(dmm(2),0,4)
      str1(i1+1:) = '  Min/max='//str2(1:len1(str2))//
     +              '/'//str3(1:len1(str3))
      i1 = len1(str1)
c
c Write pixel map ranges
c
      call rdhda (lg, 'bunit', units, ' ')
      if (npixr.eq.1) then
        str2 = rtoaf(pixr(1),0,4)
        i2 = len1(str2)
        str3 = rtoaf(pixr(2),0,4)
        i3 = len1(str3)
c
        str1(i1+1:) = '  Range = '//str2(1:i2)//' to '//str3(1:i3)
        i1 = len1(str1)
c
        if (units.ne.' ') then
          str1(i1+1:) = ' '//units(1:len1(units))//' ('//trfun//')'
        else
          str1(i1+1:) = ' ('//trfun//')'
        end if
      else
        if (units.ne.' ') then
          str1(i1+1:) = ' '//units(1:len1(units))//'  Various ranges'
        else
          str1(i1+1:) = '  Various ranges'
        end if
      end if
      i1 = len1(str1)
c
      call pgtext (xpos, ypos, str1(1:i1))
      ypos = ypos - yinc
c
      end
c
c* anniniCG -- Init. plot annotation and write reference values to plot
c& nebk
c: plotting
c+
      subroutine anninicg (no3, naxis, crpix, crval, cdelt, ctype, 
     +                     vymin, pcs, ydispb, labtyp, xpos, ypos, yinc)
c
      implicit none
      integer naxis
      real xpos, ypos, yinc, pcs, ydispb, vymin
      double precision crval(naxis), cdelt(naxis), crpix(naxis)
      character*(*) ctype(naxis), labtyp(2)
      logical no3
c
c  Do some set up chores for the full plot annotation and
c  write the reference values to the plot.  The window is
c  redefined to be the same as the available part of the
c  view-surface in normalized device coords (0 -> 1) to make
c  life easier.
c    
c  Input
c   no3      DOn't write ref pix for third axis
c   naxis    NUmber of axes
c   c*       Axis descriptors
c   vymin    y viewsurface normalized device coordinate
c            at which the lowest sub-plot x-axis is drawn
c   pcs      PGPLOT character size parameters for plot labelling 
c            (not the annotation)
c   ydispb   Displacement of x-axis label in character heights
c   labtyp   Axis label types
c Output
c   x,ypos   World coordinate of next line of text to be written
c   yinc     World increment between lines of text
c--
c-----------------------------------------------------------------------
      include 'mirconst.h'
      include 'maxnax.h'
      double precision rd
      parameter (rd = 180.0/dpi)
c
      real xht, yht, xhta, yhta, acs, ychinc, yoff, ygap
      character str1*132, str2*132, abstyp*6, gentyp(maxnax)*4, 
     +  refstr*60
      integer len1, maxis, ip, il1, i
c-----------------------------------------------------------------------
c
c Define viewport to space left at bottom of viewsurface and define
c the window to something easy to use here.  Define character size
c for annotation
c
      call pgsvp (0.0, 1.0, 0.0, vymin)
      call pgswin (0.0, 1.0, 0.0, vymin)
      call anndefcg (acs, ychinc, ygap)
c
c Find size of one character in n.d.c. for axis labels and annotation
c
      call pgsch (pcs)
      call pgqcs (0, xht, yht)
      call pgsch (acs)
      call pgqcs (0, xhta, yhta)
c
c Find start of annotation, allowing for x-label and a bit of space
c between label and annotation
c
      if (labtyp(1).eq.'none') then
        yoff = (1.0 + ygap)*yhta
      else
        yoff = ydispb*yht + (1.0 + ygap)*yhta
      end if
c
c Increment between annotation lines in world coordinates (recall
c n.d.c. = world coordinates with the above viewport deifnitions)
c
      yinc = ychinc * yhta
c
      xpos = 0.0
      ypos = vymin - yoff
c
c Format reference pixels of each axis.
c
      str1 = ' '
      maxis = min(3,naxis)
      if (no3) maxis = min(2,naxis)
      ip = 2
      do i = 1, maxis
        call axtypcg (1, ctype(i), gentyp(i))
        il1 = len1(gentyp(i))
c
c Bit of a mess for UU or VV as their generic descriptor is UV
c
        if (gentyp(i)(1:il1).eq.'UV') then
          if (index(ctype(i),'UU').ne.0 .or. 
     +        index(ctype(i),'uu').ne.0) then
            str1(ip:) = 'UU,'
          else 
            str1(ip:) = 'VV,'
          end if
        else
          write (str1(ip:),'(a)') gentyp(i)(1:il1)//','
        end if
        ip = len1(str1) + 2
      end do
c
      ip = len1(str1)
      str1(ip:) = ' = '
      ip = ip + 3
      do i = 1, maxis
        call axabscg (1, gentyp(i), abstyp)
        call pix2wfcg (abstyp, i, crpix(i), naxis, crval, crpix,
     +                 cdelt, ctype, .false., refstr, il1)
c
        write (str1(ip:),'(a)') refstr(1:il1)//','
        ip = len1(str1) + 2
      end do     
c
      ip = len1(str1)
      write (str1(ip:), '(a)') ' at pixel ('
      ip = len1(str1) + 1
      do i = 1, maxis
        call strfd (crpix(i), '(f7.2)', str2, il1)
        str1(ip:) = str2(1:il1)//','
        ip = ip + il1 + 2
      end do
      ip = len1(str1)
      str1(ip:ip) = ')'
c
      call pgtext (xpos, ypos, str1(1:ip))
c
c Increment location
c
      ypos = ypos - yinc
c
      end
c
c* annspcCG -- Annotate plot with information from spectrum images
c& nebk
c: plotting
c+
      subroutine annspccg (nspec, spin, iscale, yinc, xpos, ypos)
c
      implicit none
      integer nspec
      real yinc, xpos, ypos, iscale(nspec)
      character*(*) spin(nspec)
c
c     Annotate plot with spectrum image information
c
c  Input:
c    nspec   NUmber of spectrum images
c    spin    Image names
c    iscale  Scale factor for each image
c    yinc    World increment between text lines
c    xpos    World x coordinate for text lines
c  Input/output
c    ypos    World y coordinate for next text line
c--
c-----------------------------------------------------------------------
      real xpos2, xlen, ylen
      character str1*132, str2*20, rtoaf*20
      integer len1, i1, i2, i
c-----------------------------------------------------------------------
c
c Write spectrum image names; there will be at least one
c Write them in the same colour they were plotted
c
      xpos2 = xpos
      call pgsci (7)
      call pgtext (xpos2, ypos, ' Spectrum images :')
      call pglen (4, ' Spectrum images :AA', xlen, ylen)
      xpos2 = xpos2 + xlen
c
      do i = 1, nspec
        str2 = rtoaf (iscale(i),0,4)
        i2 = len1(str2)
        str1 = spin(i)(1:len1(spin(i)))//' ('//str2(1:i2)//'),'
        i1 = len1(str1)
        if (i.eq.nspec) str1(i1:i1) = ' '
c
        call pgsci (i+1)
        call pgtext (xpos2, ypos, str1(1:i1))
c
        call pglen (4, str1(1:i1)//'AA', xlen, ylen)
        xpos2 = xpos2 + xlen
      end do
      ypos = ypos - yinc
      call pgsci (7)
c
      end
c
c* annvecCG -- Annotate plot with information from a vector image pair
c& nebk
c: plotting
c+
      subroutine annveccg (lv, vin, vfac, yinc, xpos, ypos)
c
      implicit none
      integer lv(2)
      real vfac(2), yinc, xpos, ypos
      character*(*) vin(2)
c
c  Annotate plot with vector image information
c
c  Input:
c    lv      Handles for vector images
c    vin     Vector image 
c    vfac    Maximum vector amplitude and scale in pixel units
c	     per mm (e.g. jy/beam per mm, or ratio per mm)
c    yinc    World increment between text lines
c    xpos    World x coordinate for text lines
c  Input/output
c    ypos    World y coordinate for next text line
c--
c-----------------------------------------------------------------------
      character src1*50, src2*50, str1*132, str2*132, str3*132, 
     +  units*20, btype*30
      integer len1, i1, i2, i3, iu
c-----------------------------------------------------------------------
c
c Image name
c
      call rdhda (lv(1), 'object', src1, ' ')
      if (src1.ne.' ') then
         str3 = ' ('//src1(1:len1(src1))//')'
         i3 = len1(str3)
      else 
         str3 = ' '
         i3 = 1
      end if
c
      call rdhda (lv(2), 'object', src2, ' ')
      if (src2.ne.' ') then
         str2 = ' ('//src2(1:len1(src2))//')'
         i2 = len1(str2)
      else 
         str2 = ' '
         i2 = 1
      end if
      str1 = ' Vector images: '//vin(1)(1:len1(vin(1)))//
     +         str2(1:i2)//', '//vin(2)(1:len1(vin(2)))//str3(1:i3)
      i1 = len1(str1)
c
c Units
c
      call rdhda (lv(1), 'bunit', units, ' ')
      call rdbtype (lv(1), btype, ' ')
      if (units.eq.' ') then
        if (btype.eq.'fractional_polarization') then
          units = 'ratio'
        else if (btype.eq.'depolarization_ratio') then
          units = 'ratio'
        else if (btype.eq.'polarized_intensity') then
          units = 'Jy/beam'
        else if (btype.eq.'rotation_measure') then
          units = 'rad m\u-2\d'
        end if
      end if
      iu = max(1,len1(units))
c
c Format peak and scale factor
c
      call strfmtcg (vfac(1), 4, str2, i2)
      call strfmtcg (vfac(2), 4, str3, i3)
c
      str1(i1+1:) = ' |A\dmax\u|='//str2(1:i2)//' '//units(1:iu)//
     +              ', scale='//str3(1:i3)//' '//units(1:iu)//'/mm'
      i1 = len1(str1)
c
      call pgtext (xpos, ypos, str1(1:i1))
      ypos = ypos - yinc
c
      end
c
c* annwinCG -- Annotate plot with spatial window
c& nebk
c: plotting
c+
      subroutine annwincg (blc, trc, ibin, jbin, kbin, naxis, size,
     +                     cdelt, ctype, yinc, xpos, ypos)
c
      implicit none
      integer blc(*), trc(*), ibin(2), jbin(2), kbin(2), naxis, 
     +  size(naxis)
      real xpos, ypos, yinc
      double precision cdelt(naxis)
      character*(*) ctype(naxis)
c
c  Annotate plot with spatial window and channel increments
c
c  Input:
c    blc,trc   Window in pixels
c    i,jbin    Spatial inc and bin.
c    kbin      Channel increment and averaging size. If both 0,
c              don't write them out
c    naxis     Number of axes
c    size      Size of axes
c    cdelt     Pixel increments
c    ctype     Axis types
c    xpos      X location for text
c    yinc      Y increment between bases of successive lines of text
c              in normalized device coordinates
c  Input/output:
c    ypos      Y location for text.  On output, is the location for
c              the next line.
c--
c-----------------------------------------------------------------------
      character*8 str1, str2, str3, str4
      character*132 stra, strb, strc, strd, stre, line*200
      character gentyp*4, units*10
      integer i1, i2, i3, i4, ia, ib, ic, id, ie, il, iu
c
      integer len1
c-----------------------------------------------------------------------
c
c Format spatial window
c
      call pgnumb (blc(1), 0, 0, str1, i1)
      call pgnumb (blc(2), 0, 0, str2, i2)
      call pgnumb (trc(1), 0, 0, str3, i3)
      call pgnumb (trc(2), 0, 0, str4, i4)
      stra = ' Spatial region : '//str1(1:i1)//','//str2(1:i2)//' to '//
     +                            str3(1:i3)//','//str4(1:i4)
      ia = len1(stra)
c
c Format spatial binning
c
      if (ibin(1).gt.1 .or. ibin(2).gt.1 .or. jbin(1).gt.1 .or.
     +    jbin(2).gt.1) then
        call pgnumb (ibin(1), 0, 0, str1, i1)
        call pgnumb (ibin(2), 0, 0, str2, i2)
        call pgnumb (jbin(1), 0, 0, str3, i3)
        call pgnumb (jbin(1), 0, 0, str4, i4)
        strb = 'Spatial inc/bin : '//str1(1:i1)//'/'//str2(1:i2)//', '//
     +          str3(1:i3)//'/'//str4(1:i4)
        ib = len1(strb)
      else
        strb = ' '
        ib = 1
      end if
c
c Format spectral binning
c
      if (size(3).gt.1 .and. (kbin(1).gt.0 .and. kbin(2).gt.0)) then      
        call pgnumb (kbin(1), 0, 0, str1, i1)
        call pgnumb (kbin(2), 0, 0, str2, i2)
        strc = ' Spectral inc/bin : '//str1(1:i1)//'/'//str2(1:i2)
        ic = len1(strc)
c
        call strfmtcg (real(abs(kbin(1)*cdelt(3))), 4, str1, i1)
        call strfmtcg (real(abs(kbin(2)*cdelt(3))), 4, str2, i2)
c
        call axtypcg (1, ctype(3), gentyp)
        if (gentyp.eq.'FREQ') then
          units = 'GHz'
        else if (gentyp.eq.'VELO') then
          units = 'Km/s'
        else 
          units = 'none'
        end if
        iu = len1(units)
c  
        if (units.eq.'none') then
          strd = '='//str1(1:i1)//'/'//str2(1:i2)
        else
          strd = '='//str1(1:i1)//'/'//str2(1:i2)//' ('//
     +                units(1:iu)//')'
        end if
        id = len1(strd)
c
        stre = strc(1:ic)//' '//strd(1:id)
        ie = len1(stre)
      else
        stre = ' '
        ie = 1
      end if
c
      line = stra(1:ia)//' '//strb(1:ib)//' '//stre(1:ie)
      il = len1(line)
      call pgtext (xpos, ypos, line(1:il))
      ypos = ypos - yinc
c
      end
c
c* axlabCG -- Label axes
c& nebk
c: plotting
c+
      subroutine axlabcg (gaps, nx, ny, nz, nlast, iplot, xopts, yopts,
     +   xdispl, ydispb, labtyp, xlabel, ylabel, xxopts, yyopts)
c
      implicit none
      real xdispl, ydispb
      integer nx, ny, nz, nlast, iplot
      logical gaps
      character xopts*(*), yopts*(*), xxopts*(*), yyopts*(*),
     +  xlabel*(*), ylabel*(*), labtyp(2)*(*)
c
c  Label axes and prepare options strings for PGTBOX according to whether 
c  the sub-plots abut each other or not
c
c  Input
c    gaps    False means sub-plots abut, else they don't
c    nx,ny   Number of sub-plots in x and y directions on page
c    nz      Total number of sub-plots that will be drawn
c    nlast   Number of sub-plots on the last row of the last page
c    iplot   Number of current sub-plot
c    x,yopts Root option strings for PGTBOX
c    xdispl  Displacement in character heights of y-axis label
c    ydispb  Displacement in character heights of x-axis label
c    labtyp  Axis label types
c    xlabel  X-axis label
c    ylabel  Y-axis label
c  Output
c    xxopts  x-axis options string for PGTBOX
c    yyopts  y-axis options string for PGTBOX
c--
c-----------------------------------------------------------------------
      integer jplot, ix, iy
      integer len1
c-----------------------------------------------------------------------
      jplot = mod(iplot,nx*ny)
      if (jplot.eq.0) jplot = nx*ny
      ix = len1(xopts)
      iy = len1(yopts)
      xxopts = xopts(1:ix)
      yyopts = yopts(1:iy)
c
      if (.not.gaps) then
c
c When sub-plots abut each other, only label along the left most
c and bottom axes
c
        if (labtyp(1).ne.'none' .and. 
     +     (jplot.ge.nx*ny-nx+1 .or. iplot.ge.nz-nlast+1 .or.
     +      iplot+nx.gt.nz)) then
c
c Write x-axis label and prepare options string for numeric labelling
c
          if (mod(jplot,nx).eq.1) then
            xxopts = xopts(1:ix)//'N'
          else
            xxopts = xopts(1:ix)//'NF'
          end if
          call pgmtxt ('B', ydispb, 0.5, 0.5, xlabel)
        end if
c
        if (labtyp(2).ne.'none' .and. 
     +      mod(jplot,nx).eq.1 .or. nx.eq.1) then
c 
c Write y-axis label and prepare options string for numeric labelling
c
          yyopts = yopts(1:iy)//'N'
          call pgmtxt ('L', xdispl, 0.5, 0.5, ylabel)
        end if
      else       
c
c Write x and y-axis labels and prepare option strings for numeric labelling
c
        if (labtyp(1).ne.'none') xxopts = xopts(1:ix)//'N'
        if (labtyp(2).ne.'none') yyopts = yopts(1:iy)//'N'
        call pgmtxt ('B', ydispb, 0.5, 0.5, xlabel)
        call pgmtxt ('L', xdispl, 0.5, 0.5, ylabel)
      end if
c
      end
c
c* boxCG -- Draw axes and optionally numerically label
c& nebk
c: plotting
c+
      subroutine boxcg (donum, xopts, yopts)
c
      implicit none
      logical donum
      character*(*) xopts, yopts
c
c  Draw axes and put ticks on.  Optionally write the numeric labels.
c
c  Input
c    donum     If true, this is the first time we have displayed this
c              image so we label with numbers frame and box.  Otherwise
c              we have erased the display and all we want to do is redraw
c              the frame and ticks.  The numbers will not have gone.
c    x,yopts   PGTBOX labelling options
c--
c-----------------------------------------------------------------------
      character*22 xxopts, yyopts
      integer idx
c-----------------------------------------------------------------------
      xxopts = xopts
      yyopts = yopts
c
      if (.not.donum) then
        idx = index (xopts, 'N')
        if (idx.ne.0) xxopts(idx:idx) = ' '
        idx = index (yopts, 'N')
        if (idx.ne.0) yyopts(idx:idx) = ' '
      end if
c
      call pgtbox (xxopts, 0.0, 0, yyopts, 0.0, 0)
c
      end
c
c* confmtCG -- Format contour levels
c& nebk
c: plotting
c+
      subroutine confmtcg (xpos, ypos, yinc, nlevs, srtlev, levs, slev, 
     +                     write, nlines)
c
      implicit none
      integer nlevs, nlines, srtlev(nlevs)
      real levs(nlevs), slev, xpos, ypos, yinc
      logical write
c
c  Format contour levels and optionally write to viewport
c
c Input:
c   xpos      c location to start writing contours levels 
c             in world coordinates
c   yinc      Increment in w.c. to step down image for each
c             line of contours
c   nlevs     NUmber of contour levels
c   srtlev    Array sorting levels into ascending order
c   levs      Levels
c   slev      Scale factor by which user given levels are scaled
c             to make numbers in levs
c   write     True if actually want to write levels to viewport
c Input/output
c   ypos      y location at which to write levels on viewport in
c             world coordiantes.  On exit is location for next
c             line of text
c Output:
c   nlines    Number of lines needed to write all levels
c
c--
c-----------------------------------------------------------------------
      real xw1, xw2, yw1, yw2, x1, y1, x2, y2, dx
      integer i1, i2, len1, k
      character str1*1000, str2*30
c-----------------------------------------------------------------------
      call pgqwin (xw1, xw2, yw1, yw2)      
      dx = abs(xw2 - xw1)
c
      nlines = 0
      str1 = ' Contours : '
      i1 = len1(str1) + 1
      k = 0
c
      do while (k.lt.nlevs)
c
c Format level
c
        k = k + 1
        call strfmtcg (levs(srtlev(k))/slev, 4, str2, i2)
c
        call pglen (4, str1(1:i1), x1, y1)
        call pglen (4, ' '//str2(1:i2)//',', x2, y2)
c
c See if space on current line for this level
c
        if (abs(x2)+abs(x1).le.dx) then
c
c Add level to line
c
          str1(i1+1:) = str2(1:i2)//', '
          i1 = len1(str1) + 1
c
c Write it out if last one
c
          if (k.eq.nlevs) then
            if (write) then
              call pgtext (xpos, ypos, str1(1:i1-2))
              ypos = ypos - yinc
            end if
            nlines = nlines + 1
          end if
        else
c
c No more space on this line, write it out if desired
c
          i1 = len1(str1)
          if (write) then
            call pgtext (xpos, ypos, str1(1:i1))
            ypos = ypos - yinc
          end if
          k = k - 1
c
          str1 = ' '
          i1 = 3
          nlines = nlines + 1
        end if
      end do
c
      end
c
c* conturCG -- Draw contour plot
c& nebk
c: plotting
c+
      subroutine conturcg (blank, solneg, win1, win2, dobl, 
     +                     data, nlevs, levs, tr, sdbreak)
c
      implicit none
      integer win1, win2, nlevs
      real data(win1,win2), levs(*), tr(6), sdbreak, blank
      logical solneg, dobl
c
c  Draw contours
c
c  Input:
c    blank    Vaue used for magic blanks
c    solneg   False => Positive contours solid, negative dashed.
c             True  => Positive contours dashed, negative solid.
c             "Positive" above means values >= SDBREAK
c    win1,2   Window sizes in x and y
c    dobl     True if blanks present in image section to contour
c    data     Image to contour
c    nlevs    Number of contour levels
c    levs     Contour levels
c    tr       Transformation matrix between array inices and
c             world coords
c    sdbreak  Value for distinction between solid and dashed contours
c--
c-----------------------------------------------------------------------
      integer stylehi, stylelo, i
c-----------------------------------------------------------------------
      if (.not.solneg) then
        stylehi = 1
        stylelo = 2
      else
        stylehi = 2
        stylelo = 1
      end if
c
      do i = 1, nlevs
        if (levs(i).ge.sdbreak) then
          call pgsls (stylehi)
        else
          call pgsls (stylelo)
        end if
        if (dobl) then
c
c This PG contouring routine does not do a very good job on dashed
c contours and is slower than PGCONT
c
           call pgconb (data, win1, win2, 1, win1, 1, win2, 
     +                  levs(i), -1, tr, blank)
        else
c
c Run faster contouring routine if no blanks
c
           call pgcont (data, win1, win2, 1, win1, 1, win2, 
     +                  levs(i), -1, tr)
          end if
      end do
      call pgsls (1)
c
      end
c
c* erswinCG -- Erase window from PGPLOT device
c& nebk
c: plotting
c+
      subroutine erswincg (xmin, xmax, ymin, ymax)
c
      implicit none
      real xmin, xmax, ymin, ymax
c
c  Erase the specified window from the PGPLOT device with 
c  rectangle fill
c
c  Input
c    x,ymin,max    Window in world coordinates
c--
c-----------------------------------------------------------------------
      integer ci, fs
c-----------------------------------------------------------------------
      call pgqci (ci)
      call pgqfs (fs)
c
      call pgsci (0)
      call pgsfs (1)
      call pgrect (xmin, xmax, ymin, ymax)
c
      call pgsci (ci)
      call pgsfs (fs)
c
      end
c
c* lab3CG -- Label sub-plot with value and/or pixel of 3rd axis
c& nebk
c: plotting
c+
      subroutine lab3cg (lun, doerase, doval, dopix, labtyp, ipl, plav)
c
      implicit none
      integer ipl, plav, lun
      logical doval, dopix, doerase
      character*6  labtyp(2)
c
c  Label the plot with the third axis values or pixel or both
c
c  Input
c    lun        Handle of image
c    doerase    .true. to erase the background behind the string
c    doval      .true. if writing value
c    dopix      .true. if writing pixel
c    labtyp     Axis label types
c    ipl        Start plane of image being plotted
c    plav       Number of planes being averaged for current sub-plot
c--
c----------------------------------------------------------------------
      double precision pix, val3
      real mx, my, x1, x2, y1, y2, xb(4), yb(4), dx, dy
      character str1*30, str2*30, str3*60, types(3)*4, ltype*6
      integer i1, i3, is2, ie2
c
      include 'maxnax.h'
      integer len1, naxis
      character*30 hangleh, rangle
      character*9 ctypes(maxnax)
c------------------------------------------------------------------------
      call rdhdi (lun, 'naxis', naxis, 0)
      if (naxis.lt.3) return
c
c Prepare pixel label
c
      if (plav.eq.1) then
        call pgnumb (ipl, 0, 0, str1, i1)
        pix = ipl
      else
        pix = (ipl+ipl+plav-1) / 2.0
        call strfmtcg (real(pix), 2, str1, i1)
      end if
c
c Prepare value label.  The units depend upon what type of axis the
c third axis is, and what the units of the complementary axis is
c
      call initco (lun)
      if (doval) then
        call ctypeco (lun, 3, 0, ctypes)
        call axtypcg (3, ctypes, types)
        if (types(3).eq.'VELO') then
          ltype = 'abskms'
        else if (types(3).eq.'FREQ') then
          ltype = 'absghz'
        else if (types(3).eq.'UV' .or. types(3).eq.'NONE') then
          ltype = 'abslin'
        else if (types(3).eq.'RA' .or. types(3).eq.'LONG') then
c  
c Look for DEC axis amongst first two and find label type to
c set label type for 3rd axis value
c
          if (types(1).eq.'DEC' .or. types(1).eq.'LATI') then
            ltype = 'hms'
            if (labtyp(1).eq.'arcsec' .or. labtyp(1)(4:6).eq.'deg')
     +         ltype = labtyp(1)
          else if (types(2).eq.'DEC' .or. types(2).eq.'LATI') then
            ltype = 'hms'
            if (labtyp(2).eq.'arcsec' .or. labtyp(2)(4:6).eq.'deg')
     +         ltype = labtyp(2)
          end if
        else if (types(3).eq.'DEC' .or. types(3).eq.'LATI') then
c  
c Look for RA axis amongst first two and find label type to
c set label type for 3rd axis value
c
          if (types(1).eq.'RA' .or. types(1).eq.'LONG') then
            ltype = 'dms'
            if (labtyp(1).eq.'arcsec' .or. labtyp(1)(4:6).eq.'deg')
     +         ltype = labtyp(1)
          else if (types(2).eq.'RA' .or. types(2).eq.'LONG') then
            ltype = 'dms'
            if (labtyp(2).eq.'arcsec' .or. labtyp(2)(4:6).eq.'deg')
     +         ltype = labtyp(2)
          end if
        end if
c
c Now compute the value of the third axis in the desired units
c and format it
c 
        call w2wsco (lun, 3, 'abspix', ' ', pix, ltype, ' ', val3)
        call finco (lun)
c
c Format value
c
        if (ltype.eq.'hms') then
          str2 = hangleh(val3)
        else if (ltype.eq.'dms') then
          str2 = rangle(val3)
        else 

c_lss_s
          if (val3.lt.100.0) then
             call strfmtcg (real(val3), 2, str2, ie2)
          else if (val3.lt.1000.0) then
             call strfmtcg (real(val3), 3, str2, ie2)
          else
             call strfmtcg (real(val3), 6, str2, ie2)
          end if
c_lss_e

        end if  
        ie2 = len1(str2)
        is2 = 1
        do while (str2(is2:is2).eq.' ' .and. is2.le.ie2)
          is2 = is2 + 1
        end do
      end if
c
c Concatenate strings
c
      if (doval .and. dopix) then
        str3 = str2(is2:ie2)//', '//str1(1:i1)
      else if (doval) then
        str3 = str2(is2:ie2)
      else if (dopix) then
        str3 = str1(1:i1)
      end if
      i3 = len1(str3)
c
c Work out world coordinate of string BLC; 1 char in & 2 char down
c
      call pgqwin (x1, x2, y1, y2)
      call pgqtxt (0.0, 0.0, 0.0, 0.0, 'X', xb, yb)
      dx = (xb(4) - xb(1))
      call pgqtxt (0.0, 0.0, 0.0, 0.0, str3(1:i3), xb, yb)
      dy = (yb(2) - yb(1))
c       
      mx = x1 + dx
      my = y2 - 2.0*dy
c
c Erase rectangle and write string
c
      call strerscg (doerase, 0.0, str3(1:i3), mx, my)
c
      end
c
c
c* setlabCG -- Set label options strings and axis displacements
c& nebk
c: plotting
c+
      subroutine setlabcg (labtyp, ymin, ymax, xdispl, ydispb, 
     +                     xopts, yopts)
c
      implicit none
      character labtyp(*)*(*), xopts*(*), yopts*(*)
      real xdispl, ydispb, ymin, ymax
c
c  Set the labelling displacements from the relevant axes, and set 
c  PGTBOX labelling options strings.
c
c  Input
c    labtyp   Label type requested by user
c    ymin,max y axis min and max
c  Output
c    xdispl   Displacement in character heights from left y-axis 
c             for Y label
c    ydispb   Displacement in character heights from bottom x-axis 
c             for X label
c    x,yopts  PGTBOX options string, include 'Z' for time labelling
c--
c-------------------------------------------------------------------------------
      real dely, xch, ych, xl, yl, xd
      character str*60
      integer len1, il
c-----------------------------------------------------------------------
c
c X axis
c
      if (labtyp(1).eq.'hms') then
        ydispb = 3.6
        xopts = 'BCSTHYZO'
      else if (labtyp(1).eq.'dms') then
        ydispb = 3.6
        xopts = 'BCSTDYZO'
      else if (labtyp(1).eq.'none') then
        ydispb = 3.6
        xopts = 'BC'
      else
        ydispb = 3.1
        xopts = 'BCST'
      end if
c
c Y axis.  Have a stab at a correct axis label displacement when using
c HMS or DMS; it depends upon the number of decimal places in the 
c labels and knowing about the PGTBOX algorithm.  Very modular.
c Allow for space between numeric label and axis, and between
c numeric label and axis label.

      dely = abs(ymax - ymin)
      if (dely.le.5*60) then
        if (dely/6.0.lt.0.01) then
          str = '1O05\uh\d05\um\d05\us\d.555O'
        else if (dely/6.0.lt.0.1) then
          str = '1O05\uh\d05\um\d05\us\d.55O'
        else if (dely/6.0.lt.1.0) then
          str = '1O05\uh\d05\um\d05\us\d.5O'
        else
          str = '1O05\uh\d05\um\d05\us\dO'
        end if
      else if (dely.le.5*3600) then
        str = '1O05\uh\d05\um\dO'
      else 
        str = '1O05\uh\dO'
      end if
      il = len1(str)
      if (ymin.lt.0.0 .or. ymax.lt.0.0) then
        str(il+1:il+1) = '-'
        il = len1(str)
      end if
c
c Find the length of this string in mm and convert to
c displacement to left of axis for vertical axis label
c
      call pglen (2, str(1:il), xl, yl)
      call pgqcs (2, xch, ych) 
      xd = xl / xch
c
      if (labtyp(2).eq.'hms') then
        xdispl = xd
        yopts = 'BCSTHYZV'
      else if (labtyp(2).eq.'dms') then
        xdispl = xd
        yopts = 'BCSTDYZV'
      else if (labtyp(2).eq.'none') then
        xdispl = 1.0
        yopts = 'BC'
      else
        xdispl = 2.5
        yopts = 'BCST' 
      end if
c
      end
c
c* strersCG -- Optionally erase a rectangle on the view-port & write a string in it
c& nebk
c: plotting
c+
      subroutine strerscg (doerase, just, string, x, y)
c
      implicit none
      real x, y, just
      character string*(*)
      logical doerase
c
c  Optionally erase a snugly fitting rectangle and write a string to the
c  view-port into it
c
c  Input
c    doerase     Erase rectangle behind string if true.
c    just        Horizontal string justification.  
c                     0.0 -> left just
c                     0.5 -> centred
c                     1.0 -> right just
c    string      String to write
c    x,y         World coordinates of BLC of string
c--
c-----------------------------------------------------------------------
      integer len1, tbg
c-----------------------------------------------------------------------
      call pgqtbg (tbg)
      if (doerase) call pgstbg (0)
      call pgptxt (x, y, 0.0, just, string(1:len1(string)))
      call pgstbg (tbg)
c
      end
c
c* strfmtcg -- Format a number with PGNUMB
c& nebk
c: plotting
c+
      subroutine strfmtcg (xnum, ns, str, is)
c
      implicit none
      real xnum
      integer ns, is
      character*(*) str
c
c  Format a number with a specified number of significant figures with
c  the pgplot routine pgnumb. It chooses automatically decimal or
c  exponential notation.  Pgplot superscripting escape sequences
c  may be embedded in the string in the latter case.
c
c  Input:
c    xnum    The number = mm * 10**pp
c    ns      Number of desired signifcant figures
c  Output:
c    str     Formatted string
c    is      Length of string
c--
c-----------------------------------------------------------------------
      integer mm, pp
c-----------------------------------------------------------------------
      if (xnum.ne.0.0) then
        pp = int(log10(abs(xnum))) - ns
        mm = nint(xnum/10.0**pp)
      else
        mm = 0
        pp = 1
      end if
c
      call pgnumb (mm, pp, 0, str, is)
c
      end
c
c* vpadjCG -- Adjust viewport if equal scales requested
c& nebk
c: plotting
c+
      subroutine vpadjcg (hard, eqscale, scale, vxmin, vymin, vymax,
     +   nx, ny, blc, trc, naxis, crval, crpix, cdelt, ctype, tfvp,
     +   wdgvp, vxsize, vysize)
c
      implicit none
      integer nx, ny, blc(*), trc(*), naxis
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      real vxsize, vysize, vxmin, vymin, vymax, scale(2), tfvp(4),
     +  wdgvp(4)
      logical eqscale
      character hard*(*), ctype(naxis)*(*)
c
c  So far everything has been worked out for unequal scales in
c  x and y.  If the user requests equal scales, or gives the scales,
c  we need to make some adjustments to the viewport
c
c  Inputs
c    hard         YES for hardcopy device
c    eqscale      True means equals scale requested, else different 
c    nx,ny        Number of sub-plots in x and y
c    blc,trc      Window in pixels
c    cdelt        Array of pixel increments
c  Input/Output
c    scale        scales in x and y in linear axis units/mm
c                 RA axes are radians on the sky per mm
c    vxmin        Left hand side of encompassing view port
c    vymin,vymax  Bottom and top of encompassing view port
c    tfvp         Transfer function fiddle plot viewport. SHould be all zero
c                 if no fiddling.
c    wdgvp        Wedge viewport.  All zero fo no wedge
c    vxsize       Size of viewport for sub-plots in normalized device 
c    vysize       coordinates
c--
c-----------------------------------------------------------------------
      double precision x1, x2, y1, y2, delx, dely, cosdec, xfac, yfac,
     +  xscale, yscale, xscale0, yscale0
      real vx1, vx2, vy1, vy2, vxmore, vymore, vxsize2, vysize2
      character aline*72, type*6
      logical ok, cdok(2), dofid, dowedge
      integer i
c-----------------------------------------------------------------------
c
c Since each axis type may be different convert window to "abslin"
c coordinates to work out equal scales
c
      type = 'abslin'
      call pix2wcg (.false., dble(blc(1)-0.5), 1, type, naxis, crval, 
     +              crpix, cdelt, ctype, x1, ok)
      call pix2wcg (.false., dble(trc(1)+0.5), 1, type, naxis, crval, 
     +              crpix, cdelt, ctype, x2, ok)
      call pix2wcg (.false., dble(blc(2)-0.5), 2, type, naxis, crval, 
     +              crpix, cdelt, ctype, y1, ok)
      call pix2wcg (.false., dble(trc(2)+0.5), 2, type, naxis, crval,
     +              crpix, cdelt, ctype, y2, ok)
c
c For RA/DEC axes, we want the scale equal on the sky, so we
c must take a cos(DEC) term into account
c
      call cosdeccg (1, naxis, ctype, crval, cosdec, cdok(1))
      delx = abs(x2 - x1)
      if (cdok(1)) delx = delx * cosdec
c
      call cosdeccg (2, naxis, ctype, crval, cosdec, cdok(2))
      dely = abs(y2 - y1)
      if (cdok(2)) dely = dely * cosdec
c
      if (.not.cdok(1) .or. .not.cdok(2)) then
        call bug ('w', 
     +    'VPADJCG: Cannot correctly work out scale for RA axis')
        call bug ('w', 
     +    'VPADJCG: because DEC axis missing; image may be squashed')
      end if
c
c Find width of viewport for each subplot in mm and compute scales
c in world coordinates per mm for image optimally filling the viewport.
c
      call pgsvp (0.0, vxsize, 0.0, vysize)
      call pgqvp (2, vx1, vx2, vy1, vy2)
      xscale0 = delx / (vx2 - vx1)
      yscale0 = dely / (vy2 - vy1)
c
c Now set scales actually used, allowing for user given scales,
c or unequal default scales
c
      if (scale(1).ne.0.0 .or. scale(2).ne.0.0) then
c
c Over-ride user given scales if too small to fit image on viewport
c
        if (scale(1).gt.xscale0) then
          xscale = scale(1) 
        else 
          xscale = xscale0
          if (scale(1).ne.0.0) call bug ('w', 
     +        'VPADJCG: User x-scale too small, will self-scale')
        end if
c
        if (scale(2).gt.yscale0) then
          yscale = scale(2)
        else 
          yscale = yscale0
          if (scale(2).ne.0.0) 
     +    call bug ('w', 
     +              'VPADJCG: User y-scale too small, will self-scale')
        end if
c
c Adjust for equal scales if required
c
        if (eqscale) then
          if (xscale.ne.yscale) call bug ('w', 
     +     'VPADJCG: Use options=unequal to honour different '//
     +     'values for keyword "scale"')
c
          xscale = max(xscale,yscale)
          yscale = xscale
        end if
      else
c
c Using defualt scales; adjust for equal scales if required
c
        if (eqscale) then
          xscale = max(xscale0,yscale0)
          yscale = xscale
        else
          xscale = xscale0
          yscale = yscale0
        end if
      end if
c
c Set factor by which we multiply subplot viewport size to
c allow for scake changes
c
      xfac = xscale0 / xscale
      yfac = yscale0 / yscale
c
c Tell user about scales, regardless of equality
c
      if (hard.eq.'YES') then
         write (aline, 100) xscale, yscale
100      format ('Linear x and y scales per mm = ', 
     +           1pe12.6, ', ', 1pe12.6)
         call output (aline)
      end if
c
c Adjust viewports for equal scales or user given scales
c
      if (eqscale .or. scale(1).ne.0.0 .or. scale(2).ne.0.0) then
c
c Set new sub-plot viewport sizes if required
c    
        vxsize2 = vxsize * xfac
        vysize2 = vysize * yfac
c
c Now because we may have made one or both of the subplot viewport 
c dimensions smaller, adjust the encompassing viewport so that the 
c sub-plots are still symmetrically placed on the viewsurface.  
c
        vxmore = nx * (vxsize - vxsize2)
        vxmin = vxmin + vxmore / 2.0
c
        vymore = ny * (vysize - vysize2)
        vymin = vymin + vymore / 2.0
        vymax = vymax - vymore / 2.0
c
c Set new sub-plot sizes
c
        vxsize = vxsize2
        vysize = vysize2
c
c Make sure we shift the transfer function fiddling plot 
c and wedge viewports too
c
        dofid = .false.
        dowedge = .false.
        do i = 1, 4
          if (tfvp(i).ne.0.0) dofid = .true.
          if (wdgvp(i).ne.0.0) dowedge = .true.
        end do
        if (dofid) then
          tfvp(1) = tfvp(1) - vxmore / 2.0
          tfvp(3) = tfvp(3) - vxmore / 2.0
          tfvp(2) = tfvp(2) + vymore / 2.0
          tfvp(4) = tfvp(4) + vymore / 2.0
        end if
        if (dowedge) then
          wdgvp(1) = wdgvp(1) - vxmore / 2.0
          wdgvp(3) = wdgvp(3) - vxmore / 2.0
          wdgvp(2) = wdgvp(2) + vymore / 2.0
          wdgvp(4) = wdgvp(4) - vymore / 2.0
        end if
      end if
c
c Return actual scales used
c
      scale(1) = xscale
      scale(2) = yscale
c
      end
c
c
c* vpsizCG -- Set encompassing viewport and subplot increment sizes
c& nebk
c: plotting
c+
      subroutine vpsizcg (dofull, dofid, ncon, gin, vin, nspec, bin, 
     +  maxlev, nlevs, srtlev, levs, slev, nx, ny, pcs, xdispl, 
     +  ydispb, gaps, wedcod, wedwid, wedisp, tfdisp, labtyp, vxmin, 
     +  vymin, vymax, vxgap, vygap, vxsize, vysize, tfvp, wdgvp)
c
      implicit none
      integer maxlev, nlevs(*), srtlev(maxlev,*), nx, ny, ncon, 
     +  wedcod, nspec
      real vxmin, vymin, vymax, vxgap, vygap, vxsize, vysize, pcs,
     +  ydispb, xdispl,  wedwid, wedisp, tfvp(4), tfdisp, wdgvp(4),
     +  levs(maxlev,*), slev
      logical dofid, dofull, gaps
      character*(*) gin, vin, bin, labtyp(2)*(*)
c
c   Work out view port that encompasses all sub-plots and allows
c   for all labelling below it.   Assume unequal scales in x and y 
c   here.  If user wants equal scales, adjust later.
c
c   Input
c     dofull      True for full plot annotation (contour levels etc)
c     dofid       True for interactive fiddle
c     ncon        Number of contour images
c     *in         Grey, vector and box type image names
c     nspec       Number of spectrum images
c     maxlevs     Maximum number of cintour levels per image
c     nlevs       Number of contour levels for each image
c     srtlev      Array to sort contours in increasing order
c     levs        Contour levels for each image
c     slev        Scale factor by which user given levels are scaled
c                 resulting in the numbers stored in levs
c     nx,ny       Number of sub-plots in x and y 
c     pcs         PGPLOT character size for plot labels
c     xdispl      Displacement of y-axis label from axis in char hghts
c     ydispb      Displacement of x-axis label from axis in char hghts
c     gaps        If true then don't leave gaps between sub-plots else
c                 leave gaps between sub-plots & label each window
c     wedcod      1 -> one wedge to right of all subplots
c                 2 -> one wedge to right per subplot
c                 3 -> one wedge per subplot inside subplot
c     wedwid      Fraction of full viewport for wedge width (wedcod=1)
c     wedisp      Displacement of wedge from right axis in char heights
c     tfdisp      Displacement of transfer function plot from right 
c                 axis in char heights
c     labtyp      Axis labels
c   Output
c     vxmin       X-min of viewport window in normalized device coords
c     vymin,vymax Y viewport range. Viewport encompasses all sub-plots
c     vx,ygap     Leave a gap between sub-plots in ndc in x and y
c     vx,ysize    Size of viewport of each sub-plot in ndcs in x & y
c     tfvp        Viewport coords in which to draw interactive fiddle plot
c     wdgvp       Viewport for wedge if wedcod = 1.  Other wedge type 
c                 viewports are worked out when the wedge is drawn in 
c---------------------------------------------------------------------------
c
c Fraction of viewsurface to use for interactive fiddle plot
c
      real tfvps
      parameter (tfvps = 0.1)
c
      real xht, yht, xhta, yhta, acs, ychinc, annlines, vxmax, dvwx,
     +  dvtx, dvwd, ygap, asp, dvtfx, dvtfy, dvtd, dvwl, xpos, ypos, 
     +  yinc
      integer nlines, i
      logical dowedge
c---------------------------------------------------------------------------
c
c Work out character height in n.d.c. for plot labels
c
      call pgsch (pcs)
      call pgqcs (0, xht, yht)
c
c Set viewport that encompasses all sub-plots in n.d.c.
c
      vxmin = (xdispl + 1.2)*xht
      vymax = 1.0 - yht
c
c Work out wedge spaces
c
      do i = 1, 4
        wdgvp(i) = 0.0
      end do
      dvwx = 0.0
      dowedge = wedcod.eq.1 .or. wedcod.eq.2
      if (dowedge) then
c
c Width of wedge label area and displacement from right hand 
c edge of subplot in ndc
c
        dvwl = 2.0 * xht
        dvwd  = wedisp * xht
c
c Total width taken up by wedge in ndc
c
        dvwx = wedwid + dvwl + dvwd
      end if
c
c Work out transfer function plot spaces
c
      do i = 1, 4
        tfvp(i) = 0.0
      end do
      dvtx = 0.0
      if (dofid) then
c
c We want the fiddle plot to be square on the screen so 
c find the width and height in ndc accordingly
c
        asp = yht / xht
        if (asp.ge.1.0) then
          dvtfx = tfvps / asp
          dvtfy = tfvps
        else
          dvtfx = tfvps 
          dvtfy = tfvps * asp
        end if
c
c x displacement of plot from edge of viewport
c
        dvtd  = tfdisp * xht
c
        dvtx = dvtfx + dvtd
      end if
c
c Set x trc of image viewport
c
      vxmax = 1.0 - max(dvwx,dvtx) - xht
c
c When doing full annotation need to make space at bottom of plot. Allow 
c for x axis label, gap between it and start of text, lines of text, and 
c space between lines of text.
c
      if (dofull) then
        annlines = 0.0
        if (gin.ne. ' ') annlines = annlines + 1.0
        if (vin.ne.' ')  annlines = annlines + 1.0
        if (bin.ne.' ')  annlines = annlines + 1.0
        if (nspec.gt.0)  annlines = annlines + 1.0
c
c Define annotation character size and set it 
c
        call anndefcg (acs, ychinc, ygap)
        call pgsch (acs)
c
        if (ncon.gt.0) then
c
c Find number of lines for contours; set viewport for x direction
c xpos etc dummies as we won't actually plot anything here
c
          call pgsvp (vxmin, vxmax, 0.0, 1.0)
          call pgswin (0.0, 1.0, 0.0, 1.0)
          xpos = 0.0
          ypos = 0.0
          yinc = 0.0
          do i = 1, ncon 
            call confmtcg (xpos, ypos, yinc, nlevs(i), srtlev(1,i), 
     +                     levs(1,i), slev, .false., nlines)
            annlines = annlines + nlines + 1.0
          end do
        end if
c
c Need lines for reference values and window as well.  Window is written
c last and has dangling letters in its line, so allow extra 0.5 character
c heights for that too.
c
        annlines = annlines + 2.5
c
c Allow some extra space for the x-label annotation and a gap
c between it and the additional annotation.  This is not very
c modular, and these numbers must match those in ANNINICG
c
        call pgqcs (0, xhta, yhta)
        if (labtyp(1).ne.'none') then
          vymin = (ydispb*yht) + ((annlines*ychinc)+ygap)*yhta
        else
          vymin = ((annlines*ychinc)+ygap)*yhta
        end if
      else
        vymin = (ydispb + 0.5) * yht
      end if
c
c Now allow for the transfer function fiddle plot if necessary.  It sits
c below the viewport and to the right.  Any full plot annotation will 
c reuse its space.  Set transfer function plot viewport
c
      if (dofid) then
        vymin = max(vymin,dvtfy+yht)
c
        tfvp(1) = vxmax + dvtd
        tfvp(2) = vymin - dvtfy - 0.75*yht
        tfvp(3) = tfvp(1) + dvtfx
        tfvp(4) = tfvp(2) + dvtfy
      end if
c
c Set wedge viewport
c
      if (dowedge) then
        wdgvp(1) = vxmax + dvwd
        wdgvp(2) = vymin
        wdgvp(3) = wdgvp(1) + wedwid
        wdgvp(4) = vymax
      end if
c
c Work out size of sub-plots and gaps between in n.d.c. For gap allow
c for label displacement plus 2 extra characters worth of space
c
      if (nx.gt.1) then
        if (gaps) then
          vxgap = (1.0 + xdispl + 2.0) * xht
        else
          vxgap = 0.0
        end if
        vxsize = ((vxmax - vxmin) - ((nx - 1) * vxgap)) / nx
      else
        vxgap = 0.0
        vxsize = vxmax - vxmin
      end if
c
      if (ny.gt.1) then
        if (gaps) then
          vygap = (ydispb + 2.0) * yht
        else
          vygap = 0.0
        end if
        vysize = ((vymax - vymin) - ((ny - 1) * vygap)) / ny
      else
        vygap = 0.0
        vysize = vymax - vymin
      end if
c
      end
c
c
c* wedgCG -- Draw pixel map wedge in specified viewport
c& nebk
c: plotting
c+
      subroutine wedgcg (label, trfun, groff, nbins, cumhis, wdgvp, 
     +                   a1, a2)
c
      implicit none
      integer nbins
      real wdgvp(4), a1, a2, groff, cumhis(nbins)
      character trfun*3
      logical label
c
c Draw a vertical grey-scale wedge in the specified viewport
c
c Input
c  label  True means label wedge to right else none
c  trfun  Transfer function type applied to image.  One of 'lin',
c         'log', 'heq' or 'sqr'
c  groff  Offset added to image for log and sqrt transfer functions
c  nbins  Number of bins used in histogram equalization of image
c  cumhis Cumulative histogram for histogram equalization
c         Values for each bin are the intensities assigned to   
c         the image.  Thus if an image pixel ended up in
c         cumhis bin idx, then its new value is cumhis(idx)
c  wdgvp  Viewport to draw wedge in
c  a1     The value which is to appear with shade C1
c  a2     The value which is to appear with shade C2
c         Use the values of A1 and A2 that were sent to PGIMAG.
c         These values should be those appropriate to before any
c         application of transfer functions (log etc) and adding of
c         offsets (GROFF)
c
c
c--
c-----------------------------------------------------------------------
      include 'maxdim.h'
      include 'mem.h'
      real wx1, wx2, wy1, wy2, vx1s, vx2s, vy1s, vy2s, wdginc, tr(6), 
     +  b1, b2
      integer i, ipw, nbins2
c
      save tr
      data tr /0.0, 1.0, 0.0, 0.0, 0.0, 1.0/
c-----------------------------------------------------------------------
c
c Allocate memory for wedge
c
      nbins2 = nbins
      if (trfun.ne.'heq') nbins2 = 128
      call memalloc (ipw, nbins2, 'r')
c
c Store the current world and viewport coords and the character height.
c
      call pgqwin (wx1, wx2, wy1, wy2)
      call pgqvp (0, vx1s, vx2s, vy1s, vy2s)
c
c Create a dummy wedge array to be plotted.
c
      if (trfun.eq.'log') then
        b1 = log10(a1+groff)
        b2 = log10(a2+groff)
      else if (trfun.eq.'sqr') then
        b1 = sqrt(a1+groff)
        b2 = sqrt(a2+groff)
      else if (trfun.eq.'heq') then
        b1 = cumhis(1)
        b2 = cumhis(nbins2)
      else
        b1 = a1
        b2 = a2
      end if
c
c Generate wedge with correct transfer function applied
c
      if (trfun.eq.'heq') then
c
c Make it from histogram returned by HEQCG
c
        do i = 1, nbins2
          memr(ipw+i-1) = cumhis(i)
        end do
      else
c
c Generate linear wedge
c
        wdginc = (a2-a1) / (nbins2-1)
        do i = 1, nbins2
          memr(ipw+i-1) = a1 + (i-1) * wdginc
c
c Apply transfer function
c
          if (trfun.eq.'log') then
            memr(ipw+i-1) = log10(memr(ipw+i-1)+groff)
          else if (trfun.eq.'sqr') then
            memr(ipw+i-1) = sqrt(memr(ipw+i-1)+groff)
          end if
        end do
      end if
c
c Draw the wedge and label
c
      call pgsvp (wdgvp(1), wdgvp(3), wdgvp(2), wdgvp(4))
      call pgswin (0.9, 1.1, 1.0, real(nbins2))
      call pgimag (memr(ipw), 1, nbins2, 1, 1, 1, nbins2, 
     +             b1, b2, tr)
      call pgswin (0.0, 1.0, a1, a2)
      if (label) then
c
c Label box to right
c
        call pgbox('BC', 0.0, 0, 'BCMST', 0.0, 0)
      else 
c
c No labels.
c
        call pgbox('BC', 0.0, 0, 'BCST', 0.0, 0)
      end if
c
c Restore the original viewport and world coordinates.
c
      call pgsvp (vx1s, vx2s, vy1s, vy2s)
      call pgswin (wx1, wx2, wy1, wy2)
      call pgupdt
c
c Free up memory
c
      call memalloc (ipw, nbins2, 'r')
c
      end
c
c* wedgeCG -- Decide if it is time to draw a wedge and do so if so
c& nebk
c: plotting
c+
      subroutine wedgecg (wedcod, wedwid, jj, trfun, groff, nbins,
     +                    cumhis, wdgvp, a1, a2)
c
      implicit none
      real groff, cumhis(*), wdgvp(4), a1, a2, wedwid
      integer wedcod, jj, nbins
      character trfun*3
c
c Work out whether the pixel map wedges are to be drawn inside
c or outside the subplots, and whether there will be one or many
c  
c Input
c  wedcod 1 -> one wedge to right of all subplots
c         2 -> one wedge to right per subplot
c         3 -> one wedge per subplot inside subplot
c  wedwid Fraction of subplot viewport for wedge (wedcod=2,3)
c  jj     Number of subplot on this page
c  trfun  Transfer function type applied to image.  
c  groff  Offset added to image for log and sqrt transfer functions
c  nbins  Number of bins used in histogram equalization of image
c  cumhis Cumulative histogram for histogram equalization returned
c         by HEQCG
c  wdgvp  Viewport to draw wedge in (wedcod=1)
c  a1,a2  pixel map max and min
c         Use the values of A1 and A2 that were sent to PGGRAY.
c         These values should be those appropriate to before 
c         any application of transfer functions (log etc) and 
c         adding of offsets
c  nx,ny  Number of subplots in x and y directions
c  npixr  NUmber of pixel map "range" groups given by user
c  trfun  Transfer function type of first "range" group
c--
c-----------------------------------------------------------------------
      real vx1, vx2, vy1, vy2, wv(4), xht, yht, wedfrc
c-----------------------------------------------------------------------
      call pgqvp (0, vx1, vx2, vy1, vy2)
      call pgqcs (0, xht, yht)
      wedfrc = wedwid * (vx2 - vx1)
c
      if (wedcod.eq.1) then
        if (jj.eq.1) then
          call wedgcg (.true., trfun, groff, nbins, cumhis, 
     +                 wdgvp, a1, a2)
        end if
      else if (wedcod.eq.2) then
        wv(1) = vx2 + 1.0*xht
        wv(2) = vy1
        wv(3) = wv(1) + wedfrc
        wv(4) = vy2
        call wedgcg (.true., trfun, groff, nbins, cumhis, 
     +               wv, a1, a2)
      else
        wv(1) = vx2 - wedfrc
        wv(2) = vy1
        wv(3) = vx2
        wv(4) = vy2
        call wedgcg (.false., trfun, groff, nbins, cumhis, 
     +               wv, a1, a2)
      end if
c
      end
c
c* yhtwCG -- Find height of one character in world coordinates
c& nebk
c: plotting
c+
      subroutine yhtwcg (yht)
c
      implicit none
      real yht
c
c  Find the height, in world coordinates, of one character
c  with the current PGPLOT character size active
c
c  Output:
c    yht     Height in world coordinates of one character
c--
c-----------------------------------------------------------------------
      real xch, ych, vpx1, vpx2, vpy1, vpy2, wx1, wx2, wy1, wy2
c-----------------------------------------------------------------------
c
c Find current height of one character in normalized device coordinates
c
      call pgqcs (0, xch, ych)
c
c Find current view-port in ndc
c
      call pgqvp (0, vpx1, vpx2, vpy1, vpy2)
c
c Find current window in world coordinates
c
      call pgqwin (wx1, wx2, wy1, wy2)
c
c Convert height from ndc to world coordinates
c
      yht = abs((wy2-wy1) * ych / (vpy2-vpy1))
c
      end


c**********************************************************************
c     A collection of subroutines shared by the programs CGDISP,
c     CGSPEC, CGCURS, CGSLICE, REGRID, IMBIN and UVSUB. 
c
c
c  apptrfcg :  Apply transfer function to image
c  axabscg  :  Return an "abs" axis label type for given generic axis type
c  axfndcg  :  Find a generic axis type
c  axtypcg  :  Returns generic axis label type of given axis
c  chkdescg :  COmpare a real axis descriptor from two images
c  chkdimcg :  Check image dimensions acceptable
c  chnselcg :  Make list of CHAN and REGION selected channel groups
c  conlevcg :  Compute contour levels
c  copyimcg :  Copy image
c  cosdeccg :  Find cos(DEC) for  RA axis
c  defchrcg :  Give a default char. height for axis & velocity labels
c  grfixcg  :  Fix up a grey scale range (includes log taking)
c  hedinfcg :  Get some header information from image
c  heqcg    :  Histogram equalize an image
c  limitscg :  Work out limits and transformation matrix for both axes
c  limtrcg  :  Work out limits and transformation matrix for one axis
c  maskorcg :  OR mask of mask image with mask of data image
c  matchcg  :  Match string with allowed types
c  nxnycg   :  Work out number of sub-plots per page
c  opimcg   :  Open an image and return axis descriptors
c  optcg    :  Version of BobS options, but without the fatalities
c  ol2pixcg :  Convert overlay location in specified coords to pixels
c  pix2wcg  :  Convert from image pixels to world coord of requested type
c  pix2wfcg :  Convert from image pixels to world coord of requested type
c              and format in string
c  pixi2wcg :  Find pixel increment in world coordinates
c  ppconcg  :  Convert between unbinned full image pixels and binned
c              subimage pixels
c  readbcg  :  Read blanking mask form mask image
c  readimcg :  Read in image dealing with averaging and blanking
c  savdescg :  Make a copy of the axis descriptors
c  setcolcg :  Set a PGPLOT colour for multiple line graphics on 1 plot
c  setdescg :  Set axis descriptors for an image by copying from another
c  strprpcg :  Prepare string by stripping extra white space and
c              delimitering fields by commas
c  subinccg :  Step to next sub-plot
c  sunitcg  :  Set pixel units base upon requested label type
c  wedgincg :  Work out if greys cale wedges inside ro outside subplots
c  windfidcg:  Adjust window size to fit an integral number of bins
c  w2pixcg  :  Convert from world coord of given type to image pixels
c  w2wcg    :  Convert between world coord types
c  w2wfcg   :  Convert between world coord types and format
c
c  History:
c     nebk   20sep91     Created from PGDISP/PGCURS
c     nebk   08nov91     Use local blc,trc in call to BOXRUNS in
c                        CHNSELPG, because they may get modified
c                        if blanked pixels exist
c     nebk   28apr92     "g" format seems to behave capriciously
c                        Try to do something better in VCLABPG
c                        Renamed subroutines to *cg from *pg 
c                        as pgdisp etc -> cgdisp etc
c     nebk   12may92     Return actual scales in VPADJCG
c     nebk   14may92     Add  LIMTRCG. Add a couple more
c                        parameters to HEDINFCG
c     nebk   18may92     Add AXFNDCG
c     nebk   04jul92     Don't modify variable (PLAV) in READIMCG. Add
c                        O2PIXCG, SETTRCG, CONLINCG, STRERSCG, DEGHSMCG,
c			 ANN*CG, CHKDESCG, CHKDIMCG,  add argument 
c			 MIRROR to CONLEVCG 
c     nebk   08jul82     Add OPTCG and INIT/NORM to READIMCG call. FIx 
c                        bug in CHNSELCG causing groups to be redundantly
c                        specified under some circumstances
c     nebk   14jul92     Add POSOFF to O2PIXCG. Type CDELT and CRVAL
c			 as DOUBLE PRECISION
c     nebk   07aug92     Try to instill some more modularity into all 
c                        coordinate conversions with PIX2WCG and
c                        W2PIXCG, removing SETTRCG along the way.
c     nebk   22oct92     Add units to velocity and frequency axes 
c			 in LIMTRCG.  SETLABCG was not correctly 
c                        setting the dms,hms PGTBOX strings.
c     nebk   28nov92     Add 'abs/relkms' and 'abs/relghz' label types
c                        Change "linear" to "abslin"
c     nebk   02dec92     Add pix2wfcg, sunitcg
c     nebk   24dec92     Split cgpgsubs.for off.
c     rjs    04jan93     Make def. args in rdhdd double in HEDINFCG
c     nebk   27feb93     Earn brownie points with Mr. T by reformatting
c                        subroutine call sequence variables.
c     nebk   21apr93     Add AXTYPCG
c     nebk   27may93     Add 0.5 pixel to blc,trc in LIMTRCG so that
c                        image edges are at n.5,m.5 not n,m
c     nebk   29may93     Remove CHTONVCG as now there is PGQCS 
c     nebk   02jun93     Move ANNDEFCG, VPASPCG and VPADJCG to 
c                        CGPGSUBS.FOR as they now call PGQVSZ
c     nebk   22jun93     Change PIX2WCG, W2PIXCG, LIMTRCG for RA axes to
c			 return abslin/rellin in rads of polar rotation
c                        Add COSDECCG and use it.
c     nebk   05jul93     MAXDIM-> MAXNAX in W2PIXCG.  Whoops !
c     nebk   25aug93     Remove DEGHMSCG in favour of new DANGLEH
c			 Add "absdeg" and "reldeg" axis label types
c                        Add PIXI2WCG.   Add DOEPOCH to LIMTRCG
c     nebk   15sep93     Format change in OPTCG
c     nebk   14nov93     Add 'O' to x-axis options for PGTBOX in SETLAB
c                        Add labtyp=none
c     nebk   07dec93     Add 'V' to y-axis for new PGTBOX in SETLABCG &
c                        modify slightly blanking in READIMCG & TAKLOGCG
c     nebk   10dec93     Add MASKORCG and READBCG
c     nebk   14dec93     Add AXABSCG and LIMITSCG
c     nebk   03jan94     Add new argument to OMATCHCG and rename MATCHCG
c		         Add SETCOLCG
c     nebk   09jan94     Convert CRPIX -> double precision. 
c			 Add W2WCG, W2WFCG
c     nebk   27jan94     Add square root transfer function to GRFIXCG
c                        Rename TAKLOG to APPTRF and include h.e., log,
c			 and square root transfer functions. Add HEQCG
c     nebk   15feb94     Add WEDGINCG and WEDGECG
c     nebk   02mar94     SETLABCG -> cgpgsubs.for
c     nebk   08mar94     Move WEDGECG to CGPGSUBS.FOR, add WINDFIDCG
c                        Implement spatial binning in READBCG, READIMCG,
c                        LIMITSCG and LIMTRCG. Add COPYIMCG, PPCONCG
c     nebk   09jun94     Recognize UU and VV image axes
c     nebk   21jun94     Add OPIMCG 
c     nebk   12jul94     Fix dimensioning bug in SETDESCG
c     nebk   19jul94     Allow roundoff tolerance in CHKDESCG
c     nebk   27aug94     Convert OL2PIXCG to use correct coordinate 
c                        conversion routines via COSUBS.FOR
c     nebk   15jan95     Add SAVDESCG
c     nebk   14apr95     Add HARD and DOFID arguments to WEDGINCCG
c***********************************************************************
c
c* apptrfCG -- Apply transfer function to image
c& nebk
c: plotting
c+
      subroutine apptrfcg (pixr, trfun, groff, size, nimage, image,
     +                     nbins, his, cumhis)
c
      implicit none
      integer nimage(*), size, nbins, his(nbins)
      real groff, image(*), pixr(2), cumhis(*)
      character trfun*3
c
c  Take the log of an image with an offset added
c
c  Input:
c   pixr     Intensity range with bias and logs/sqrt taken if necessary
c   trfun    Transfer function.  "lin", "log", "heq" or "sqr"
c   groff    Bias to make image positive if necessary
c   size     Size of image
c   nimage   Normalization image
c   nbins    Number of bins for histogram equalization
c  Input/output:
c   image    Image.  Log taken on output
c   his      Image histogram for histogram equalization
c   cumhis   Cumulative histogram for histogram equalization
c            Values for each bin are the intensities assigned to 
c            the image.  Thus if an image pixel ended up in 
c            cumhis bin idx, then its new value is cumhis(idx)
c            
c--
c---------------------------------------------------------------------
      integer i
c---------------------------------------------------------------------
      if (trfun.eq.'log') then
        do i = 1, size
          if (nimage(i).ne.0) image(i) = log10(image(i) + groff)
        end do
      else if (trfun.eq.'sqr') then
        do i = 1, size
          if (nimage(i).ne.0) image(i) = sqrt(image(i) + groff)
        end do
      else if (trfun.eq.'heq') then
        call heqcg (pixr, size, nimage, image, nbins, his, cumhis)
      end if
c
      end
c
c
c* axabsCG -- Give generic "abs" axis label type for generic axis type
c& nebk
c: plotting
c+
      subroutine axabscg (naxis, gentyp, abstyp)
c
      implicit none
      integer naxis
      character*(*) gentyp(naxis), abstyp(naxis)
c
c  For a given generic axis type, return a sensible absolute axis label type
c
c  Input
c    naxis   Number of axes
c    gentyp  Array of generic axis type as given by AXTYPCG
c  Output
c    abstyp  Array of absolute axis label types
c           
c             RA           -> hms
c             DEC          -> dms
c             LATI, LONG   -> absdeg
c             VELO         -> abskms
c             FREQ         -> absghz
c             UV           -> abslin
c             otherwise    -> abslin
c--
c-----------------------------------------------------------------
      integer i
      character lgtype*8
c-----------------------------------------------------------------
      do i = 1, naxis
        lgtype = gentyp(i)
        call ucase(lgtype)
c
        if (lgtype.eq.'RA') then
          abstyp(i) = 'hms'
        else if (lgtype.eq.'DEC') then
          abstyp(i) = 'dms'
        else if (lgtype.eq.'LONG' .or. lgtype.eq.'LATI') then
          abstyp(i) = 'absdeg'
        else if (lgtype.eq.'VELO') then
          abstyp(i) = 'abskms'
        else if (lgtype.eq.'FREQ') then
          abstyp(i) = 'absghz'
        else if (lgtype.eq.'UV') then
          abstyp(i) = 'abslin'
        else
          abstyp(i) = 'abslin'
        end if
      end do
c
      end
c
c* axfndCG -- Find a specified generic axis in an image
c& nebk
c: plotting
c+
      subroutine axfndcg (type, naxis, ctype, iax)
c
      implicit none
      integer naxis, iax
      character*(*) type, ctype(naxis)
c
c  Find generic axis type in image.
c
c  Input
c    type   Generic axis type to find in axis string.  The first axis
c	    encountered that has this type is returned.  The type
c           should be one of:
c           
c             RA   ->  RA, LL, ELON, GLON
c             DEC  ->  DEC, MM, ELAT, GLAT
c             LONG ->  ELON, GLON
c             LATI ->  ELAT, GLAT
c             VELO ->  VELO, FELO
c             FREQ ->  FREQ
c             UV   ->  UU, VV
c             RAD  ->  An axis whose increment should be in
c		       radians.  These are RA, DEC, LAT, LONG axes
c                      as described by the LHS above.  
c           Other types are searched for exactly as specified
c    naxis  Number of axes to search
c    ctype  Axis types
c  Output
c    iax    Axis number that matches "type".  0 if not present
c--
c-----------------------------------------------------------------
      integer i
      character ltype*8, lctype*8
c-----------------------------------------------------------------
      ltype = type
      call ucase (ltype)	
      iax = 0
c
      do i = 1, naxis
        lctype = ctype(i)
        call ucase (lctype)
c
        if (ltype.eq.'RA') then
          if (index(lctype,'RA').ne.0 .or.
     +        index(lctype,'LL').ne.0) then
            iax = i
            return
          end if
        else if (ltype.eq.'DEC') then
          if (index(lctype,'DEC').ne.0 .or.
     +        index(lctype,'MM').ne.0) then
            iax = i
            return
          end if
        else if (ltype.eq.'LONG') then
          if (index(lctype,'ELON').ne.0 .or.
     +        index(lctype,'GLON').ne.0) then
            iax = i 
            return
          end if
        else if (ltype.eq.'LATI') then
          if (index(lctype,'ELAT').ne.0 .or.
     +        index(lctype,'GLAT').ne.0) then
            iax = i
            return
          end if
        else if (ltype.eq.'VELO') then
          if (index(lctype,'VELO').ne.0 .or.
     +        index(lctype,'FELO').ne.0) then
            iax = i 
            return
          end if
        else if (ltype.eq.'FREQ') then
          if (index(lctype,'FREQ').ne.0) then
            iax = i
            return
          end if
        else if (ltype.eq.'RAD') then
          if (index(lctype,'RA').ne.0 .or.
     +        index(lctype,'LL').ne.0 .or.
     +        index(lctype,'DEC').ne.0 .or.
     +        index(lctype,'MM').ne.0 .or.
     +        index(lctype,'ELON').ne.0 .or.
     +        index(lctype,'GLON').ne.0 .or.
     +        index(lctype,'ELAT').ne.0 .or.
     +        index(lctype,'GLAT').ne.0) then
            iax = i
            return
          end if
        else if (ltype.eq.'UV') then
          if (index(lctype,'UU').ne.0 .or.
     +        index(lctype,'VV').ne.0) then
            iax = i
            return
          end if
        else
          if (index(ctype(i),type).ne.0) then
            iax = i
            return
          end if
        end if
      end do
c
      end
c
c* axtypCG -- Return generic axis type for specified axes
c& nebk
c: plotting
c+
      subroutine axtypcg (naxis, ctype, type)
c
      implicit none
      integer naxis
      character*(*) ctype(naxis)
      character*4 type(naxis)
c
c  Return a generic axis type for each axis type.   
c
c  Input
c    naxis    Number of axes to consider
c    ctype    Array of axis type descriptors
c  Output
c    type     Array of generic axis types describing each axis
c             The generic names returned are one of 
c                 RA, DEC, LATI, LONG, VELO, FREQ, UV, NONE  where
c
c             RA   means CTYPE was one of   RA, LL
c             DEC  means CTYPE was one of   DEC, MM
c             LONG means CTYPE was one of   ELON, GLON
c             LATI means CTYPE was one of   ELAT, GLAT
c             VELO means CTYPE was one of   VELO, FELO
c             FREQ means CTYPE was one of   FREQ
c             UV   means CTYPE was one of   UU, VV
c             NONE means CTYPE was not recognized
c             
c--
c-----------------------------------------------------------------
      integer i
      character lctype*8
c-----------------------------------------------------------------
      do i = 1, naxis
        lctype = ctype(i)
        call ucase (lctype)
c
        if (index(lctype,'RA').ne.0 .or.
     +      index(lctype,'LL').ne.0) then
          type(i) = 'RA'
        else if
     +     (index(lctype,'DEC').ne.0 .or.
     +      index(lctype,'MM').ne.0) then
          type(i) = 'DEC'
        else if 
     +     (index(lctype,'ELON').ne.0 .or.
     +      index(lctype,'GLON').ne.0) then
          type(i) = 'LONG'
        else if
     +     (index(lctype,'ELAT').ne.0 .or.
     +      index(lctype,'GLAT').ne.0) then
          type(i) = 'LATI'
        else if
     +     (index(lctype,'VELO').ne.0 .or.
     +      index(lctype,'FELO').ne.0) then
          type(i) = 'VELO'
        else if (index(lctype,'FREQ').ne.0) then
          type(i) = 'FREQ'
        else if
     +     (index(lctype,'UU').ne.0 .or.
     +      index(lctype,'VV').ne.0) then
          type(i) = 'UV'
        else
          type(i) = 'NONE'
        end if
      end do
c
      end
c
c* chkdesCG -- Compare a double precision axis descriptor from two images
c& nebk
c: plotting
c+
      subroutine chkdescg (relax, type, iaxis, im1, im2, des1, des2)
c
      implicit none
      character type*(*), im1*(*), im2*(*)
      integer iaxis
      double precision des1, des2
      logical relax
c
c  Compare a double precision axis descriptor from two images
c
c  Input:
c    type    Type of descriptor
c    iaxis   Axis number
c    im1,2   Images
c    des1,2  Descriptors
c--
c-----------------------------------------------------------------------
      double precision desmax
      character line*130
      integer len1
c-----------------------------------------------------------------------
      desmax = max(abs(des1),abs(des2))
      if (abs(des1-des2).gt.desmax*1.0d-6 .or. des1*des2.lt.0.0d0) then
        write (line, 10) type, im1(1:len1(im1)), im2(1:len1(im2)),
     +                   iaxis
10      format ('CHKDESCG: Unequal ', a, ' for images ', a, ' & ', a,
     +          ' on axis ', i1)
        if (relax) then
          call bug ('w', line)
        else
          call bug ('i', 
     +       'CHKDESCG: You might consider, with care, OPTIONS=RELAX')
          call bug ('f', line)
        end if
      end if
c
      end
c
c* chkdimCG -- Check an image's dimensions are OK
c& nebk
c: plotting
c+
      subroutine chkdimcg (maxnax, maxdim, naxis, size, image)
c
      implicit none
      integer maxnax, maxdim, naxis, size
      character image*(*)
c
c  Check that an image's dimensions are acceptable.
c
c  Input:
c    maxnax      Maximum number of dimensions allowed in image
c    maxdim      Maximum size of first dimension allowed
c    naxis       Number of dimensions in contour image
c    size        SIze of first dimension
c    image       Image name
c--
c-----------------------------------------------------------------------
      character msg*80
      integer len1
c-----------------------------------------------------------------------
      if (naxis.gt.maxnax) then
        msg = 'CHKDIMCG: '//image(1:len1(image))//
     +        ' has too many dimensions'
        call bug ('f', msg)
      end if
c
      if (size.gt.maxdim) then
        msg = 'CHKDIMCG: '//image(1:len1(image))//
     +        ' first dimension too large'
        call bug ('f', msg)
      end if
c
      end
c
c* chnselCG -- Make list of CHAN and REGION selected channel groups
c& nebk
c: plotting
c+
      subroutine chnselcg (blc, trc, kbin, maxbox, boxes, maxgrp,
     +                     grpbeg, ngrp, ngrps)
c
      implicit none
      integer maxbox, boxes(maxbox), maxgrp, grpbeg(maxgrp), 
     +ngrp(maxgrp), ngrps, kbin(2), blc(3), trc(3)
c
c  Find the channels designated by the CHAN and REGION specifiations
c  via the RUNS arrays.  
c
c  Input
c    blc,trc    Cube surrounding region of interest
c    kbin       Channel increment and average to step through image
c    maxbox     Maximum number of boxes
c    boxes      Boxes following BOXINPUT,BOXSET,BOXINFO (optional) and
c               BOXMASK
c    maxgrp     Maximum number of allowed groups
c  Output
c    grpbeg     Array of start channels for each group of selected
c               channels.  Each group will be averaged together to
c               make on sub-plot
c    ngrp       Number of channels in each group
c    ngrps      Number of groups
c--
c-----------------------------------------------------------------------
      include 'maxdim.h'
      integer maxruns
      parameter (maxruns = 10*maxdim)
c
      integer runs(3,maxruns), nruns, k, j, ipl, xmin, xmax, ymin,
     +ymax, inc, iav
c-----------------------------------------------------------------------
      inc = kbin(1)
      iav = kbin(2)
      if (inc.eq.1) iav = 1
      if (iav.gt.inc) iav = inc
c
      j = 0
      k = 0
      ipl = blc(3)
c
      do while (ipl+j.le.trc(3))
c
c Use runs to see if plane has some unblanked pixels
c
        call boxruns (1, ipl+j, ' ', boxes, runs, maxruns,
     +                nruns, xmin, xmax, ymin, ymax)
c
        if (nruns.gt.0) then
c
c This plane in region
c
          j = j + 1
          if (j.eq.1) then
c
c Assign group start plane
c
            k = k + 1
            if (k.gt.maxgrp) call bug ('f',
     +        'CHNSELCG: You have selected too many groups of channels')
            grpbeg(k) = ipl
c
            if (kbin(2).eq.1) then
              ngrp(k) = 1
              j = 0
              ipl = ipl + kbin(1)
            end if
          else if (j.eq.kbin(2)) then
c
c Reached limit of number of planes to average together.
c
            ngrp(k) = j
            j = 0
            ipl = ipl + kbin(1)
          end if
        else
c
c Don't want this plane, so start a new group and assign
c number of planes in old group.
c
          if (k.ne.0 .and. ngrp(k).eq.0) ngrp(k) = j
          ipl = ipl + j + 1
          j = 0
        end if
      end do
c
      if (k.eq.0) call bug ('f', 
     +  'CHNSELCG: There were no valid pixels in the region')
c
c Finish off last group
c
      if (ngrp(k).eq.0) ngrp(k) = j
      ngrps = k
c
      end
c
c* conlevCG -- Compute contour levels
c& nebk
c: plotting
c+
      subroutine conlevcg (mirror, maxlev, lcin, cnaxis, csize,
     +                     levtyp, slev, nlevs, levs, srtlev)
c
      implicit none
      integer lcin, cnaxis, csize(cnaxis), nlevs, maxlev, srtlev(maxlev)
      real slev, levs(maxlev)
      character*1 levtyp
      logical mirror
c
c  Compute contour levels
c
c  Input:
c    mirror   MUltiply specified contour levsls by -1 and add to list
c    maxlev   Maximum number of levels allowed
c    lcin     Handle of contour image
c    cnaxis   Number of dimensions in contour image
c    csize    Dimensions of contour image
c  Input/output:
c    levtyp   Type of scale factor (percentage or absolute)
c    slev     Contour scale factor
c    nlevs    Number of contour levels
c  Output:
c    levs     Contour levels
c    srtlev   Indexes of array giving levels in increasing order
c--
c-----------------------------------------------------------------------
      integer i, ilev, mlevs
      real cdmin, cdmax, off, inc
c-----------------------------------------------------------------------
      mlevs = nlevs
      if (nlevs.eq.0) then
c
c Set default contours
c
        call imminmax (lcin, cnaxis, csize, cdmin, cdmax)
c
        if (cdmax.gt.0.0 .and. cdmin.lt.0.0) then
           slev = max(abs(cdmax), abs(cdmin)) / 8
c
           nlevs = abs(cdmin) / slev
           ilev = 1
           do i = -nlevs, -1, 1
             levs(ilev) = i * slev
             ilev = ilev + 1
           end do 
c
           nlevs = cdmax / slev
           do i = 1, nlevs, 1
             levs(ilev) = i * slev
             ilev = ilev + 1
           end do          
c 
           nlevs = ilev - 1
           slev = 1.0
           levtyp = 'a'
        else
           off = 0.05 * (cdmax - cdmin)
           nlevs = 10
           inc = ((cdmax-off) - (cdmin+off)) / (nlevs - 1)
           do i = 1, nlevs
              levs(i) = cdmin+off + (i-1)*inc
           end do
c
           slev = 1.0
           levtyp = 'a'
        end if
      else if (levtyp.eq.'p')  then
c
c Set percentage contours
c
        if (slev.eq.0.0) slev = 1.0
        call imminmax (lcin, cnaxis, csize, cdmin, cdmax)
        slev = slev * cdmax / 100.0
      else if (levtyp.eq.'a') then
c
c Absolute contours
c
        if (slev.eq.0.0) slev = 1.0
      end if
c
c Set mirrored contours only for user specified contours
c
      if (mirror .and. mlevs.ne.0) then
        mlevs = nlevs
        do i = 1, mlevs
          if (levs(i).ne.0.0) then
            if (nlevs.lt.maxlev) then
              nlevs = nlevs + 1
              levs(nlevs) = -1.0*levs(i)
            else
              call bug ('w',
     +        'CONLEVCG: Max. no. of contours reached during mirroring')
              goto 100
            end if
          end if
        end do
      end if
c
c Scale levels
c
100   do i = 1, nlevs
        levs(i) = levs(i) * slev
      end do
c 
c Sort in increasing order
c
      call sortidxr (nlevs, levs, srtlev)
c      
      end
c
c
c* copyimCG -- Copy image
c& nebk
c: plotting
c+
      subroutine copyimcg (n, in, copy)
c
      implicit none
      integer n
      real in(n), copy(n)
c 
c  Copy an image for safe keeping
c
c Input
c     n       Size of image
c     image   Image
c Output
c     copy    Copy of image
c-
c-----------------------------------------------------------------------
      integer i
c-----------------------------------------------------------------------
      do i = 1, n
        copy(i) = in(i)
      end do
c
      end
c
c* cosdecCG -- Find cos(DEC) for an RA axis
c& nebk
c: plotting
c+
      subroutine cosdeccg (iax, naxis, ctype, crval, cosdec, ok)
c
      implicit none
      integer iax, naxis
      double precision crval(naxis), cosdec
      character ctype(naxis)*(*)
      logical ok
c
c  If the axis of interest is an RA axis, find cos(DEC) if
c  the declination axis exists.
c
c Input:
c   iax      Axis of interest in the image
c   naxis    Number of axes in the image
c   ctype    Axis names
c   crval    Axis reference values
c Output:
c   cosdec   cos(DEC).  WIll be 1.0 if axis of interest is not
c            RA, or if DEC axis can't be found 
c   ok       True if RA asked for and DEC found
c            True if RA not asked for
c            False if RA asked for and DEC absent
c--
c-----------------------------------------------------------------------
      integer ira, idec
c------------------------------------------------------------------------
c
c Find RA axis
c
      call axfndcg ('RA', naxis, ctype, ira)
c
c Is it the one we are interested in
c
      if (iax.eq.ira) then
c
c Find the DEC axis
c
        call axfndcg ('DEC', naxis, ctype, idec)
        if (idec.gt.0) then
          ok = .true.
          cosdec = cos(crval(idec))
        else
          ok = .false.
          cosdec = 1.0
        end if
      else
        ok = .true.
        cosdec = 1.0
      end if
c
      end
c
c* defchrCG -- Give a default char. height for axis & velocity labels
c& nebk
c: plotting
c+
      subroutine defchrcg (nx, ny, cs)
c
      implicit none
      real cs(*)
      integer nx, ny
c
c  Work out default character size for axis labels and for velocity 
c  label.  Add a linear ramp otherwise they come out too big for 
c  single plots per page, and too small for multiple plots per page
c
c  Input:
c    nx,ny     Number of sub-plots in x and y directions
c  Input/output:
c    cs        PGPLOT character sizes for axis labels and velocity label
c--
c-----------------------------------------------------------------------
c
c Axis labels
c
      if (cs(1).le.0.0) then
        cs(1) = 1.2 / max(nx,ny) 
        cs(1) = (0.13*max(nx,ny) + 0.67) * cs(1)
      end if
c
c Velocity/frequency/channel labels
c
      if (cs(2).le.0.0) then
        cs(2) = 1.2 / max(nx,ny)
        cs(2) = (0.13*max(nx,ny) + 0.67) * cs(2)
      end if
c
      end
c
c* grfixCG -- Fix up a grey scale range with optional bias for log taking
c& nebk
c: plotting
c+
      subroutine grfixcg (pixr, lgin, gnaxis, gsize, trfun, 
     +                    pixr2, groff, blankg)
c
      implicit none
      real pixr(2), pixr2(2), groff, blankg
      integer lgin, gnaxis, gsize(*)
      character trfun*(*)
c
c  Make sure the grey scale range is valid, and take logs if
c  desired.  This may require a DC bias to avoid negative 
c  numbers in the image.
c
c  Input:
c    lgin     Handle for image
c    gnaxis   Number of dimesions in image
c    gsize    Size of dimensions
c    trfun    'log', 'lin', 'heq', or 'sqr' transfer functions
c  Input/Output:
c    pixr     User supplied grey scale range.  Defaults filled in
c             on output
c  Output:
c    pixr2    Grey scale range with bias and logs/sqrt taken if necessary
c    groff    DC bias to avoid negatives in image if logs taken
c    blankg   Value to use for blanked pixels
c--
c-----------------------------------------------------------------------
      real gmini, gdmin, gdmax
c-----------------------------------------------------------------------
c
c Set default range to data min to max
c
      if (pixr(1).eq.0.0 .and. pixr(2).eq.0.0) then
        call imminmax (lgin, gnaxis, gsize, pixr(1), pixr(2))
      else if (pixr(1).eq.pixr(2)) then
        call bug ('w', 
     +    'GRFIXCG: Zero grey scale range, reset to image range')
        call imminmax (lgin, gnaxis, gsize, pixr(1), pixr(2))
      end if
c
c Work out offset if log transfer function for grey scale requested
c
      pixr2(1) = pixr(1)
      pixr2(2) = pixr(2)
      if (trfun.eq.'log' .or. trfun.eq.'sqr') then
        groff = 0.0
        call imminmax (lgin, gnaxis, gsize, gdmin, gdmax)
        gmini = min(pixr2(1), pixr2(2), gdmin)
        if (gmini.le.0.0) groff = abs(gmini) + 0.01*(gdmax - gdmin)
        if (trfun.eq.'log') then
          pixr2(1) = log10(pixr2(1)+groff)
          pixr2(2) = log10(pixr2(2)+groff)
        else 
          pixr2(1) = sqrt(pixr2(1)+groff)
          pixr2(2) = sqrt(pixr2(2)+groff)
        end if
      end if
c
c Set blanked pixel value to white.   
c
      blankg = pixr2(1) - (0.01*(pixr2(2)-pixr2(1)))
c
      end
c
c* hedinfCG -- Get some header information from image
c& nebk
c: plotting
c+
      subroutine hedinfcg (lun, naxis, size, epoch, crpix, cdelt,
     +                     crval, ctype, mask)
c
      implicit none
      integer lun, naxis, size(naxis)
      real epoch
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      character*(*) ctype(naxis)
      logical mask
c
c  Get some header keywords from the image associated with LUN
c 
c  Input
c    lun      Handle of image
c    naxis    Number of dimensions in image
c    size     Size of each axis
c  Output
c    epoch    Epoch of image
c    crpix    Array of image reference pixels
c    cdelt    Array of image increments (natural inits; rad)
c    crval    Array of image reference values (natural units)
c    ctype    Array of image axis types
c    mask     True if there is blanking mask
c--
c------------------------------------------------------------------------
      integer i
      character str*1, itoaf*1
      logical hdprsnt
c---------------------------------------------------------------------
      do i = 1, naxis
        str = itoaf(i)
c
        call rdhdd (lun, 'crpix'//str, crpix(i), dble(size(i))/2.0)
        call rdhdd (lun, 'cdelt'//str, cdelt(i), 1.0d0)
        call rdhda (lun, 'ctype'//str, ctype(i), ' ')
        call rdhdd (lun, 'crval'//str, crval(i), 0.0d0)
      end do
      call rdhdr (lun, 'epoch', epoch, 0.0)
      mask = hdprsnt (lun, 'mask')
c
      end 
c
c* heqCG -- Histogram equalize an image
c& nebk
c: plotting
c+
      subroutine heqcg (pixr, n, nimage, image, nbins, his, cumhis)
      implicit none
      integer nbins, n, nimage(n), his(nbins)
      real image(n), pixr(2), cumhis(nbins)
c
c  Apply histogram equalization to an image directly.  128 bins 
c  are used in the histogram.
c
c  Input
c   pixr   Display intensity range with bias added and logs/sqrt 
c          taken if necessary
c   n      Number of pixels
c   nimage Normalization image
c   nbins  Number of bins in histogram
c  Input/output
c   image  Image
c   his    Image histogram
c   cumhis Cumulative histogram.  Values for each bin are
c          the intensities assigned to the image.  Thus
c          if an image pixel ended up in cumhis bin idx, then
c          its new value is cumhis(idx)
c
c--
c-----------------------------------------------------------------------
      integer idx, i
      real fac, bmin, bmax, cum
c-----------------------------------------------------------------------
c
c Initialize histogram
c
      bmin = pixr(1)
      bmax = pixr(2)
      do i = 1, nbins
        his(i) = 0
        cumhis(i) = 0.0
      end do
c
c Generate image histogram
c
      fac = real(nbins-1) / (bmax-bmin)
      do i = 1, n
        if (nimage(i).gt.0.0) then
          idx = max(1,min(nbins,nint((image(i)-bmin)*fac)+1))
          his(idx) = his(idx) + 1
        end if
      end do
c
c Generate cumulative histogram.  
c
      cum = 0.0
      do i = 1, nbins
        cum = cum + his(i) 
        cumhis(i) = cum
      end do
c
c Now discretize the cumulative histogram values as well
c
      fac = real(nbins-1) / real(n)
      do i = 1, nbins
c
c This index converts the actual cumulative histogram
c value to the nearest discrete bin
c
        idx = max(1,min(nbins,nint(cumhis(i)*fac)+1))
c
c Convert this bin back to an intensity and reuse CUMHIS array
c
        cumhis(i) = real(idx)/real(nbins)*(bmax-bmin) + bmin
      end do
c
c Now fix the image pixels (including masked ones)
c
      fac = real(nbins-1) / (bmax-bmin)
      do i = 1, n
c
c Find cumulative histogram index of this pixel
c
        idx = max(1,min(nbins,nint((image(i)-bmin)*fac)+1))
c
c Replace by discretized cumulative histogram intensity
c
        image(i) = cumhis(idx)
      end do
c
      end
c
c* limitsCG -- Work out limits and transformation matrix for both axes
c& nebk
c: plotting
c+
      subroutine limitscg (labtyp, blc, trc, naxis, epoch, crpix, cdelt,
     +   crval, ctype, doepoch, xmin, xmax, ymin, ymax, ibin, jbin, 
     +   tr, xlabel, ylabel)
c
      implicit none
      integer blc(*), trc(*), naxis, ibin, jbin
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      real xmin, xmax, ymin, ymax, tr(6), epoch
      character*(*) labtyp(2), ctype(naxis), xlabel, ylabel
      logical doepoch
c
c   Work out window world coordinate limits and transformation array 
c   depending upon label type.  Return header items to be used
c   for all following positional computations.
c
c     Input
c       labtyp       Label type (p, po, ao, rd, l, lo) for x and y axes
c       blc,trc      Spatial window in unbinned pixels
c       naxis        Number of axes
c       crpix        Array of image reference pixels
c       cdelt        Array of image increments 
c       crval        Array of image reference values 
c       ctype        Array of image axis types
c       epoch        EPoch
c       doepoch      Write epoch into axis labels
c       i,jbin       x and y increments to step through image in
c     Output
c       c,ylabel     Labels for axes
c       xmin,xmax    Spatial window in world coordinates, depends on labtyp
c       ymin,ymax
c       tr           Matrix transforming from array indices to world
c                    coordinates.  Note this accounts for the fact that
c                    only the desired window is read into the data arrays,
c                    so there is a blc offset included in tr.  It also
c		     accounts for any spatial binning.
c
c-----------------------------------------------------------------------
c
c Set transformation matrix; converts from pixels to world coordinates.
c No cross terms in transformation
c
      tr(3) = 0.0
      tr(5) = 0.0
c
c Fill limits and transformation depending on label type
c
      call limtrcg (doepoch, labtyp(1), naxis, 1, crval, crpix, cdelt, 
     +   ctype, blc(1), trc(1), epoch, ibin, xmin, xmax, 
     +   tr(1), tr(2), xlabel)
      call limtrcg (doepoch, labtyp(2), naxis, 2, crval, crpix, cdelt, 
     +   ctype, blc(2), trc(2), epoch, jbin, ymin, ymax, 
     +   tr(4), tr(6), ylabel)
c
      end
c
c* limtrCG -- Work out limits and transformation matrix for one axis
c& nebk
c: plotting
c+
      subroutine limtrcg (doepoch, labtyp, naxis, iax, crval, crpix, 
     +                    cdelt, ctype, blc, trc, epoch, bin, axmin, 
     +                    axmax, tr1, tr2, label)
c
      implicit none
      integer blc, trc, iax, naxis, bin
      double precision cdelt(naxis), crval(naxis), crpix(naxis)
      real axmin, axmax, tr1, tr2, epoch
      character labtyp*(*), label*(*), ctype(naxis)*(*)
      logical doepoch
c
c  Work out limits and transformation for current axis
c
c  Input
c    doepoch      Write epoch into axis labels
c    labtyp       Label type for axis
c    naxis        Number of axes
c    iax          Number of axis we want to label. Generally 1 or 2
c    crpix        Array of image reference pixels
c    cdelt        Array of image increments 
c    crval        Array of image reference values 
c    ctype        Array of image axis types
c    blc,trc      Spatial window in unbinned pixels
c    epoch        Epoch
c    bin          Pixel increment that we are stepping through image with
c  Output
c    axmin,axmax  Spatial window in world coordinates, depends on labtyp
c    tr1,2        Matrix elements for current axis for array transforming 
c                 from array indices to world coordinates.  Note this 
c                 accounts for the fact that only the desired window is 
c                 read into the data arrays,  so there is blc offset 
c                 included in tr.  Thus x = tr1 + tr2*i where
c                 i is 1 at blc. 
c    label        Axis label
c--
c-----------------------------------------------------------------------
      include 'mirconst.h'
      double precision r2a, w1
      parameter (r2a = 180.0*3600.0/dpi)
c
      double precision winc, pix
      integer l2, ipos, len1, irad, ifrq, ivel, iuv
      character str*20, estr*5
      logical ok
c----------------------------------------------------------------------------
c
c Set limits depending on label type and check validity
c
      call pix2wcg (.true., dble(blc-0.5), iax, labtyp, naxis, 
     +              crval, crpix, cdelt, ctype, w1, ok)
      axmin = w1
      call pix2wcg (.true., dble(trc+0.5), iax, labtyp, naxis, 
     +              crval, crpix, cdelt, ctype, w1, ok)
      axmax = w1
c
      if (axmin.eq.axmax) then
        if (iax.eq.1) call bug ('f', 
     +    'LIMTRCG: Display limits; XMIN = XMAX -- check REGION')
        if (iax.eq.2) call bug ('f', 
     +    'LIMTRCG: Display limits; YMIN = YMAX -- check REGION')
      end if
c
c Set transformation matrix elements depending on label type
c
      pix = dble(blc) - 1.0d0 - (bin-1)*0.5d0
      call pix2wcg (.true., pix, iax, labtyp, naxis, crval, 
     +              crpix, cdelt, ctype, w1, ok)
      tr1 = w1
c
      call pixi2wcg (.true., iax, labtyp, naxis, crval, crpix, 
     +               cdelt, ctype, winc, ok)
      tr2 = winc*bin
c
c Write epoch string for label
c
      if (doepoch .and. epoch.gt.0.0) then
        write (estr(2:), 100) nint(epoch)
100     format (i4)
        if (estr(2:).eq.'2000') then
          estr(1:1) = 'J'
        else if (estr(2:).eq.'1950') then
          estr(1:1) = 'B'
        end if
      else
        estr = ' '
      end if
c
c Remove ---* and --* from axis type
c
      ipos = index(ctype(iax),'---')
      if (ipos.ne.0) then
        str = ctype(iax)(1:ipos-1)
      else
        ipos = index(ctype(iax),'--')
        if (ipos.ne.0) then
          str = ctype(iax)(1:ipos-1)
        else
          str = ctype(iax)(1:len1(ctype(iax)))
        end if
      end if
      l2 = len1(str)
c
c Set the axis label depending on label type
c
      call axfndcg ('RAD',  1, ctype(iax), irad)
      call axfndcg ('FREQ', 1, ctype(iax), ifrq)
      call axfndcg ('VELO', 1, ctype(iax), ivel)
      call axfndcg ('UV',   1, ctype(iax), iuv)
c
      if (labtyp.eq.'abspix') then
        label = str(1:l2)//' (pixels; '//estr//')'
        if (estr.eq.' ') label = str(1:l2)//' (pixels)'
      else if (labtyp.eq.'relpix') then
        label = str(1:l2)//' offset (pixels; '//estr//')'
        if (estr.eq.' ') label = str(1:l2)//' offset (pixels)'
      else if (labtyp.eq.'arcsec') then
        label = str(1:l2)//' offset (arcsec; '//estr//')'
        if (estr.eq.' ') label = str(1:l2)//' offset (arcsec)'
      else if (labtyp.eq.'absdeg') then
        label = str(1:l2)//' (degrees; '//estr//')'
        if (estr.eq.' ') label = str(1:l2)//' (degrees)'
      else if (labtyp.eq.'reldeg') then
        label = str(1:l2)//' offset (degrees; '//estr//')'
        if (estr.eq.' ') label = str(1:l2)//' offset (degrees)'
      else if (labtyp.eq.'hms') then
        label = str(1:l2)//' ('//estr//')'
        if (estr.eq.' ') label = str(1:l2)
      else if (labtyp.eq.'dms') then
        label = str(1:l2)//' ('//estr//')'
        if (estr.eq.' ') label = str(1:l2)
      else if (labtyp.eq.'absghz') then
        label = str(1:l2)//' (GHz)'
      else if (labtyp.eq.'relghz') then
        label = str(1:l2)//' offset (GHz)'
      else if (labtyp.eq.'abskms') then
c-lss        label = str(1:l2)//' (Km s\u-1\d)'
        label = 'Velocity (km s\u-1\d)'
      else if (labtyp.eq.'relkms') then
        label = str(1:l2)//' offset (Km s\u-1\d)'
      else if (labtyp.eq.'rellin') then
        if (irad.eq.1) then
          label = str(1:l2)//' offset (radians)'
        else if (ifrq.eq.1) then
          label = str(1:l2)//' offset (GHz)'
        else if (ivel.eq.1) then
          label = str(1:l2)//' offset (Km s\u-1\d)'
        else if (iuv.eq.1) then
          label = str(1:l2)//' offset (\gl)'
        else
          label = str(1:l2)//' offset '
        end if
      else if (labtyp.eq.'abslin') then
        if (irad.eq.1) then
          label = str(1:l2)//' (radians)'
        else if (ifrq.eq.1) then
          label = str(1:l2)//' (GHz)'
        else if (ivel.eq.1) then
          label = str(1:l2)//' (Km s\u-1\d)'
        else if (iuv.eq.1) then
          label = str(1:l2)//' (\gl)'
        else
          label = str(1:l2)
        end if
      else if (labtyp.eq.'none') then
        label = ' '
      end if
c
      end
c
c* maskorCG -- OR mask image mask with data image mask
c& nebk
c: plotting
c+
      subroutine maskorcg (blank, win, bimage, nimage, image)
c
      implicit none
      integer nimage(*), win(2)
      real image(*), blank
      logical bimage(*)
c
c  OR the mask image mask and the grey/contour/vector image mask
c
c  Input:
c    blank       Value to give blanked pixel
c    win         Size of image
c    bimage      The mask image mask.True is unflagged, false is flagged
c  Input/Output
c    nimage      The normalization image.  0-> blanked
c    image       The image.  New blanks may be set
c--
c------------------------------------------------------------------------
      integer i, imsize
c------------------------------------------------------------------------
      imsize = win(1) * win(2)
      do i = 1, imsize
        if (.not.bimage(i)) then
          nimage(i) = 0
          image(i)  = blank
        end if
      end do
c
      end
c
c
c*matchCG -- Match fields with allowed types and die if no good
c:plotting
c+
      subroutine matchcg (n, field, string, struct, ntype, types)
c
      implicit none
      integer ntype, n
      character*(*) types(ntype), string, field, struct
c
c  Look for string in list of allowed ones.  If not found die with 
c  fatal error.  Expand string for minimum match.  Extra variables
c  can be used to provide error messages.  These messages expect
c  that the string is one field from several fields making up
c  one structure, and that there are several structures being
c  examined.  For example, an overlay file for CGDISP expects
c  many rows, each describing one overlay.  Each row contains
c  several fields, each of which may take on different values.
c
c  Inputs:
c    ntype	The number of possible values that STRING can have
c    type	An array of possible values for STRING
c
c    n          Number of the thing that we are matching (used
c               in  error messages if non zero)
c    field      A string describing what field STRING is (used
c               in error messages if non blank).
c    struct     A string describing the generic name of the structure
c               from which STRING is one field (used in error messages
c               if non blank).
c               Examples are "overlay", "slice"
c  Input/output:
c    string     The string that we are trying to match.  It is
c               expanded from minimum  match on output
c
c  An example of an error message would be:
c
c      STRING is ambiguous for STRUCT # N field FIELD.  Choose from: ...
c
c      Thus, if STRING was "rel", STRUCT was "overlay", N was 14
c      and FIELD was "xotype" then the message would read
c
c
c      "rel" is ambiguous for overlay # 14 field "xotype". Choose from: ...
c
c       Got it ??
c 
c--
c------------------------------------------------------------------------
      integer l, i, iopt, j, il, il2
      integer len1
      character*130 umsg, str*10
c-----------------------------------------------------------------------
      l = len1(string)
c
      iopt = 0
      do i = 1, ntype
        if (string(1:l).eq.types(i)(1:l)) then
          if (iopt.ne.0) then
            umsg = '"'//string(1:l)//'" is ambiguous'
            il = len1(umsg) + 1
c
            if (struct.ne.' ' .and. n.gt.0) then
              umsg(il:) = ' for '//struct(1:len1(struct))
              il = len1(umsg) + 1
c
              call strfi (n, '(i4)', str, il2)
              umsg(il:) = ' (# '//str(1:il2)//')'
              il = len1(umsg) + 1
            end if
c
            if (field.ne.' ') then
              if (struct.eq.' ' .or. n.eq.0) then
                umsg(il:) =  ' for field "'//field(1:len1(field))//
     +                       '".  Choose from'
              else
                umsg(il:) =  ' field "'//field(1:len1(field))//
     +                       '".  Choose from'
              end if
            else
              umsg(il:) =  '. Choose from'
            end if
c
            call output (umsg)
            do j = 1, ntype
              umsg = '   '//types(j)
              call output (umsg)
            end do
            call bug('f', 'MATCHCG:')
          end if
          iopt = i
        endif
      end do
c
c Set expanded string
c
      if (iopt.ne.0) string = types(iopt)
c
c Didn't find nuttin
c
      if(iopt.eq.0) then
        umsg = '"'//string(1:l)//'" is unrecognized'
        il = len1(umsg) + 1
c
        if (struct.ne.' ' .and. n.gt.0) then
          umsg(il:) = ' for '//struct(1:len1(struct))
          il = len1(umsg) + 1
c
          call strfi (n, '(i4)', str, il2)
          umsg(il:) = ' (# '//str(1:il2)//')'
          il = len1(umsg) + 1
        end if
c
        if (field.ne.' ') then
          if (struct.eq.' ' .or. n.eq.0) then
            umsg(il:) =  ' for field "'//field(1:len1(field))//
     +                   '".  Choose from'
          else
            umsg(il:) =  ' field "'//field(1:len1(field))//
     +                   '".  Choose from'
          end if
        else
          umsg(il:) =  '. Choose from'
        end if
c
        call output (umsg)
        do j = 1, ntype
          umsg = '   '//types(j)
          call output (umsg)
        end do
        call bug('f', 'MATCHCG:')
      end if
c
      end
c
c
c* nxnyCG -- Work out number of sub-plots per page
c& nebk
c: plotting
c+
      subroutine nxnycg (nxdef, nydef, nz, nx, ny, nlast)
c
      implicit none
      integer nxdef, nydef, nx, ny, nz, nlast
c
c  Work out number of plots in the x and y directions and the
c  total number of plots
c
c  Inputs
c    nx,ydef   Default x and y numbers of sub-plots per page
c    nz        Total number of sub-plots
c  Outputs
c    nx,ny     Number of sub-plots in x and y directions per page
c    nlast     Number of sub-plots on the last row of the last page
c--
c--------------------------------------------------------------------------
      if (nx.le.0 .or. ny.le.0) then
        if (nz.lt.nxdef*nydef) then
          nx = 1
          ny = 1
          do while (nz.gt.nx*ny) 
            if (nx.eq.ny) then
              nx = nx + 1
            else
              ny = ny + 1
            end if
          end do
        else
          nx = nxdef
          ny = nydef
        end if
      end if
c
      nlast = mod(nz,nx)
      if (nlast.eq.0) nlast = nx
c
      end
c
c*OpImCG -- Open an image and return axis descriptors
c:plotting
c+
      subroutine opimcg (maxdim, maxnax, in, lin, naxis, size, epoch,
     +                   mask, crpix, cdelt, crval, ctype)
c
      implicit none
c
      integer maxdim, maxnax, lin, size(maxnax), naxis
      double precision crval(maxnax), cdelt(maxnax),
     +  crpix(maxnax)
      real epoch(*)
      character*(*) in, ctype(maxnax)
      logical mask
c
c     Open an image and return some header descriptors 
c
c   Input:
c     maxdim     Maximum allowed size of first dimension of image
c     maxnax     Maximum number of allowed dimenions for image
c   Output:
c     lin        Handle for image
c     size       Size of each dimension of image 
c     naxis      Number of dimensions of image
c     epoch      Epoch of image
c     mask       True if blanking mask present for image
c     crpix      Reference pixels
c     cdelt      Increments
c     crval      Reference values
c     ctype      Axis types
c--
c-----------------------------------------------------------------------
      integer len1
      character msg*132
c-----------------------------------------------------------------------
      call xyopen (lin, in, 'old', maxnax, size)
      call rdhdi (lin, 'naxis', naxis, 0)
      if (naxis.eq.0) then
        msg = in(1:len1(in))//' has zero dimensions !!'
        call bug ('f', msg)
      end if
c
      call hedinfcg (lin, naxis, size, epoch, crpix, cdelt,
     +               crval, ctype, mask)
      call chkdimcg (maxnax, maxdim, naxis, size, in)
c
      end
c
c
c*OptCG -- Get command line options but only warn if unrecognized.
c:plotting
c+
      subroutine optcg (key, opts, present, nopt)
c
      implicit none
      character key*(*)
      integer nopt
      character opts(nopt)*(*)
      logical present(nopt)
c
c  Get options from the command line, and return to the caller those
c  options that are present. 
c
c  Unrecognized options generate a warning only, unlike the standard 
c  Miriad subroutine that does this which issues a fatal error.
c
c  Inputs:
c    key	The task keyword to use.
c    opts	An array of possible option values. These should be in lower
c		case.
c    nopt	The number of possible options.
c  Output:
c    present	This indicates whether the option was present.
c--
c------------------------------------------------------------------------
      character string*16
      integer l,i,iopt
c
c  Externals.
c
      integer len1
      character*80 umsg
c-----------------------------------------------------------------------
c
c  Initialise the options to indicate that none are present.
c
      do i = 1, nopt
        present(i) = .false.
      end do
c
c  Search the task parameters.
c
      call keya (key, string, ' ')
      do while (string.ne.' ')
        l = len1(string)
        call lcase (string(1:l))
        umsg = 'OPTCG: Unrecognised option "'//string(1:l)//'"'
        if (l.gt.len(opts(1))) call bug ('f', umsg)
        iopt = 0
        do i = 1, nopt
          if (string(1:l).eq.opts(i)(1:l)) then
            umsg = 'OPTCG: Ambiguous option "'//string(1:l)//'"'
            if (iopt.ne.0) call bug ('f', umsg)
            iopt = i
          end if
        end do
c
        if (iopt.eq.0) then
          umsg = 'OPTCG: Unrecognised option "'//string(1:l)//'"'
          call bug ('w', umsg)
        else
          present(iopt) = .true.
        end if
        call keya (key, string, ' ')
      end do
c
      end
c
c* ol2pixCG -- Convert overlay location in given coordinates to pixels
c& nebk
c: plotting
c+
      subroutine ol2pixcg (lun, pix3, ofig, otype, off, dsign, nums, 
     +                     opos, np)
      implicit none
c
      double precision off(*), nums(*), opos(*), pix3
      integer lun, dsign(2), np
      character*(*) otype(2), ofig
c
c Convert overlay location from OTYPE units to pixels.  This is 
c a conversion from true world coordinates to image pixels
c
c Input
c   lun       Handle of image
c   pix3       Third axis pixel (channel) that we are displaying 
c             this overlay on
c   ofig      Overlay figure type
c   otype     Overlay units  for each axis ('arcsec' etc)
c   dsign     SIgn for dms axes. +/-1  
c   nums      The array of numbers read from the overlay file
c             starting with the first one to use here.  These
c             are in true coordinates such as those given by IMPOS
c   off       Offset to be added to the locations decoded from
c	      the text file and held in NUMS.  These are in the same
c             units as OTYPE so no conversion is done.  Is ignored
c             for RA and DEC because I am too lazy.
c Output
c   opos      Output location in pixels for x and y
c   np        This is the number of locations of the NUMS array used
c             
c--
c-----------------------------------------------------------------------
      include 'mirconst.h'
      double precision win(3), wout(3)
      character*6 typei(3), typeo(3)
      integer ip, i
c-----------------------------------------------------------------------
c
c Prepare coordinates for conversion
c
      ip = 1
      do i = 1, 2
        if (otype(i).eq.'hms') then
          win(i) = nums(ip) + nums(ip+1)/60.0d0 + nums(ip+2)/3600.0d0
          win(i) = win(i) * dpi / 12.0d0
          ip = ip + 3
        else if (otype(i).eq.'dms') then
          win(i) = abs(nums(ip)) + nums(ip+1)/60.d0 + 
     +             nums(ip+2)/3600.0d0
          win(i) = dsign(i) * abs(win(i)) * dpi / 180.0d0
          ip = ip + 3
        else
          win(i) = nums(ip) + off(i)
          ip = ip + 1
        end if
c
        typei(i) = otype(i)
        typeo(i) = 'abspix'
      end do
      typei(3) = 'abspix'
      typeo(3) = 'abspix'
      win(3) = pix3
c
c Convert location to absolute pixels
c
      call w2wco (lun, 3, typei, ' ', win, typeo, ' ', wout)
      opos(1) = wout(1)
      opos(2) = wout(2)
c
c If this overlay is a 'line' type, there is another location to do
c 
      if (ofig.eq.'line') then
        do i = 1, 2
          if (typei(i).eq.'hms') then
            win(i) = nums(ip) + nums(ip+1)/60.0d0 + nums(ip+2)/3600.0d0
            win(i) = win(i) * dpi / 12.0d0
            ip = ip + 3
          else if (typei(i).eq.'dms') then
            win(i) = abs(nums(ip)) + nums(ip+1)/60.d0 + 
     +               nums(ip+2)/3600.0d0
            win(i) = dsign(i) * abs(win(i)) * dpi / 180.0d0
            ip = ip + 3
          else
            win(i) = nums(ip) + off(i)
            ip = ip + 1
          end if
        end do
c
c Convert location to absolute pixels
c
        call w2wco (lun, 3, typei, ' ', win, typeo, ' ', wout)
        opos(3) = wout(1)
        opos(4) = wout(2)
      end if
      np = ip - 1
c
      end
c
c* pix2wcg -- Convert from image pixel to world coordinate of given type
c& nebk
c: plotting
c+
      subroutine pix2wcg (domsg, pixel, iax, labtyp, naxis, crval, 
     +                    crpix, cdelt, ctype, world, ok)
c
      implicit none
      integer naxis, iax
      double precision cdelt(naxis), crval(naxis), crpix(naxis),
     +  world, pixel
      character labtyp*(*), ctype(naxis)*(*)
      logical ok, domsg
c
c  Convert from image pixels to world coordinates, depending on
c  requested labtyp.
c
c  Input:
c    domsg   If true, give a message warning when requested labtyp does 
c            not match the axis type in ctype.
c    pixel   Image pixel value
c    iax     This is the axis number in which we are interested. Should
c            be 1, 2 or 3.
c    labtyp  Requested type of world coordinate.   Should be one
c            of   abspix, relpix, arcsec, hms, dms, absghz, relghz,
c                 abskms, relkms, abslin, rellin, none. Note that a 
c	     request for a linear (abs or rel) axis conversion for an
c	     RA axis will return the RA in radians of polar rotation. 
c	     That is, the increment will be divided by cos(DEC)
c	     For labtyp=hms and labtyp=dms the world coordinate is in 
c	     seconds of time and seconds of arc.
c    naxis   Number of axes in image
c    crval   Array of image reference values
c    crpix   Array of image reference pixels
c    cdelt   Array of image pixel increments
c    ctype   Array of image axis types
c  Output:
c    world   Output world coordinate.  
c    ok      If false, then the requested labtyp is inconsistent with
c            the axis type.  WOrld will have been computed as if
c            the axis type was as expected.
c--
c-----------------------------------------------------------------------
      include 'mirconst.h'
      include 'maxdim.h'
      double precision r2a, r2d
      integer max2
c
      parameter (r2a = 180.0d0*3600.0d0/dpi, max2 = 11 * maxdim,
     +           r2d = 180.0d0/dpi)
c
      double precision rainc, cosdec
      integer idec, ira, ifrq, ivel, len1, irad
      character msg*80
      logical warn(11,maxdim), cdok
      save warn
      data warn /max2*.true./
c----------------------------------------------------------------------------
      if (iax.lt.1 .or. iax.gt.naxis) 
     +  call bug ('f', 'PIX2WCG: Invalid axis number')
c
      call axfndcg ('RA',   naxis, ctype, ira)
      call axfndcg ('DEC',  naxis, ctype, idec)
      call axfndcg ('FREQ', naxis, ctype, ifrq)
      call axfndcg ('VELO', naxis, ctype, ivel)
      call axfndcg ('RAD', 1, ctype(iax), irad)
      call cosdeccg (iax, naxis, ctype, crval, cosdec, cdok)
c
c Set world coordinate depending on type
c
      ok = .true.
      if (labtyp.eq.'abspix' .or. labtyp.eq.'none') then
c
c Absolute pixels ('none' masquerades as 'abspix')
c
        world = pixel
      else if (labtyp.eq.'relpix') then
c 
c Relative pixels
c
        world = pixel - crpix(iax)
      else if (labtyp.eq.'arcsec') then
c
c Relative arcseconds
c
        if (irad.eq.0) then
          write (msg, 100) iax
100       format ('PIX2WCG: Axis ',i1,' does not appear to have pixel ',
     +            'increments in radians but')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +      'PIX2WCG: conversion to "arcsec" requested. Continue '//
     +      'assuming axis in radians')
          warn(1,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax) * r2a
      else if (labtyp.eq.'hms') then
c
c HH MM SS.S
c
        if (iax.ne.ira .and. warn(2,iax)) then
          write (msg, 200) iax
200       format ('PIX2WCG: Axis ', i1, ' is not RA but conversion ',
     +            'to "hms"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +      'PIX2WCG: requested.  Continue assuming axis in radians')
          warn(2,iax) = .false.
          ok = .false.
        end if
c
        if (idec.eq.0) call bug ('f', 
     +    'PIX2WCG: No DEC axis found; cannot convert RA to "hms"')
c
c Work out in radians
c
        world = ((pixel-crpix(iax))*cdelt(iax)/cosdec)+crval(iax)
c
c Convert to seconds of time
c
        world = world * r2a / 15.0
      else if (labtyp.eq.'dms') then
c
c DD MM SS.S
c
        if (iax.ne.idec .and. warn(3,iax)) then
          write (msg, 300) iax
300       format ('PIX2WCG: Axis ', i1, ' is not DEC but conversion ',
     +            'to "dms"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +      'PIX2WCG: requested.  Continue assuming axis in radians')
          warn(3,iax) = .false.
          ok = .false.
        end if
c
c Work out in radians
c
        world = ((pixel-crpix(iax))*cdelt(iax)) + crval(iax)
c
c Convert to seconds
c
        world = world * r2a 
      else if (labtyp.eq.'absghz') then
c
c Absolute frequency
c
        if (iax.ne.ifrq .and. warn(4,iax)) then
          write (msg, 400) iax
400       format ('PIX2WCG: Axis ', i1, 
     +            ' is not FREQ but conversion to "absghz"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +    'PIX2WCG: requested. Continue assuming axis in GHz')
          warn(4,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax) + crval(iax)
      else if (labtyp.eq.'relghz') then
c
c Relative frequency
c
        if (iax.ne.ifrq .and. warn(5,iax)) then
          write (msg, 500) iax
500       format ('PIX2WCG: Axis ', i1, 
     +            ' is not FREQ but conversion to "relghz"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +    'PIX2WCG: requested. Continue assuming axis in GHz')
          warn(5,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax) 
      else if (labtyp.eq.'abskms') then
c
c Absolute velocity
c
        if (iax.ne.ivel .and. warn(6,iax)) then
          write (msg, 600) iax
600       format ('PIX2WCG: Axis ', i1, 
     +            ' is not VELO but conversion to "abskms"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +     'PIX2WCG: requested. Continue assuming axis in Km/s')
          warn(6,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax) + crval(iax)
      else if (labtyp.eq.'relkms') then
c
c Relative velocity
c 
        if (iax.ne.ivel .and. warn(7,iax)) then
          write (msg, 700) iax
700       format ('PIX2WCG: Axis ', i1, 
     +            ' is not VELO but conversion to "relkms"')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +     'PIX2WCG: requested. Continue assuming axis in Km/s')
          warn(7,iax) = .false.
          ok = .false.
        end if
        world = (pixel - crpix(iax)) * cdelt(iax) 
      else if (labtyp.eq.'abslin') then
c
c Absolute linear coordinate.  For RA convert to radians of
c polar rotation.
c
        if (iax.eq.ira .and. idec.eq.0) then
          if (warn(8,iax)) then
            write (msg, 800) iax
800         format ('PIX2WCG: "abslin" requested for RA axis ', i1, 
     +              ' but no DEC axis')
            call output (msg)
            msg = 'PIX2WCG: in image so coordinate is radians on sky'
            call output (msg)
            warn(8,iax) = .false.
          end if
        end if
c
        rainc = cdelt(iax) / cosdec
        world = (pixel - crpix(iax)) * rainc + crval(iax)
      else if (labtyp.eq.'rellin') then
c
c Relative linear coordinate.  For RA convert to radians of
c polar rotation.
c
        if (iax.eq.ira .and. idec.eq.0 .and. warn(9,iax)) then
          write (msg, 900) iax
900       format ('PIX2WCG: "rellin" requested for RA axis ', i1, 
     +            ' but no DEC axis')
          call output (msg)
          msg = 'PIX2WCG: in image so coordinate is radians on sky'
          call output (msg)
          warn(9,iax) = .false.
        end if
        rainc = cdelt(iax) / cosdec
        world = (pixel - crpix(iax)) * rainc 
      else if (labtyp.eq.'reldeg') then
c
c Relative degrees
c
        if (irad.eq.0) then
          write (msg, 910) iax
910       format ('PIX2WCG: Axis ',i1,' does not appear to have pixel ',
     +            'increments in radians but')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +       'PIX2WCG: conversion to "arcsec" requested. Continue '//
     +       'assuming axis in radians')
          warn(10,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax) * r2d
      else if (labtyp.eq.'absdeg') then
c
c Absolute degrees
c
        if (irad.eq.0) then
          write (msg, 920) iax
920       format ('PIX2WCG: Axis ',i1,' does not appear to have pixel ',
     +            'increments in radians but')
          if (domsg) call bug ('w', msg)
          if (domsg) call bug ('w', 
     +       'PIX2WCG: conversion to "arcsec" requested. Continue '//
     +       'assuming axis in radians')
          warn(11,iax) = .false.
          ok = .false.
        end if
c
        world = (pixel - crpix(iax)) * cdelt(iax)  + crval(iax)
        world = world * r2d
      else
        msg = 'PIX2WCG: '//labtyp(1:len1(labtyp))//
     +        ' is an unrecognized world coordinate type'
        call bug ('f', msg)
      end if
c
      end
c
c* pix2wfcg -- Convert from image pixel to world coordinate and format
c& nebk
c: plotting
c+
      subroutine pix2wfcg (labtyp, iax, pixel, naxis, crval, crpix, 
     +                     cdelt, ctype, nounit, str, ilen)
c
      implicit none
      integer iax, naxis, ilen
      double precision crval(naxis), cdelt(naxis), crpix(naxis), pixel
      character str*(*), labtyp*(*), ctype(*)*(*)
      logical nounit
c
c  Format the specified pixel value in a string according to the
c  specified label type.   If the label type is inconsistent with
c  the axis (e.g. asking for "hms" for a non-RA-like axis),
c  an "abslin" axis type format will result.
c
c Input/output:
c   labtyp Axis label type. May be changed on output to "abslin"
c          if labtyp is incosnistent with ctype
c   iax    Axis of pixel
c   pixel  Absolute pixel value
c   naxis  Number of axes
c   crval  Array of reference values
c   crpix  Array of reference pixels
c   cdelt  Array of pixel increments
c   ctype  Array of axis types
c   nounit If true don't append units to string
c Output:
c   str    Formatted string
c   ilen   Length of str
c--
c-----------------------------------------------------------------------
      double precision world
      character msg*80, labtyp2*6, unit*20, str1*30
      logical ok
      integer len1, il
c
      character*30 dangle, dangleh
c-----------------------------------------------------------------------
c
c Convert absolute pixel to label type coordinate
c
      labtyp2 = labtyp
      call pix2wcg (.false., pixel, iax, labtyp2, naxis, crval, crpix,
     +              cdelt, ctype, world, ok)
c
c Axis type did not match request, give linear instead
c
      if (.not.ok) then
        write (msg, 100) iax
100     format ('PIX2WFCG: type of axis ', i1, ' and requested label')
        call bug ('w', msg)
        call bug ('w', 'PIX2WFCG: do not match.  Use "abslin" instead')
c
        labtyp2 = 'abslin'
        call pix2wcg (.false., pixel, iax, labtyp2, naxis, crval, crpix,
     +                cdelt, ctype, world, ok)
      end if
c
c Format value
c
      if (labtyp2.eq.'abspix' .or. labtyp2.eq.'relpix' .or.
     +    labtyp2.eq.'none') then
        call strfd (world, '(f8.2)', str1, il)
      else if (labtyp2.eq.'abskms' .or. labtyp2.eq.'relkms') then
        call strfd (world, '(1pe12.5)', str1, il)
      else if (labtyp2.eq.'absghz' .or. labtyp2.eq.'relghz') then
        call strfd (world, '(1pe11.5)', str1, il)
      else if (labtyp2.eq.'absdeg' .or. labtyp2.eq.'reldeg') then
        call strfd (world, '(f8.3)', str1, il)
      else if (labtyp2.eq.'arcsec' .or. 
     +         labtyp2.eq.'abslin' .or. labtyp2.eq.'rellin') then
        call strfd (world, '(1pe15.8)', str1, il)
      else if (labtyp2.eq.'hms') then
c
c  Pix2wcg returns RA in seconds of time; dangleh wants hours
c
        world = world / 3600.0d0
c
c Unwrap if necessary
c
        if (world.lt.0.0d0) world = 24.0d0 + world
        str1 = dangleh(world)
        il = len1(str1)
      else if (labtyp2.eq.'dms') then
c
c  Pix2wcg returns DEC in seconds of arc; dangle wants degrees
c
        world = world / 3600.0d0
        str1 = dangle(world)
        il = len1(str1)
      else
        msg = 'PIX2WFCG: '//labtyp2(1:len1(labtyp2))//
     +        ' is an unrecognized world coordinate type'
        call bug ('f', msg)
      end if
c
c Set coordinate units
c
      if (nounit) then
        str = str1(1:il)
      else
        call sunitcg (ctype(iax), labtyp2, unit)
        str = str1(1:il)//' '//unit
      end if
      ilen = len1(str)
c
      end
c
c* pixi2wcg -- Convert pixel increment to the requested world coordinate
c& nebk
c: plotting
c+
      subroutine pixi2wcg (domsg, iax, labtyp, naxis, crval, crpix,
     +                     cdelt, ctype, winc, ok)
c
      implicit none
      integer naxis, iax
      double precision cdelt(naxis), crval(naxis), crpix(naxis), winc
      character labtyp*(*), ctype(naxis)*(*)
      logical ok, domsg
c
c  Convert from image pixel increment to a world coordinate increment,
c  depending on requested type.
c
c  Input:
c    domsg   If true, give a message warning when requested labtyp does 
c            not match the axis type in ctype.
c    iax     This is the axis number in which we are interested. Should
c            be 1, 2 or 3.
c    labtyp  Requested type of world coordinate.   Should be one
c            of   abspix, relpix, arcsec, hms, dms, absghz, relghz,
c                 abskms, relkms, abslin, rellin, none.   Note that a 
c	     request for a linear (abs or rel) axis conversion for an 
c	     RA axis will return the RA in radians of polar rotation. 
c	     That is, the increment will be divided by cos(DEC)
c    naxis   Number of axes in image
c    crval   Array of image reference values
c    crpix   Array of image reference pixels
c    cdelt   Array of image pixel increments
c    ctype   Array of image axis types
c  Output:
c    winc    The pixel increment in the requested world coordinate type
c            For labtyp=hms and labtyp=dms the world coordinate is in 
c            seconds of time and seconds of arc
c    ok      If false, then the requested type is inconsistent with
c            the axis type.  WOrld will have been computed as if
c            the axis type was as expected.
c--
c-----------------------------------------------------------------------
      double precision w1, w2
c----------------------------------------------------------------------------
      call pix2wcg (domsg, 1.0d0, iax, labtyp, naxis, crval,
     +              crpix, cdelt, ctype, w1, ok)
      call pix2wcg (domsg, 2.0d0, iax, labtyp, naxis, crval,
     +              crpix, cdelt, ctype, w2, ok)
      winc = w2 - w1 
c
      end
c
c
c* ppconCG -- Convert unbinned full image pixels to binned subimage pixels
c& nebk
c: plotting
c+
c
      subroutine ppconcg (id, blc, bin, p)
c
      implicit none
      integer id, blc, bin
      double precision p
c    
c  Convert pixel values from a full image unbinned pixel to
c  a subimage binned pixel, and vice versa
c
c  Input
c   id        Direction of convsersion
c                1 -> p      -> pb-sub
c                2 -> pb-sub -> p
c   blc       BLC (in full image unbinned pixels) at which subimage begins
c   bin       Pixel increment with which we are stepping through image
c  Input/output
c   p         Pixel with bin=1 and blc=1 OR pixel appropriate to BIN
c             and BLC
c-----------------------------------------------------------------------
      if (id.eq.1) then
c
c Convert to subimage pixels
c
        p = p - blc + 1
c
c Convert to binned subimage pixel
c
        if (bin.ne.1) p = (p-0.5d0)/dble(bin) + 0.5d0
      else if (id.eq.2) then
c
c Convert to unbinned subimage pixel
c
        if (bin.ne.1) p = dble(bin)*(p-0.5d0) + 0.5d0
c
c Convert to full image unbinned pixel
c
        p = p + blc - 1
      end if
c
      end
c
c* readbCG -- Read in mask image mask
c& nebk
c: plotting
c+
c
      subroutine readbcg (init, lun, ibin, jbin, krng, blc, trc, 
     +                    bimage, blanks)
c
      implicit none
      logical bimage(*)
      integer lun, blc(*), trc(*), ibin(2), jbin(2), krng(2)
      logical blanks, init
c
c  Read in the blanking mask from the specified window from the image
c  When reading more than one plane, the mask image pixel is considered
c  blanked if any of the planes are blanked at that pixel.  When 
c  spatially binning images, a binned pixel is considered blanked if
c  any of the input pixels were blanked.
c
c  Input:
c    init        If true initialize BINMAGE to all good first
c    lun         Handle of image
c    ibin        Increment and average for i direction
c    jbin        Increment and average for j direction
c    krng        First pixel in k direction to read and number of
c                pixels to average
c    blc,trc     Window to read
c  Input/Output
c    blanks      True if there are blanked pixels in bimage
c  Output
c    bimage      Masking image.  True means a good pixel (unflagged) and
c                false means bad (flagged pixel).  Will be bad if any
c                pixel in spectral range is bad for each spatial pixel
c
c--
c------------------------------------------------------------------------
      include 'maxdim.h'
      integer i, j, k, ii, jj, pi, po, kst, kav, kend, io, jo,
     +  nii, nji, nio, njo, no
      logical good(maxdim)
c------------------------------------------------------------------------
c  
c Find size of unbinned and binned image 
c 
      nii = trc(1) - blc(1) + 1
      nji = trc(2) - blc(2) + 1
      if (ibin(2).ne.1) then
        nio = nii / ibin(1) 
      else
        nio = (nii-1)/ibin(1) + 1
      end if
      if (jbin(2).ne.1) then
        njo = nji / jbin(1) 
      else
        njo = (nji-1)/jbin(1) + 1
      end if
c
c Initialize
c
      no = nio * njo
      if (init) then
        do i = 1, no
          bimage(i) = .true.
        end do
        blanks = .false.
      end if
      do i = 1, maxdim
        good(i) = .true.
      end do
c
c Read in plane(s)
c
      kst = krng(1)
      kav = krng(2)
      kend = min(trc(3),kst+kav-1)
c
      do k = kst, kend
        call xysetpl (lun, 1, k)
c
c Step through rows
c
        jo = 1
        do j = 1, nji, jbin(1)
          call xyflgrd (lun, j, good)
c
c Accumulate desired rows
c
          do jj = j, j+jbin(2)-1
            call xyflgrd (lun, jj+blc(2)-1, good)
c
c Step through row
c
            io = 1
            do i = 1, nii, ibin(1)
c 
c Accumulate desired pixels
c
              do ii = i, i+ibin(2)-1
c           
c Input row and output image pointers
c
                pi = ii + blc(1) - 1
                po = (jo-1)*nio + io
c           
c If any pixel in the binned region is bad, set the binned pixel to bad
c
                if (.not.good(pi)) then
                  bimage(po) = .false.
                  blanks = .true.
                end if
              end do
              io = io + 1
            end do
          end do
          jo = jo + 1
        end do
      end do
c
      end
c
c
c* readimCG -- Read in image dealing with averaging and blanking
c& nebk
c: plotting
c+
      subroutine readimcg (init, mask, blank, lun, ibin, jbin, krng, 
     +                     blc, trc, norm, nimage, image, blanks, dmm)
c
      implicit none
      real blank, image(*), dmm(2)
      integer nimage(*), lun, ibin(2), jbin(2), krng(2), blc(3),
     +  trc(3)
      logical blanks, mask, init, norm
c
c  Read in the specified window from the image and apply spatial
c  and spectral binning as desired
c
c  Input:
c    init        True to initialize output array and normalization
c                image first
c    mask        True if blanking mask present
c    blank       Value to use for magic blanking
c    lun         Handle of image
c    ibin        Increment and binning for i direction
c    jbin        Increment and binning for j direction
c    krng        First pixel in k direction to read and number of
c                pixels to average
c    blc,trc     Input window, in unbinned pixels, to read and bin
c    norm        If true, normalize the summed image before
c                exiting.  It is up to you to renitialize at	
c                the appropriate time with INIT on the next call
c  Output
c    nimage      Normalization image; it is the number of pixels
c                that were averaged together at each output pixel 
c                location.  Will be zero for blanked pixels
c    image       Output image (binned, normalized)
c    blanks      True if blanks in output image
c  Input/output
c    dmm         Data min and max so far
c
c--
c------------------------------------------------------------------------
      include 'maxdim.h'
      real row(maxdim)
      logical good(maxdim)
      integer i, j, k, ii, jj, pi, po, kst, kav, kend, io, jo,
     +  nii, nji, nio, njo, no
c------------------------------------------------------------------------
c
c Find size of unbinned and binned images
c
      nii = trc(1) - blc(1) + 1 
      nji = trc(2) - blc(2) + 1
      if (ibin(2).ne.1) then
        nio = nii / ibin(1) 
      else
        nio = (nii-1)/ibin(1) + 1
      end if
      if (jbin(2).ne.1) then
        njo = nji / jbin(1) 
      else
        njo = (nji-1)/jbin(1) + 1
      end if
c
c Initialize
c
      no = nio * njo
      if (init) then
        do i = 1, no
          image(i) = 0.0
          nimage(i) = 0
        end do
        blanks = .false.
      end if
      do i = 1, maxdim
        good(i) = .true.
      end do
c
c Loop over planes
c
      kst = krng(1)
      kav = krng(2)
      kend = min(trc(3),kst+kav-1)
c
      do k = kst, kend
        call xysetpl (lun, 1, k)
c
c Step through rows
c
        jo = 1
        do j = 1, nji, jbin(1)
c
c Accumulate desired rows
c
          do jj = j, j+jbin(2)-1
            call xyread (lun, jj+blc(2)-1, row)
            if (mask) call xyflgrd (lun, jj+blc(2)-1, good)
c
c Step through row
c
            io = 1
            if (ibin(2).eq.1) then
c
c Faster route if no binning
c
              do i = 1, nii, ibin(1)
c
c Input row and output image pointers
c
                pi = i + blc(1) - 1
                po = (jo-1)*nio + io
c
                if (good(pi)) then
                  nimage(po) = nimage(po) + 1
                  image(po) = image(po) + row(pi)
                end if
                io = io + 1
              end do
            else
              do i = 1, nii, ibin(1)
c
c Accumulate desired pixels
c
                do ii = i, i+ibin(2)-1
c
c Input row and output image pointers
c
                  pi = ii + blc(1) - 1
                  po = (jo-1)*nio + io
c
                  if (good(pi)) then
                    nimage(po) = nimage(po) + 1
                    image(po) = image(po) + row(pi)
                  end if
                end do
                io = io + 1
              end do
            end if
          end do
          jo = jo + 1
        end do
      end do
c
c Normalize and blank 
c
      do i = 1, no
        if (nimage(i).ne.0) then
          if (norm) image(i) = image(i) / real(nimage(i))
          dmm(1) = min(dmm(1),image(i))
          dmm(2) = max(dmm(2),image(i))
        else
          blanks = .true.
          image(i) = blank
        end if
      end do
c
      end
c
c* savdesCG --  Save a copy of the axis descriptors
c& nebk
c: plotting
c+
      subroutine savdescg (naxis, ctype, crval, crpix, cdelt, sctype,
     +                   scrval, scrpix, scdelt)
c
      implicit none
      integer naxis
      double precision crval(naxis), cdelt(naxis), crpix(naxis),
     +  scrval(naxis), scdelt(naxis), scrpix(naxis)
      character*(*) ctype(naxis), sctype(naxis)
c
c  Make a copy of the axis descriptors 
c
c  Input
c    naxis     Number of axes
c    c*        Axis descriptors
c  Output
c    cs*       Copy of axis descriptors
c--
c-----------------------------------------------------------------------
      integer i
c-----------------------------------------------------------------------
      do i = 1, naxis
        sctype(i) = ctype(i)
        scrval(i) = crval(i)
        scdelt(i) = cdelt(i)
        scrpix(i) = crpix(i)
      end do
c
      end
c
c* setcolCG --  Set multiple line graphics PGPLOT colours
c& nebk
c: plotting
c+
      subroutine setcolcg (i, icol)
c
      implicit none
      integer i, icol
c
c  Return a PGPLOT colour index given a graph number, where you plan
c  to put many graphs with different colours on the one plot.  The
c  colours are chosen so that similar colours are not consecutive
c
c Input:
c   i      Graph number in the range 1 -> NGRAPH, where NGRAPH is the number
c          of graphs that will be drawn on the one plot
c Output:
c   icol   The colour index to set with PGSCI (ICOL)
c
c--
c-----------------------------------------------------------------------
      integer maxcol 
      parameter (maxcol = 13)
      integer lcols(maxcol), ip
c
      save lcols
      data lcols /2, 7, 5, 3, 1, 6, 8, 12, 4, 10, 11, 9, 13/
c------------------------------------------------------------------------
      ip = mod(i,maxcol)
      if (ip.eq.0) ip = maxcol
      icol = lcols(ip)
c
      end
c
c* setdesCG --  Set axis descriptors fro an image by copying from another
c& nebk
c: plotting
c+
      subroutine setdescg (naxis1, size1, crval1, cdelt1, crpix1, 
     +   ctype1, epoch1, naxis2, size2, crval2, cdelt2, crpix2, 
     +   ctype2, epoch2)
c
      implicit none
      integer naxis1, size1(naxis1), naxis2, size2(naxis1)
      double precision crval1(naxis1), crval2(naxis1),
     +  cdelt1(naxis1), cdelt2(naxis1), crpix1(naxis1), 
     +  crpix2(naxis1)
      real epoch1, epoch2
      character*(*) ctype1(naxis1), ctype2(naxis1)
c
c  Copy axis descriptors from one set to another
c
c--
c-----------------------------------------------------------------------
      integer i
c------------------------------------------------------------------------
      naxis2 = naxis1
      do i = 1, naxis1
        size2(i) = size1(i)
        crval2(i) = crval1(i)
        cdelt2(i) = cdelt1(i)
        crpix2(i) = crpix1(i)
        ctype2(i) = ctype1(i)
      end do
      epoch2 = epoch1
c
      end
c
c* strprpCG -- Prepare string; strip extra white space & delimiter with commas
c& nebk
c: plotting
c+
      subroutine strprpcg (maxloc, aline, comloc, nfield, lena)
c
      implicit none
      character*(*) aline
      integer nfield, maxloc, comloc(maxloc), lena
c
c     Take a string with a number of mixed ascii/numeric fields in it
c     and prepare it for use by stripping out extra white space and
c     replacing the space delimiters by commas (matod needs this).
c
c     Input:
c       maxloc  Maximum number of fields allowed in string
c     Input/output:
c       aline   String
c     Output
c       comloc  Locations along string of comma delimiters for
c               each field.  comloc(1) is the comma between the
c               first and second fields etc
c       nfield  Number of fields in string
c       lena    Length of output string after massaging
c--
c---------------------------------------------------------------------
      integer i, j, lenb, idx
      character bline*132
c
      integer len1
c--------------------------------------------------------------------
c
c Strip leading white space
c
      idx = 1
      do while (aline(idx:idx).eq.' ')
        idx = idx + 1
      end do
      bline = aline(idx:)
      aline = ' '
      aline = bline
c
c Strip additional white space out. Catch cases where commas 
c already the separator too
c
      bline = ' '
      lena = len1(aline)
      bline(1:1) = aline(1:1)
      j = 2
      do i = 2, lena
        if ((aline(i:i).eq.' ' .and. aline(i-1:i-1).eq.' ') .or.
     +      (aline(i:i).eq.' ' .and. aline(i-1:i-1).eq.',')) then
          continue
        else
          bline(j:j) = aline(i:i)
          j = j + 1
        end if
      end do
c
c Replace spaces and colons (which may come from RA or DEC formatted
c strings) by commas (for matodf) and count how many fields there are
c
      lenb = len1(bline)
      nfield = 0
      do i = 1, lenb
        if (bline(i:i).eq.' ' .or. bline(i:i).eq.':' .or.
     +      bline(i:i).eq.',') then
          bline(i:i) = ','
          nfield = nfield  + 1
          if (nfield.gt.maxloc) call bug ('f',
     +      'STRPRPCG: Too many fields for internal storage')
          comloc(nfield) = i
        end if
      end do
      nfield = nfield + 1
      if (bline(lenb:lenb).eq.',') then
        nfield = nfield - 1
        lenb = lenb - 1
      end if
      aline = bline
      lena = lenb
c
      end 
c
c* subincCG -- Step to next sub-plot
c& nebk
c: plotting
c+
      subroutine subinccg (iplot, nx, ny, vxmin, vymax, vxsize, vysize, 
     +                     vxgap, vygap, vx, vy)
c
      implicit none
      real vxmin, vymax, vxsize, vysize, vxgap, vygap, vx, vy
      integer iplot, nx, ny
c
c  Increment view port locations ready for next sub-plot
c 
c  Input
c    iplot    Current sub-plot number
c    nx,ny    Number of sub-plots in x and y directions on view-surface
c    vxmin    minimum x location of encompassing viewport (ndc)
c    vymax    maximum y location of encompassing viewport (ndc)
c    vx,ysize Size of sub-plots on view-surface (ndc)
c    vx,ygap  Gap between sub-plots on the view-surface (ndc)
c  Input/output
c    vx,vy    Location of blc of next sub-plot on view-surface
c--
c-----------------------------------------------------------------------
      if (mod(iplot,nx*ny).eq.0) then
        vx = vxmin
        vy = vymax - vysize
      else if (mod(iplot,nx).eq.0) then
        vx = vxmin
        vy = vy - vygap - vysize
      else
        vx = vx + vxgap + vxsize
      end if
c
      end
c
c
c* sunitCG -- Set axis units given axis type
c& nebk
c: plotting
c+
      subroutine sunitcg (ctype, labtyp, units)
c
      implicit none
      character*(*) labtyp, units, ctype
c
c  Set the units of a pixel based upon the requested labelling
c  type and the axis type.  Used for ascii not graphical output
c  so no PGPLOT escape sequences.
c
c  Inputs:
c    ctype  Axis header CTYPE value
c    labtyp Axis type
c  Output:
c    units  Axis units
c--
c-----------------------------------------------------------------------
      integer ifrq, ivel, irad, iuv
c-----------------------------------------------------------------------
      if (labtyp.eq.'hms' .or. labtyp.eq.'dms') then
        units = ' '
      else if (labtyp.eq.'arcsec') then
        units = 'arcsec'
      else if (labtyp.eq.'absdeg') then
        units = 'degrees'
      else if (labtyp.eq.'reldeg') then
        units = 'offset degrees'
      else if (labtyp.eq.'abspix' .or. labtyp.eq.'none') then
        units = 'pixels'
      else if (labtyp.eq.'relpix') then
        units = 'offset pixels'
      else if (labtyp.eq.'absghz') then
        units = 'GHz'
      else if (labtyp.eq.'relghz') then
        units = 'offset GHz'
      else if (labtyp.eq.'abskms') then
        units = 'Km/s'
      else if (labtyp.eq.'relkms') then
        units = 'offset Km/s'
      else 
        call axfndcg ('RAD',  1, ctype, irad)
        call axfndcg ('FREQ', 1, ctype, ifrq)
        call axfndcg ('VELO', 1, ctype, ivel)
        call axfndcg ('UV',   1, ctype, iuv)
c
        if (labtyp.eq.'abslin') then
          if (irad.eq.1) then
            units = 'radians'
          else if (ifrq.eq.1) then
            units = 'GHz'
          else if (ivel.eq.1) then
            units = 'Km/s'
          else if (iuv.eq.1) then
            units = 'wavelengths'
          else
            units = ' '
          end if
        else if (labtyp.eq.'rellin') then
          if (irad.eq.1) then
            units = 'offset radians'
          else if (ifrq.eq.1) then
            units = 'offset GHz'
          else if (ivel.eq.1) then
            units = 'offset Km/s'
          else if (iuv.eq.1) then
            units = 'offset wavelengths'
          else
            units = 'offset'
          end if
        end if
      end if
c
      end
c
c* wedginCG -- See if grey scale wedges are inside or outside subplots
c& nebk
c: plotting
c+
      subroutine wedgincg (hard, dofid, dowedge, nx, ny, npixr, 
     +                     trfun, wedcod)
c
      implicit none
      logical dowedge, dofid
      integer nx, ny, npixr, wedcod
      character trfun*3, hard*3
c
c Work out whether the grey scale wedges are to be drawn inside
c or outside the subplots, and whether there will be one or many
c  
c Input
c  hard      'YES' if writing to hardcopy PGPLOT device
c  dofid     True if user has requested OFM fiddle option
c  dowedge   True if user requests wedge
c  nx,ny     Number of subplots in x and y directions
c  npixr     NUmber of grey scale "range" groups given by user
c  trfun     Transfer function type of first "range" group
c Output
c wedcod     0 -> No wedges
c            1 -> one wedge to right of all subplots
c            2 -> one wedge to right per subplot
c            3 -> one wedge per subplot inside subplot
c--
c-----------------------------------------------------------------------
      if (.not.dowedge) then
        wedcod = 0
      else      
        if (hard.eq.'YES') then
          if (nx*ny.eq.1) then
            wedcod = 1   
          else
            if (dofid) then
              wedcod = 3
            else
              if (npixr.eq.1 .and. trfun.ne.'heq') then
                wedcod = 1
              else if (ny.gt.1.and.nx.eq.1 .and. ((npixr.eq.1 .and. 
     +                 trfun.eq.'heq') .or. npixr.gt.1)) then
                wedcod = 2
              else
                wedcod = 3
              end if
            end if
          end if
        else
          if (nx*ny.eq.1 .or. (npixr.eq.1 .and. trfun.ne.'heq')) then
              wedcod = 1
          else if (ny.gt.1.and.nx.eq.1 .and. ((npixr.eq.1 .and. 
     +             trfun.eq.'heq') .or. npixr.gt.1)) then
            wedcod = 2
          else 
            wedcod = 3
          end if
        end if
      end if
c
      end
c
c* winfidcg - adjust window size to fit integral number of bins
c& nebk
c: plotting
c+
      subroutine winfidcg (size, axis, bin, blc, trc, win)
      implicit none
      integer axis, bin(2), blc, trc, size, win
c
c     Adjust the size of the window so that the bin width fits
c     an integer number of times 
c
c     Input:
c        size    SIze of total available image
c        axis    Axis number 
c        bin     Pixel increment and binning width across image
c     Input/output
c        blc,trc Window in pixels, adjusted if necessary to fit
c		 an integral number of bins
c     Output
c        win     Size of binned window
c
c--
c-----------------------------------------------------------------------
      integer lo, hi, rem, size2, bin2
      logical new, fail
      character aline*80
c-----------------------------------------------------------------------
c
c Don't fiddle width if no binning, READIMCG and READBCG will cope
c
      if (bin(2).eq.1) then
        win = ((trc-blc+1)-1)/bin(1) + 1
        return
      end if
c
c If the binning width is not unity, the increment must already
c hae been set to the same number
c
      bin2 = bin(2)
      lo = blc
      hi = trc
      new = .false.
      fail = .false.
      size2 = hi - lo + 1
      rem = mod(size2,bin2)
c
c If no adjustement needed, bug out now
c
      if (rem.eq.0) then
        win = (trc-blc+1) / bin2
        return
      end if
c
c Adjust window to fit integral number of bins.  Decrement BLC by 1
c and increment TRC by 1 until ok.
c
      do while (rem.ne.0 .and. .not.fail)
        if (blc.eq.1 .and. trc.eq.size) fail = .true.
c
        if (.not.fail) then
          blc = max(blc-1,1)
          size2 = trc - blc + 1
          rem = mod(size2,bin2)
c
          if (rem.ne.0) trc = min(trc+1,size)
          size2 = trc - blc + 1
          rem = mod(size2,bin2)
c
          new = .true.
        end if
      end do
c
      if (fail) then
c
c We failed by making the window smaller, try making it bigger
c
        size2 = hi - lo + 1
        rem = mod(size2,bin2)
        new = .false.
        fail = .false.
        do while (rem.ne.0 .and. .not.fail)
          if (blc+bin2.gt.trc) fail = .true.
c
          if (.not.fail) then
            blc = blc + 1
            size2 = trc - blc + 1
            rem = mod(size2,bin2)
c
            if (rem.ne.0) trc = trc - 1
            size2 = trc - blc + 1
            rem = mod(size2,bin2)
c
            new = .true.
          end if
        end do
      end if
c
c Tell user what happened
c
      if (fail) then
        write (aline, 50) axis
50      format ('Can''t adjust window to contain',
     +          ' integral no. of bins on axis ', i1)
        call bug ('f', aline)
      else if (new) then
        write (aline, 100) axis, lo, hi, blc, trc, bin(2)
100     format ('Adjusted axis ', i1, ' window from ', i4, ',', i4,
     +          ' to ', i4, ',', i4, ' to fit bin width ',i4)
        call output (aline)
      end if
c
c Size of binned window
c
      win = size2 / bin2
c
      end
c
c* w2pixCG -- Convert world coordinate of given type to image pixels
c& nebk
c: plotting
c+
      subroutine w2pixcg (world, iax, labtyp, naxis, crval, crpix, 
     +                    cdelt, ctype, pixel, ok)
c
      implicit none
      integer naxis, iax
      double precision cdelt(naxis), crval(naxis), crpix(naxis),
     +  world, pixel
      character ctype(naxis)*(*), labtyp*(*)
      logical ok
c
c  Convert world coordinate of given type to image pixels
c
c  Input:
c    world   World coordinate.  
c    iax     This is the axis number in which we are interested. Should
c            be 1, 2 or 3.
c    labtyp  Given type of world coordinate.   Should be one
c            of   abspix, relpix, arcsec, hms, dms, absghz, relghz,
c                 abskms, relkms, abslin, rellin, none.  For RA axes
c            linear coordinates are assumed to be in radians of
c            polar rotation.  For labtyp=hms and labtyp=dms the 
c            world coordinate is in seconds of time and seconds of arc
c    naxis   Number of axes in image
c    crval   Array of image reference values
c    crpix   Array of image reference pixels
c    cdelt   Array of image pixel increments
c    ctype   Array of image axis types
c  Output:
c    pixel   Image pixel
c    ok      If false, the requested type conflicted with the actual
c            axis type.  The pixel was calculated as if there was 
c            no conflict.
c--
c-----------------------------------------------------------------------
      include 'mirconst.h'
      include 'maxnax.h'
      double precision a2r, d2r
      integer max2
c
      parameter (a2r = dpi / (180.0d0 * 3600.0d0), max2 = 9 * maxnax,
     +           d2r = dpi / 180.0d0)
c
      double precision rad, delra, rainc, cosdec
      integer ira, idec, ifrq, ivel, len1, irad
      logical warn(9,maxnax), cdok
      character msg*80
      save warn
      data warn /max2*.true./
c-----------------------------------------------------------------------
      if (iax.lt.1 .or. iax.gt.naxis) 
     +  call bug ('f', 'W2PIXCG: Invalid axis number')
c
      call axfndcg ('RA',   naxis, ctype, ira)
      call axfndcg ('DEC',  naxis, ctype, idec)
      call axfndcg ('FREQ', naxis, ctype, ifrq)
      call axfndcg ('VELO', naxis, ctype, ivel)
      call axfndcg ('RAD', 1, ctype(iax), irad)
      call cosdeccg (iax, naxis, ctype, crval, cosdec, cdok)
c
c Convert to pixels from world coordinate depending upon type
c 
      ok = .true.
      if (labtyp.eq.'abspix' .or. labtyp.eq.'none') then
c
c Absolute pixels ('none' masquerading as 'abspix')
c
        pixel = world
      else if (labtyp.eq.'relpix') then
c
c Relative pixels
c
        pixel = crpix(iax) + world
      else if (labtyp.eq.'arcsec') then
c
c Relative arcseconds
c
        if (irad.eq.0) then
          write (msg, 100) iax
100       format ('W2PIXCG: Axis ', i1, ' is not RA,DEC,LAT,LON but ',
     +            'conversion from "arcsec"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested.  Continue assuming axis in radians')
          warn(1,iax) = .false.
          ok = .false.
        end if
c
        pixel = world * a2r / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'hms') then
c
c HH MM SS.S
c
        if (iax.ne.ira .and. warn(2,iax)) then
          write (msg, 200) iax
200       format ('W2PIXCG: Axis ', i1, ' is not RA but conversion ',
     +            'from "hms"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested.  Continue assuming axis in radians')
          warn(2,iax) = .false.
          ok = .false.
        end if
c
        if (idec.eq.0) call bug ('f', 
     +    'W2PIXCG: No DEC axis found; cannot convert from "hms"')
c
c Convert world coordinate in seconds of time to radians
c
        rad = 15.d0 * world * a2r
c
c Take smallest distance between reference value and location
c
        delra = rad - crval(iax)
        if (abs(delra).gt.dpi) then
          if (delra.gt.0.0) then
            delra = delra - 2.0*dpi
          else
            delra = delra + 2.0*dpi
          end if
        end if
c
c Finally convert to pixels
c
        pixel = delra*cosdec/cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'dms') then
c
c DD MM SS.S
c
        if (iax.ne.idec .and. warn(3,iax)) then
          write (msg, 300) iax
300       format ('W2PIXCG: Axis ', i1, ' is not DEC but conversion ',
     +            'from "dms"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested.  Continue assuming axis in radians')
          warn(3,iax) = .false.
          ok = .false.
        end if
c
        rad = world * a2r
        pixel = (rad-crval(iax))/cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'absghz') then
c
c Absolute frequency
c
        if (iax.ne.ifrq .and. warn(4,iax)) then
          write (msg, 400) iax
400       format ('W2PIXCG: Axis ', i1, 
     +            ' is not FREQ but conversion from "absghz"')
          call bug ('w', msg)
          call bug ('w', 
     +    'W2PIXCG: requested. Continue assuming axis in GHz')
          warn(4,iax) = .false.
          ok = .false.
        end if
        pixel = (world - crval(iax)) / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'relghz') then
c
c Relative frequency
c
        if (iax.ne.ifrq .and. warn(5,iax)) then
          write (msg, 500) iax
500       format ('W2PIXCG: Axis ', i1, 
     +            ' is not FREQ but conversion from "relghz"')
          call bug ('w', msg)
          call bug ('w', 
     +    'W2PIXCG: requested. Continue assuming axis in GHz')
          warn(5,iax) = .false.
          ok = .false.
        end if
        pixel = world / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'abskms') then
c
c Absolute velocity
c
        if (iax.ne.ivel .and. warn(6,iax)) then
          write (msg, 600) iax
600       format ('W2PIXCG: Axis ', i1, 
     +            ' is not VELO but conversion from "abskms"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested. Continue assuming axis in Km/s')
          warn(6,iax) = .false.
          ok = .false.
        end if
        pixel = (world - crval(iax)) / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'relkms') then
c
c Relative velocity
c
        if (iax.ne.ivel .and. warn(7,iax)) then
          write (msg, 700) iax
700       format ('W2PIXCG: Axis ', i1, 
     +            ' is not VELO but conversion from "relkms"')
          call bug ('w', msg)
          call bug ('w', 'W2PIXCG: "relkms" requested. '//
     +                   'Continue assuming axis in Km/s')
          warn(7,iax) = .false.
          ok = .false.
        end if
        pixel = world / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'abslin') then
c
c Absolute linear coordinate.  For RA convert from radians of
c polar rotation.
c
        if (iax.eq.ira .and. idec.eq.0) then
          write (msg, 800) iax
800       format ('PIX2WCG: conversion for RA axis ', i1, 
     +            ' from "abslin" to pixels requested')
          call output (msg)
          msg = 'PIX2WCG: but no DEC axis in image.  Cannot convert'
          call output (msg)
          call bug ('f', ' ')
        end if
c
        rainc = cdelt(iax) / cosdec
        pixel = (world - crval(iax)) / rainc + crpix(iax)
      else if (labtyp.eq.'rellin') then
c
c Relative linear coordinate.  For RA convert from radians of
c polar rotation.
c
        if (iax.eq.ira .and. idec.eq.0) then
          write (msg, 900) iax
900       format ('PIX2WCG: conversion for RA axis ', i1, 
     +            ' from "rellin" to pixels requested')
          call output (msg)
          msg = 'PIX2WCG: but no DEC axis in image.  Cannot convert'
          call output (msg)
          call bug ('f', ' ')
        end if
c
        rainc = cdelt(iax) / cosdec
        pixel = world / rainc + crpix(iax)
      else if (labtyp.eq.'reldeg') then
c
c Relative degrees
c
        if (irad.eq.0) then
          write (msg, 910) iax
910       format ('W2PIXCG: Axis ', i1, ' is not RA,DEC,LON,LAT but ',
     +            'conversion from "reldeg"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested.  Continue assuming axis in radians')
          warn(8,iax) = .false.
          ok = .false.
        end if
c
        pixel = world * d2r / cdelt(iax) + crpix(iax)
      else if (labtyp.eq.'absdeg') then
c
c Absolute degrees 
c
        if (irad.eq.0) then
          write (msg, 920) iax
920       format ('W2PIXCG: Axis ', i1, ' is not RA,DEC,LON,LAT but ',
     +            'conversion from "absdeg"')
          call bug ('w', msg)
          call bug ('w', 
     +      'W2PIXCG: requested.  Continue assuming axis in radians')
          warn(9,iax) = .false.
          ok = .false.
        end if
c
        pixel = (world*d2r - crval(iax)) / cdelt(iax) + crpix(iax)
      else
        msg = 'W2PIXCG: '//labtyp(1:len1(labtyp))//
     +        ' is an unrecognized world coordinate type'
        call bug ('f', msg)
      end if
c
      end
c
c
c* w2wcg -- Convert from world coordinate to world coordinate 
c& nebk
c: plotting
c+
      subroutine w2wcg (domsg, win, iax, typein, typeout, naxis, crval,
     +                  crpix, cdelt, ctype, wout, ok)
c
      implicit none
      integer naxis, iax
      double precision cdelt(naxis), crval(naxis), crpix(naxis),
     +  win, wout
      character typein*(*), typeout*(*), ctype(naxis)*(*)
      logical ok, domsg
c
c  Convert from image world coordinate in one type to another.
c
c  Input:
c    domsg   If true, give a message warning when requested labtyp does 
c            not match the axis type in ctype.
c    win     Input world coordinate.  For typein=hms and typein=dms the 
c            world coordinate is in seconds of time and seconds of arc. For
c	     RA axes linear coordinates are assumed to be in radians of polar
c            rotation.That is, the increment will be divided by cos(DEC)
c    typein  Input world coordinate type.   Should be one
c            of   abspix, relpix, arcsec, hms, dms, absghz, relghz,
c                 abskms, relkms, abslin, rellin, none. 
c    typeout Output world coordinate type
c    iax     This is the axis number in which we are interested. Should
c            be 1, 2 or 3.
c    naxis   Number of axes in image
c    crval   Array of image reference values
c    crpix   Array of image reference pixels
c    cdelt   Array of image pixel increments
c    ctype   Array of image axis types
c  Output:
c    wout    Output world coordinate.  For labtyp=hms and labtyp=dms the 
c            world coordinate is in seconds of time and seconds of arc
c            ready for PGTBOX. A request for a linear (abs or rel) axis 
c	     conversion for an RA axis will return the RA in radians of
c	     polar rotation.  
c    ok      If false, then the requested labtyp is inconsistent with
c            the axis type.  WOrld will have been computed as if
c            the axis type was as expected.
c--
c-----------------------------------------------------------------------
      double precision pixel
c-----------------------------------------------------------------------
      if (typein.eq.'abspix') then
        call pix2wcg (domsg, win, iax, typein, naxis, crval, 
     +                crpix, cdelt, ctype, wout, ok)
      else 
        call w2pixcg (win, iax, typein, naxis, crval, crpix, 
     +                cdelt, ctype, pixel, ok)
        call pix2wcg (domsg, pixel, iax, typeout, naxis, crval, 
     +                crpix, cdelt, ctype, wout, ok)
      end if
c
      end
c
c
c* w2wfcg -- Convert from world coordinate to world coordinate and format
c& nebk
c: plotting
c+
      subroutine w2wfcg (win, iax, typein, typeout, naxis, crval, 
     +                   crpix, cdelt, ctype, nounit, str, ilen)
c
      implicit none
      integer naxis, iax, ilen
      double precision cdelt(naxis), crval(naxis), crpix(naxis), win
      character typein*(*), typeout*(*), ctype(naxis)*(*), str*(*)
      logical nounit
c
c  Convert from image world coordinate in one type to another.
c
c  Input:
c    win     Input world coordinate.  For typein=hms and typein=dms the 
c            world coordinate is in seconds of time and seconds of arc. For
c	     RA axes linear coordinates are assumed to be in radians of polar
c            rotation.That is, the increment will be divided by cos(DEC)
c    typein  Input world coordinate type.   Should be one
c            of   abspix, relpix, arcsec, hms, dms, absghz, relghz,
c                 abskms, relkms, abslin, rellin, none. 
c    typeout Output world coordinate type
c    iax     This is the axis number in which we are interested. Should
c            be 1, 2 or 3.
c    naxis   Number of axes in image
c    crval   Array of image reference values
c    crpix   Array of image reference pixels
c    cdelt   Array of image pixel increments
c    ctype   Array of image axis types
c    nounit  If true don't append units to string
c  Output:
c    str     Output world coordinate in formatted string.
c    ilen    Length of string
c--
c-----------------------------------------------------------------------
      double precision pixel
      logical ok
c-----------------------------------------------------------------------
      call w2pixcg (win, iax, typein, naxis, crval, crpix, 
     +              cdelt, ctype, pixel, ok)
      call pix2wfcg (typeout, iax, pixel, naxis, crval, crpix, 
     +               cdelt, ctype, nounit, str, ilen)
c
      end
c***********************************************************************
c  These subroutines provide an interface between NEBK style coordinate
c  handling (the 'hms', 'dms', 'arcsec', 'reldeg', 'abspix', 'relpix',
c  'absghz', 'relghz', 'abskms', 'relkms', 'abslin', 'rellin', 'none')
c  and RJS' new coordinate routines (co.for).  There are many 
c  similarities with cgsubs.for, but as PGPLOT only handles linear 
c  axes, these must remain until I do something clever.
c
c
c  User callable routines are:
c
c   subroutine initco  (lun)
c   subroutine finco   (lun)
c
c   subroutine ctypeco (lun, n, iax, ctype)
c   subroutine linco   (lun, labtyp, blc, trc, pl1, npl, ctype, crval, 
c                       crpix, cdelt)
c   subroutine setoaco (lun, absoff, n, types)
c   subroutine specco  (lun, iax, stype)
c
c   subroutine w2wco   (lun, n, typei, stypei, win, typeo, stypeo, wout)
c   subroutine w2wfco  (lun, n, typei, stypei, win, typeo, stypeo,
c                       nounit, strout, strlen)
c   subroutine w2wsco  (lun, iax, typei, stypei, win, typeo, stypeo, wout)
c   subroutine w2wsfco (lun, iax, typei, stypei, win, typeo, stypeo,
c                       nounit, strout, strlen)
c
c  History:
c    nebk   18aug94    Initial version
c    nebk   29dec94    Remove concatenated char*(*) in subroutine calls
c
c***********************************************************************
c
      subroutine chkaxco (type, ctype, stype)
c------------------------------------------------------------------------
c  Check axis type and desired coordinate type are compatible.  
c  Note that intrinsically non-linear axes are considered 
c  inconsistent with a "*lin" TYPE (e.g. ra and abslin)
c
c  Input
c    type   Coordinate type user has asked for; one of
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c    ctype  Axis ctype header descriptor
c    stype  Spectral axis descriptor.  If this is ' ', then
c           the CTYPE must match the TYPE (i.e. VELO/abskms is
c           good, FELO/absghz is bad).  Otherwise, it is assumed
c           that the spectral axis is going to be switched to
c           the desired STYPE so that any spectral CTYPE is
c           compatible with any spectral TYPE
c-----------------------------------------------------------------
      implicit none
      character*(*) type, ctype, stype
cc
      character lctype*8, str*132
      logical bad, bads
c-----------------------------------------------------------------
      lctype = ctype
      call ucase (lctype)
      bad = .false.
      bads = .false.
      if (stype.ne.' ' .and. stype.ne.'frequency' .and.
     +    stype.ne.'optical' .and. stype.ne.'radio') then
        str = 'CHKAXCO: invalid spectral axis type ('//stype//') given'
        call bug ('f', str)
      end if
c
      if (type.eq.'hms') then
        if (index(lctype,'RA').eq.0 .and.
     +      index(lctype,'LL').eq.0) bad = .true.
      else if (type.eq.'dms') then
        if (index(lctype,'DEC').eq.0 .and.
     +      index(lctype,'MM') .eq.0) bad = .true.
      else if (type.eq.'arcsec') then
        if (index(lctype,'RA') .eq.0 .and.
     +      index(lctype,'LL') .eq.0 .and.
     +      index(lctype,'DEC').eq.0 .and.
     +      index(lctype,'MM') .eq.0) bad = .true.
      else if (type.eq.'absdeg' .or. type.eq.'reldeg') then
        if (index(lctype,'RA') .eq.0 .and.
     +      index(lctype,'LL') .eq.0 .and.
     +      index(lctype,'DEC').eq.0 .and.
     +      index(lctype,'MM') .eq.0 .and.
     +      index(lctype,'ELON').eq.0 .and.
     +      index(lctype,'GLON').eq.0 .and.
     +      index(lctype,'ELAT').eq.0 .and.
     +      index(lctype,'GLAT').eq.0) bad = .true.
      else if (type.eq.'abskms' .or. type.eq.'relkms') then     
        if (index(lctype,'VELO').eq.0 .and.
     +      index(lctype,'FELO').eq.0 .and.
     +      index(lctype,'FREQ').eq.0) bad = .true.
            if (index(lctype,'FREQ').ne.0 .and. 
     +         stype.eq.' ') bads = .true.
      else if (type.eq.'absghz' .or. type.eq.'relghz') then     
        if (index(lctype,'FREQ').eq.0 .and.
     +      index(lctype,'VELO').eq.0 .and.
     +      index(lctype,'FELO').eq.0) bad = .true.
            if ((index(lctype,'VELO').ne.0 .or. 
     +           index(lctype,'FELO').ne.0) .and.
     +         stype.eq.' ') bads = .true.
      else if (type.eq.'abslin' .or. type.eq.'rellin') then
        if (index(lctype,'RA')  .ne.0 .or.
     +      index(lctype,'LL')  .ne.0 .or.
     +      index(lctype,'DEC') .ne.0 .or.
     +      index(lctype,'MM')  .ne.0 .or.
     +      index(lctype,'ELON').ne.0 .or.
     +      index(lctype,'GLON').ne.0 .or.
     +      index(lctype,'ELAT').ne.0 .or.
     +      index(lctype,'GLAT').ne.0 .or.
     +      index(lctype,'FELO').ne.0) bad = .true.
      end if
c
c Bug out if no good
c
      if (bad .or. bads) then
        call output ('Axis ctype = '//lctype)
        str = 'Coordinate type = '//type
        call output (str)
        if (bads) then
          if (stype.eq.' ') then
            call output ('Spectral axis convention unspecified')
          else
            str = 'Spectral axis convention = '//stype
            call output (str)
          end if
        end if
        call bug ('f', 'CHKAXCO: These are inconsistent')
      end if
c
      end
c
c* ctypeco -- Return one or several axis CTYPE descriptors
c& nebk
c: coordinates
c+
c
      subroutine ctypeco (lun, n, iax, ctype)
      implicit none
c
      integer iax, lun, n
      character*(*) ctype(*)
c
c     Return ctypes for several or one axis
c
c  Input
c    lun    Handle
c    n      If 0, just return the values for IAX, else return N values
c    iax    Axis
c  Output
c    ctype  CTYPE (upper case)
c--
c-----------------------------------------------------------------------
      double precision crval, crpix, cdelt
      integer i
c-----------------------------------------------------------------------
      if (n.le.0) then
        call coaxdesc (lun, iax, ctype(1), crpix, crval, cdelt)
        call ucase (ctype(1))
      else
        do i = 1, n
          call coaxdesc (lun, i, ctype(i), crpix, crval, cdelt)
          call ucase (ctype(i))
        end do
      end if
c
c
      end
c
c* finco -- Finish up after coordinate conversion routines
c& nebk
c: coordinates
c+
      subroutine finco (lun)
      implicit none
c
      integer lun
c
c     Tidy up after coordinate conversion routines have been accessed
c
c  Input
c    lun    Handle of image
c--
c-----------------------------------------------------------------------
      call cofin (lun)
c
      end
c
c* initco -- Initialize coordinate conversion routines
c& nebk
c: coordinates
c+
      subroutine initco (lun)
      implicit none
c
      integer lun
c
c     Initialize coordinate conversion routine
c
c  Input
c    lun    Handle of image
c--
c-----------------------------------------------------------------------
      call coinit (lun)
c
      end
c
c
c* linco -- Make linear aproximation of axis descriptors at subimage centre
c& nebk
c: coordinates
c+
      subroutine linco (lun, labtyp, blc, trc, pl1, npl, ctype, 
     +                  crval, crpix, cdelt)
      implicit none
c
      integer lun, blc(2), trc(2), pl1, npl
      double precision crval(2), crpix(2), cdelt(2)
      character*(*) ctype(2), labtyp(2)
c
c     CG* programs do not yet fully handle non-linear coordinate
c     systems.  This subroutine converts the axis descriptors 
c     which make a linear approximation at the reference pixel
c     to a linear approximation at some other pixel.    If the
c     user wants an axis in pixels or relative pixels, no change
c     is made as it is a) unnecessary and b) the reference pixel 
c     is changed in the recomputation.
c
c     Because the CG programs can display multi-panel plots, really,
c     each subplot should be dealt with separately, with the linear
c     approximation made for each subplot depending upon the value
c     of the third axis. I.e.,  the spatial CDELTS depend upon the
c     frequency of the channel.  However, this is TOO big a headache
c     for me.  Instead, the linear approximation is made for the
c     value of the third axis appropriate to the first sub-plot
c     displayed
c
c  Input
c   lun      Handle of image
c   labtyp   Axis labels ('hms' 'dms' etc)
c   blc,trc  Window on first two axes that user wants to display in 
c            absolute pixels
c   pl1      FIrst channel user wants to display
c   npl      Number of channels to average together in first
c            displayed subplot
c  Input/output
c   c*       Axis descriptors.  Only axes 1 and 2 are changed as
c            the CG programs don't use those from axis 3 directly.
c
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      double precision win(maxnax), crval1(maxnax), crpix1(maxnax), 
     +  cdelt1(maxnax)
      character ctype1(maxnax)*9, cti*21
      integer i, naxis, n, ip
c-----------------------------------------------------------------------
c
c See if we have something to do
c
      if (labtyp(1)(4:6).eq.'pix' .and. labtyp(2)(4:6).eq.'pix') return
c_lss fudge to bypass this for p-v diagrams
      if (labtyp(1)(4:6).eq.'deg' .or. labtyp(2)(4:6).eq.'deg') return
c
c Prepare absolute pixel of centre of sub-image
c
      cti = ' '
      ip = 1
      do i = 1, 2
        win(i) = (blc(i)+trc(i))/2.0
        cti(ip:) = 'ap/'
        ip = ip + 3
      end do
c
c If there is a third axis, set pixel appropriate to first subplot 
c
      call rdhdi (lun, 'naxis', naxis, 0)
      if (naxis.gt.2) then
        win(3) = dble(2*pl1+npl-1)/2.0
        cti(ip:) = 'ap'
      end if
      n = min(naxis,3)
c
c Linearize axis descriptors
c
      call coinit (lun)
      call colin (lun, cti, win, n, ctype1, crpix1, crval1, cdelt1)
      call cofin (lun)
c
c Overwrite the appropriate axis descriptors.  The descriptors  for the third
c axis are never directly used by the CG programs so don't bother with them
c
      do i = 1, 2
        if (labtyp(i)(4:6).ne.'pix') then
          ctype(i) = ctype1(i)
          crval(i) = crval1(i)
          crpix(i) = crpix1(i)
          cdelt(i) = cdelt1(i)
        end if
      end do
c
      end
c
c
      subroutine sctico (type, win, cti)
c-----------------------------------------------------------------------
c     This subroutine takes an NEBK style coordinate type descriptor,
c     and generates an RJS type coordinate descriptor making the
c     appropriate conversion to radians for angular coordinates
c     where needed ready for cocvt
c
c  Input
c    type   NEBK style type of world coordinate; one of
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c  Input/output
c    win    Coordinate value.  Any coordinate of an angular type
c           (hms, dms, *deg, arcsec) will be in radians on output
c  Output
c    cti    RJS style coordinate type ('ap', 'op', 'aw', 'ow')
c-----------------------------------------------------------------------
      implicit none
      character*(*) type, cti
      double precision win
cc
      include 'mirconst.h'
      double precision a2r, d2r
      parameter (a2r = dpi/180.0d0/3600.0d0, d2r = dpi/180.0d0)
      character*132 str
c-----------------------------------------------------------------------
c
c Set coordinate conversion string and convert units to radian
c where needed
c
      cti = ' '
c
      if (type.eq.'hms' .or. type.eq.'dms') then
        cti = 'aw'
      else if (type.eq.'abspix' .or. type.eq.'none') then
        cti = 'ap'
      else if (type.eq.'relpix') then
        cti = 'op'
      else if (type.eq.'arcsec') then
        cti = 'ow'
        win = win * a2r
      else if (type.eq.'absghz' .or. type.eq.'abskms' .or.
     +         type.eq.'abslin') then
        cti = 'aw'
      else if (type.eq.'relghz' .or. type.eq.'relkms' .or. 
     +         type.eq.'rellin') then
        cti = 'ow'
      else if (type.eq.'absdeg') then
        cti = 'aw'
        win = win * d2r
      else if (type.eq.'reldeg') then
        cti = 'ow'
        win = win * d2r
      else
        str = 'SCTICO: Unrecognized axis type ('//type//')'
        call bug ('f', str)
      end if
c
      end
c
c
      subroutine sctoco (type, wout)
c-----------------------------------------------------------------------
c     Convert an angular coordinate after it has been returned by 
c     RJS' cocvt into the units appropriate to NEBK style coordinates.  
c
c  Input 
c    type   NEBK style type of world coordinate that we want
c           to convert to;
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c  Input/output
c    wout   Coordinate value.  On input, all angular coordiantes are
c           in radians, on exit, 'arcsec' in arcsec, '*deg" in degrees
c
c-----------------------------------------------------------------------
      implicit none
      character*(*) type
      double precision wout
cc
      include 'mirconst.h'
      double precision r2a, r2d
      parameter (r2a = 180.0d0*3600.0d0/dpi, r2d = 180.0d0/dpi)
c-----------------------------------------------------------------------
      if (type.eq.'arcsec') then
        wout = wout * r2a
      else if (type.eq.'absdeg' .or. type.eq.'reldeg') then
        wout = wout * r2d
      end if
c
      end
c
c
c* setoaco -- Set default (offset) coordinate type depending on CTYPE
c& nebk
c: coordinates
c+
      subroutine setoaco (lun, absoff, n, types)
      implicit none
c
      integer n, lun
      character*(*) types(n), absoff*3
c
c     Set a string dictating what units the coordinate will
c     be presented in
c
c  Input
c    lun      Image handle
c    absoff   'abs' or 'off' for absolute of offset world coordinate
c    n        Number of axes
c  Output
c    types    Desired NEBK style coordinate types.  One of
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'absghz', 'relghz', 'abskms', 'relkms', 'abslin',
c               'rellin', 'none'
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      integer i
      character*9 lctype
c-----------------------------------------------------------------------
      do i = 1, n
c
c Get CTYPE for this axis
c
        call ctypeco (lun, 0, i, lctype)
c
c Set default
c
        if (index(lctype,'RA') .ne.0 .or.
     +      index(lctype,'LL') .ne.0 ) then
          if (absoff.eq.'off') then
            types(i) = 'arcsec'
          else
            types(i) = 'hms'
          end if
        else if (index(lctype,'DEC').ne.0 .or.
     +           index(lctype,'MM') .ne.0) then
          if (absoff.eq.'off') then
            types(i) = 'arcsec'
          else
            types(i) = 'dms'
          end if
        else if (index(lctype,'ELON').ne.0 .or.
     +           index(lctype,'GLON').ne.0 .or.
     +           index(lctype,'ELAT').ne.0 .or.
     +           index(lctype,'GLAT').ne.0) then
          if (absoff.eq.'off') then
            types(i) = 'reldeg'
          else
            types(i) = 'absdeg'
          end if
        else if (index(lctype,'VELO').ne.0) then
          if (absoff.eq.'off') then
            types(i) = 'relkms'
          else
            types(i) = 'abskms'
          end if
        else if (index(lctype,'FELO').ne.0) then
          if (absoff.eq.'off') then
            types(i) = 'relkms'
          else
            types(i) = 'abskms'
          end if
        else if (index(lctype,'FREQ').ne.0) then
          if (absoff.eq.'off') then
            types(i) = 'relghz'
          else
            types(i) = 'absghz'
          end if
        else
          if (absoff.eq.'off') then
            types(i) = 'rellin'
          else
            types(i) = 'abslin'
          end if
        end if
      end do
c
      end
c
c
c* specco -- See if this axis is spectral and what type it is
c& nebk
c: coordinates
c+
      subroutine specco (lun, iax, stype)
      implicit none
c
      integer lun, iax
      character*(*) stype
c
c     See if this axis is a spectral one and what type if it is
c
c  Input
c    lun    Handle of image
c    iax    Axis number
c  Output:
c    stype  ' ' if not spectral, else 'radio', 'optical', 'frequency'
c--
c-----------------------------------------------------------------------
      character*9 ctype
c-----------------------------------------------------------------------
      call ctypeco (lun, 0, iax, ctype)
      if (index(ctype,'VELO').ne.0) then
        stype = 'radio'
      else if(index(ctype,'FELO').ne.0) then
        stype = 'optical'
      else if(index(ctype,'FREQ').ne.0) then
        stype = 'frequency'
      else
        stype = ' '
      end if
c
      end
c
c
      subroutine sunitco (ctype, type, units)
c----------------------------------------------------------------------
c  Set the units of a pixel based upon the requested type and the 
c  axis type.  Used for ascii not graphical output so no PGPLOT escape 
c  sequences.
c
c  Inputs:
c    ctype  Axis header CTYPE value
c    type   User requested coordinate type
c  Output:
c    units  Axis units
c--
c-----------------------------------------------------------------------
      implicit none
      character*(*) type, units, ctype
cc
      character units2*10, str*132
c-----------------------------------------------------------------------
      if (type.eq.'hms' .or. type.eq.'dms' .or. type.eq.'none') then
        units = ' '
      else if (type.eq.'arcsec') then
        units = 'arcsec'
      else if (type.eq.'absdeg') then
        units = 'degrees'
      else if (type.eq.'reldeg') then
        units = 'offset degrees'
      else if (type.eq.'abspix') then
        units = 'pixels'
      else if (type.eq.'relpix') then
        units = 'offset pixels'
      else if (type.eq.'absghz') then
        units = 'GHz'
      else if (type.eq.'relghz') then
        units = 'offset GHz'
      else if (type.eq.'abskms') then
        units = 'Km/s'
      else if (type.eq.'relkms') then
        units = 'offset Km/s'
      else if (type.eq.'abslin' .or. type.eq.'rellin') then
        if (index(ctype,'VELO').ne.0 .or.
     +      index(ctype,'FELO').ne.0) then
          units2 = 'Km/s'
        else if (index(ctype,'FREQ').ne.0) then
          units2 = 'GHz'
        else if (index(ctype,'UU').ne.0 .or.
     +           index(ctype,'VV').ne.0) then
          units = 'wavelengths'
        else
c
c Note that non-linear axes, such as RA/DEC, should already have given
c a fatal error if "abslin" or "rellin" requested (in CHKAXCO)
c
          units2 = '??'
        end if
c
        if (type.eq.'abslin') then
          units = units2
        else if (type.eq.'rellin') then
          units = 'offset '//units2
        end if
      else
        str = 'SUNITCO: Unrecognized coordinate type ('//type//')'
        call bug ('f', str)
      end if
c
      end
c
c
c* w2wco -- Convert an array of coordinates
c& nebk
c: coordinates
c+
      subroutine w2wco (lun, n, typei, stypei, win, typeo, stypeo, wout)
      implicit none
c
      integer lun, n
      double precision win(n), wout(n)
      character*(*) typei(n), typeo(n), stypei, stypeo
c
c  Convert an array of NEBK style coordinates with the COCVT routines.
c
c  Input
c    lun     Handle of open file
c    n       Number of axes to convert
c    typei   Array of input coordinate types, Should be from list
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c    stypei  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is in,
c            regardless of what the header initially defines. If ' ',
c            then it assumed to be as the header defines unless
c            there is a mismatch between TYPEI and CTYPE for that axis
c            (e.g. absghz/VELO-LSR) wherupon a fatal error will result
c    win     Array of coordinates to be converted
c               'hms', 'dms' in radians
c               '*  deg'     in degrees
c               'arcsec'     in arcsec
c               '*  pix'     in pixels
c               '*  ghz'     in GHz
c               '*  kms'     in Km/s
c               '*  lin'     in natural linear axis coordinates
c    typeo   Array of output coordinate types from above list
c            requested.
c    stypeo  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is to be
c            converted to, regardless of what the header defined.
c            If ' ', then it assumed the coordinate is in the convention
c            indicated by STYPEI.  If STYPEI is blank too, then
c            CTYPE of the header and TYPEO must match or a fatal
c            error will result
c  Output
c    wout    Array of converted output coordinates in same units
c            as described above
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      integer i, ip
      character cti*21, cto*21, str*2 
      character*9 ctype, sstype, lstype
      double precision wloc(maxnax), xdum
      logical done, nix(maxnax), none
c-----------------------------------------------------------------------
c
c There maybe nothing to do for some axes.  Make sure we just
c copy the coordinates in these cases, rather than converting
c to and from pixels, thus losing precision. Save initial spectral
c convention while we are it.
c
      none = .true.
      sstype = ' '
      do i = 1, n
        nix(i) = .false.
        call specco (lun, i, lstype)
        if (lstype.ne.' ') sstype = lstype
c
        if (typei(i).eq.typeo(i)) then
          if (lstype.ne.' ') then
            if (stypei.eq.stypeo .or. typei(i)(4:6).eq.'pix')
     +        nix(i) = .true.
          else
            nix(i) = .true.
          end if
        end if
        if (.not.nix(i)) none = .false.
      end do
      if (none) then
        do i = 1, n
          wout(i) = win(i)
        end do
        return
      end if
c
c Switch spectral axis if required to type of input coordinate and
c fish out the CTYPES
c
      if (sstype.ne.' ' .and. stypei.ne.' ')
     +  call covelset (lun, stypei)
c
c Convert coordinates to absolute pixels first; loop over axes
c
      cti = '  '
      cto = '  '
      ip = 1
      do i = 1, n
c
c Check input coordinate type consistent with actual axis type
c
        call ctypeco (lun, 0, i, ctype)
        call chkaxco (typei(i), ctype, stypei)
c
c Set coordinate transformation strings and convert angular
c units if required to radians
c
        wloc(i) = win(i)
        call sctico (typei(i), wloc(i),  str)
        cti(ip:ip+2) = str//'/'
        cto(ip:ip+2) = 'ap/'
        ip = ip + 3
      end do
c
c Now convert to pixels (pixels being converted to pixels here
c will be done with no loss of precision so don't bother with
c extra code to trap it
c
      call cocvt (lun, cti, wloc, cto, wout)
c
c Now check that we need to go on.  The user may want absolute
c pixels whereupon we are done.  Note that absolute pixels
c are the same regardless of the spectral convention !
c
      done = .true.
      do i = 1, n
        if (typeo(i).ne.'abspix') done = .false.
      end do
c
      if (.not.done) then
c
c Having turned the coordinate into a pixel, we can now convert
c it to the desired output coordinate type.  First, once again
c switch the spectral axis if needed.
c
        if (sstype.ne.' ' .and. stypeo.ne.' ') 
     +    call covelset (lun, stypeo)
c
c Loop over axes 
c
        cti = '  '
        cto = '  '
        ip = 1
        do i = 1, n
c
c Check output coordinate type consistent with actual axis type
c
          call ctypeco (lun, 0, i, ctype)
          call chkaxco (typeo(i), ctype, stypeo)
c
c Set coordinate transformation strings
c
          wloc(i) = wout(i)
          call sctico (typeo(i), xdum, str)
          cti(ip:ip+2) = 'ap/'
          cto(ip:ip+2) = str//'/'
          ip = ip + 3
        end do
c
c Now convert the absolute pixels to the desired coordinate type
c
        call cocvt (lun, cti, wloc, cto, wout)
c
c Now we must convert (some of the) coordinates given in radians to the 
c appropriate output units (degrees, arcsec etc)
c
        do i = 1, n
          call sctoco (typeo(i), wout(i))
        end do
      end if
c
c Overwrite any coordinates that did not really need converting
c by the input values to improve precision
c
      do i = 1, n
        if (nix(i)) wout(i) = win(i)
      end do
c
c Restore initial spectral axis convention to common held header
c
      if (sstype.ne.' ') call covelset (lun, sstype)
c
      end
c
c
c* w2wfco -- Convert an array of coordinates and format 
c& nebk
c: coordinates
c+
      subroutine w2wfco (lun, n, typei, stypei, win, typeo, stypeo,
     +                   nounit, strout, strlen)
      implicit none
c
      integer lun, n, strlen(n)
      double precision win(n)
      character*(*) typei(n), typeo(n), strout(n), stypei, stypeo
      logical nounit
c
c  Convert an array of NEBK style coordinates with the COCVT routines 
c  and format the results with units into strings
c
c  Input
c    lun     Handle of open file
c    n       Number of axes
c    typei   Array of input coordinate types, Should be from list
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c    stypei  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is in,
c            regardless of what the header initially defines. If ' ',
c            then it assumed to be as the header defines unless
c            there is a mismatch between TYPEI and CTYPE for that axis
c            (e.g. absghz/VELO-LSR) wherupon a fatal error will result
c    win     Array of coordinates to be converted
c               'hms', 'dms' in radians
c               '*  deg'     in degrees
c               'arcsec'     in arcsec
c               '*  pix'     in pixels
c               '*  ghz'     in GHz
c               '*  kms'     in Km/s
c               '*  lin'     in natural linear axis coordinates
c    typeo   Array of output coordinate types from above list
c            requested.
c    stypeo  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is to be
c            converted to, regardless of what the header defined.
c            If ' ', then it assumed the coordinate is in the convention
c            indicated by STYPEI.  If STYPEI is blank too, then
c            CTYPE of the header and TYPEO must match or a fatal
c            error witll result
c    nounit  Don't append units
c  Output
c    strout  Array of formatted converted output coordinates
c    strlen  Length of strings in STROUT
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      double precision wout(maxnax)
      character*30 rangle, hangleh, units
      character ctype*9, str*132
      integer i, len1
c-----------------------------------------------------------------------
c
c Convert coordinates
c
      call w2wco (lun, n, typei, stypei, win, typeo, stypeo, wout)
c
c Format results
c
      do i = 1, n
        strout(i) = ' '
        if (typeo(i).eq.'abspix' .or. typeo(i).eq.'relpix' .or.
     +      typeo(i).eq.'none') then
          call strfd (wout(i), '(f9.2)', strout(i), strlen(i))
        else if (typeo(i).eq.'abskms' .or. typeo(i).eq.'relkms') then
          call strfd (wout(i), '(1pe12.5)', strout(i), strlen(i))
        else if (typeo(i).eq.'absghz' .or. typeo(i).eq.'relghz') then
          call strfd (wout(i), '(1pe15.8)', strout(i), strlen(i))
        else if (typeo(i).eq.'absdeg' .or. typeo(i).eq.'reldeg') then
          call strfd (wout(i), '(f8.3)', strout(i), strlen(i))  
        else if (typeo(i).eq.'arcsec') then
          call strfd (wout(i), '(1pe15.8)', strout(i), strlen(i))
        else if (typeo(i).eq.'abslin' .or. typeo(i).eq.'rellin') then
          call strfd (wout(i), '(1pe15.8)', strout(i), strlen(i))
        else if (typeo(i).eq.'hms') then
          strout(i) = hangleh(wout(i))
          strlen(i) = len1(strout(i))
        else if (typeo(i).eq.'dms') then
          strout(i) = rangle(wout(i))
          strlen(i) = len1(strout(i))
        else
          str = 'W2WFCO: Unrecognized coordinate type ('//typeo(i)//')'
          call bug ('f', str)
        end if
c
c Work out units
c
        if (.not.nounit) then
          call ctypeco (lun, 0, i, ctype)
          call sunitco (ctype, typeo(i), units)
c
c Add units to formatted number
c
          strout(i)(strlen(i)+2:) = units
          strlen(i) = len1(strout(i))
        end if
      end do
c
      end
c
c
c* w2wsco -- Convert NEBK style coordinate for a single axis
c& nebk
c: coordinates
c+
      subroutine w2wsco (lun, iax, typei, stypei, win, typeo, stypeo,
     +                   wout)
      implicit none
c
      integer lun, iax
      double precision win, wout
      character*(*) typei, typeo, stypei, stypeo
c
c  Convert one NEBK style coordinate with the COCVT routines.
c  Coordinates for the other axes are assumed to be at the
c  reference pixel
c
c  Input
c    lun     Handle of open file
c    iax     Axis
c    typei   Input coordinate type, Should be from list
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c    stypei  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is in,
c            regardless of what the header initially defines. If ' ',
c            then it assumed to be as the header defines unless
c            there is a mismatch between TYPEI and CTYPE for that axis
c            (e.g. absghz/VELO-LSR) wherupon a fatal error will result
c    win     Coordinate to be converted
c               'hms', 'dms' in radians
c               '*  deg'     in degrees
c               'arcsec'     in arcsec
c               '*  pix'     in pixels
c               '*  ghz'     in GHz
c               '*  kms'     in Km/s
c               '*  lin'     in natural linear axis coordinates
c    typeo   Output coordinate type from above list
c    stypeo  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is to be
c            converted to, regardless of what the header defined.
c            If ' ', then it assumed the coordinate is in the convention
c            indicated by STYPEI.  If STYPEI is blank too, then the
c            CTYPE of the header and TYPEO must match or a fatal
c            error will result
c  Output
c    wout    Converted output coordinate
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      character*6 ltypei(maxnax), ltypeo(maxnax)
      double precision lwin(maxnax), lwout(maxnax)
      integer i
c-----------------------------------------------------------------------
c
c Load reference pixel for dummy locations
c
      do i = 1, maxnax
        ltypei(i) = 'relpix'
        lwin(i) = 0.0d0
        ltypeo(i) = 'relpix'
      end do
c
c Load axis of interest
c
      ltypei(iax) = typei
      lwin(iax) = win
      ltypeo(iax) = typeo
c
c Convert
c
      call w2wco (lun, maxnax, ltypei, stypei, lwin, ltypeo, 
     +            stypeo, lwout)
c
c Fish out axis
c
      wout = lwout(iax)
c
      end
c
c
c* w2wfsco -- Convert a coordinate for a single axis and format 
c& nebk
c: coordinates
c+
      subroutine w2wsfco (lun, iax, typei, stypei, win, typeo, stypeo,
     +                    nounit, strout, strlen)
      implicit none
c
      integer lun, iax, strlen
      double precision win
      character*(*) typei, typeo, strout, stypei, stypeo
      logical nounit
c
c  Convert one NEBK style coordinate with the COCVT routines and format
c  into a string.  Coordinates for the other axes are assumed to be at the
c  reference pixel
c
c  Input
c    lun     Handle of open file
c    iax     Axis of interest
c    typei   Coordinate type, should be from list
c	        'hms',    'dms',    'arcsec', 'absdeg', 'reldeg',
c               'abspix', 'relpix', 'absghz', 'relghz', 'abskms', 
c               'relkms', 'abslin', 'rellin', 'none'
c    stypei  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is in,
c            regardless of what the header initially defines. If ' ',
c            then it assumed to be as the header defines.
c    win     Coordinate to be converted
c               'hms', 'dms' in radians
c               '*  deg'     in degrees
c               'arcsec'     in arcsec
c               '*  pix'     in pixels
c               '*  ghz'     in GHz
c               '*  kms'     in Km/s
c    typeo   Output coordinate type from above list
c    stypeo  'radio', 'optical', 'frequency'.  If a spectral coordinate
c            is given, this indicates what convention it is to be
c            converted to, regardless of what the header defined.
c            If ' ', then it assumed the coordinate is in the convention
c            indicated by STYPEI
c    nounit  Don't append units
c  Output
c    strout  Formatted converted output coordinate
c    strlen  Length of string in STROUT
c--
c-----------------------------------------------------------------------
      include 'maxnax.h'
      double precision lwin(maxnax)
      character*6 ltypei(maxnax), ltypeo(maxnax)
      character*50 lstrout(maxnax)
      integer i, lstrlen(maxnax)
c-----------------------------------------------------------------------
c
c Load dummy array values and actual value into conversion arrays
c
      if (iax.le.0)  call bug ('f', 'W2WSFCO: invalid axis number')
      do i = 1, maxnax
        lwin(i) = 0.0
        ltypei(i) = 'relpix'
        ltypeo(i) = 'relpix'
      end do
      lwin(iax) = win
      ltypei(iax) = typei
      ltypeo(iax) = typeo
c
c Convert and format
c
      call w2wfco (lun, iax, ltypei, stypei, lwin, ltypeo, stypeo, 
     +             nounit, lstrout, lstrlen)
c
c Return formatted string
c
      strout = lstrout(iax)
      strlen = lstrlen(iax)
c
      end
c
c  Overlays an RA/DEC coordinate grid on a cgdisp plot
c
      subroutine mygrid(lg,blc,trc,xxopts,yyopts)
      integer i,j,lg,lw,blc(*),trc(*)
      double precision pixblc(3),pixtrc(3),pixbrc(3),pixtlc(3)
      double precision wocblc(3),woctrc(3),wocbrc(3),woctlc(3)
      double precision r2s,r2r,xd(3),pd(3)
      real wold(4),wnew(4),xinc,yinc,xline(0:100),yline(0:100)
      real ramin,ramax,decmin,decmax
      character*(*) xxopts,yyopts
      include 'mirconst.h'
      parameter ( r2s=3600.0*180.0/dpi )
      parameter ( r2r=r2s/15.0 )
      common /myticks/ xtickd,ytickd
c
c  Keep nebk linearized world coordinate environment
c
      call pgqwin(wold(1),wold(2),wold(3),wold(4))
      call pgqlw(lw)
c
c  Convert pixel coordinates of 4 corners into RA, DEC
c
      pixblc(1)=dble(blc(1)-0.5)
      pixtrc(1)=dble(trc(1)+0.5)
      pixbrc(1)=dble(trc(1)+0.5)
      pixtlc(1)=dble(blc(1)-0.5)
      pixblc(2)=dble(blc(2)-0.5)
      pixtrc(2)=dble(trc(2)+0.5)
      pixbrc(2)=dble(blc(2)-0.5)
      pixtlc(2)=dble(trc(2)+0.5)
      pixblc(3)=dble(blc(3))
      pixtrc(3)=dble(trc(3))
      pixbrc(3)=dble(blc(3))
      pixtlc(3)=dble(blc(3))
      xd(3)=dble(blc(3))
      pd(3)=dble(blc(3))
c
c  Initialize coordinate converter
c
      call coinit(lg)
c
c  Convert
c
      call cocvt(lg,'ap/ap/ap',pixblc,'aw/aw/ap',wocblc)
      call cocvt(lg,'ap/ap/ap',pixbrc,'aw/aw/ap',wocbrc)
      call cocvt(lg,'ap/ap/ap',pixtlc,'aw/aw/ap',woctlc)
      call cocvt(lg,'ap/ap/ap',pixtrc,'aw/aw/ap',woctrc)
c
c  Ensure that blc has a higher RA than brc
c
      if (wocblc(1).lt.wocbrc(1)) then
         wocblc(1)=wocblc(1)+dtwopi
      end if
c
c  Set the new world coordinate window
c
      wnew(1)=wocblc(1)*r2r
      wnew(2)=wocbrc(1)*r2r
      wnew(3)=wocblc(2)*r2s
      wnew(4)=woctlc(2)*r2s
      call pgswin(wnew(1),wnew(2),wnew(3),wnew(4))
c
c  Draw and label the image
c
      call pgtbox (xxopts, 0.0, 0, yyopts, 0.0, 0)
c
c  Use thin lines for coordinate grid
c
      call pgslw(1)
c
c  Find minimum and maximum RA,DEC from positions of corners
c
      decmin=pi/2.0
      decmax=-pi/2.0
      ramin=2.0*pi
      ramax=0.0
      decmin=min(decmin,wocblc(2))
      decmin=min(decmin,wocbrc(2))
      decmax=max(decmax,woctlc(2))
      decmax=max(decmax,woctrc(2))
      ramin=min(ramin,wocbrc(1))
      ramin=min(ramin,woctrc(1))
      ramax=max(ramax,wocblc(1))
      ramax=max(ramax,woctlc(1))
c
c  Allow a small guard band
c
      ramin=ramin-0.2*(ramax-ramin)
      ramax=ramax+0.2*(ramax-ramin)
      decmin=decmin-0.2*(decmax-decmin)
      decmax=decmax+0.2*(decmax-decmin)
c
c  Draw lines in "pixel" space
c
      call pgswin(real(blc(1)-0.5),real(trc(1)+0.5),
     1     real(blc(2)-0.5),real(trc(2)+0.5))
c
c  Plot lines of constant RA separated by 15 minute intervals
c
        xinc=xtickd/r2r
	do i=int(ramin/xinc)-1,int(ramax/xinc)+1
	   xd(1)=real(i)*xinc
	   do j=0,100
	      xd(2)=decmin+(decmax-decmin)*real(j)/100.0
              call cocvt(lg,'aw/aw/ap',xd,'ap/ap/ap',pd)
              xline(j)=pd(1)
              yline(j)=pd(2)
	   end do
	   call pgline(101,xline,yline)
	end do
c
c  Plot lines of constant DEC
c
        yinc=1.0*ytickd/r2s
	do i=int(decmin/yinc)-1,int(decmax/yinc)+1
	   xd(2)=real(i)*yinc
	   do j=0,100
	      xd(1)=ramin+(ramax-ramin)*real(j)/100.0
              call cocvt(lg,'aw/aw/ap',xd,'ap/ap/ap',pd)
              xline(j)=pd(1)
              yline(j)=pd(2)
	   end do
	   call pgline(101,xline,yline)
	end do
c
c  Reset the pgplot world coordinate system and line width
c
        call pgswin(wold(1),wold(2),wold(3),wold(4))
        call pgslw(lw)
c
c  Finished coordinate conversions
c
        call cofin(lg)
	end





C*PGTBOX -- draw frame and write (DD) HH MM SS.S labelling
C%void cpgtbox(char *xopt, float xtick, int nxsub, char *yopt, \
C% float ytick, int nysub);
C+
      SUBROUTINE PGTBOX (XOPT, XTICK, NXSUB, YOPT, YTICK, NYSUB)
C
      REAL XTICK, YTICK
      INTEGER NXSUB, NYSUB
      CHARACTER XOPT*(*), YOPT*(*)
C
C Draw a box and optionally label one or both axes with (DD) HH MM SS 
C style numeric labels (useful for time or RA - DEC plots).   If this 
C style of labelling is desired, then PGSWIN should have been called
C previously with the extrema in SECONDS of time.
C
C In the seconds field, you can have at most 3 places after the decimal
C point, so that 1 ms is the smallest time interval you can time label.
C
C Large numbers are coped with by fields of 6 characters long.  Thus 
C you could have times with days or hours as big as 999999.  However, 
C in practice, you might have trouble with labels overwriting  themselves
C with such large numbers unless you a) use a small time INTERVAL, 
C b) use a small character size or c) choose your own sparse ticks in 
C the call to PGTBOX.  
C
C PGTBOX will attempt, when choosing its own ticks, not to overwrite
C the labels, but this algorithm is not very bright and may fail.
C
C Note that small intervals but large absolute times such as
C TMIN = 200000.0 s and TMAX=200000.1 s will cause the algorithm
C to fail.  This is inherent in PGPLOT's use of single precision
C and cannot be avoided.  In such cases, you should use relative
C times if possible.
C
C PGTBOX's labelling philosophy is that the left-most or bottom tick of
C the axis contains a full label.  Thereafter, only changing fields are
C labelled.  Negative fields are given a '-' label, positive fields
C have none.   Axes that have the DD (or HH if the day field is not
C used) field on each major tick carry the sign on each field.  If the
C axis crosses zero, the zero tick will carry a full label and sign.
C
C This labelling style can cause a little confusion with some special
C cases, but as long as you know its philosophy, the truth can be divined.
C Consider an axis with TMIN=20s, TMAX=-20s.   The labels will look like
C
C        +----------+----------+----------+----------+
C     0h0m20s      10s      -0h0m0s      10s        20s
C
C Knowing that the left field always has a full label and that
C positive fields are unsigned, informs that time is decreasing
C from left to right, not vice versa.   This can become very 
C unclear if you have used the 'F' option, but that is your problem !
C
C Exceptions to this labelling philosophy are when the finest time
C increment being displayed is hours (with option 'Y') or days.  
C Then all fields carry a label.  For example,
C
C        +----------+----------+----------+----------+
C      -10h        -8h        -6h        -4h        -2h
C
C
C PGTBOX can be used in place of PGBOX; it calls PGBOX and only invokes 
C time labelling if requested. Other options are passed intact to PGBOX.
C
C Inputs:
C  XOPT   :  X-options for PGTBOX.  Same as for PGBOX plus 
C
C             'Z' for (DD) HH MM SS.S time labelling
C             'Y' means don't include the day field so that labels
C                 are HH MM SS.S rather than DD HH MM SS.S   The hours
C                 will accumulate beyond 24 if necessary in this case.
C             'H' means superscript numbers with d, h, m, & s  symbols
C             'D' means superscript numbers with    o, ', & '' symbols 
C             'F' causes the first label (left- or bottom-most) to
C                 be omitted. Useful for sub-panels that abut each other.
C                 Care is needed because first label carries sign as well.
C             'O' means omit leading zeros in numbers < 10
C                 E.g.  3h 3m 1.2s rather than 03h 03m 01.2s  Useful
C                 to help save space on X-axes. The day field does not 
C                 use this facility.
C
C  YOPT   :  Y-options for PGTBOX.  See above.
C  XTICK  :  X-axis major tick increment.  0.0 for default. 
C  YTICK  :  Y-axis major tick increment.  0.0 for default. 
C            If the 'Z' option is used then XTICK and/or YTICK must
C            be in seconds.
C  NXSUB  :  Number of intervals for minor ticks on X-axis. 0 for default
C  NYSUB  :  Number of intervals for minor ticks on Y-axis. 0 for default
C
C
C  The regular XOPT and YOPT axis options for PGBOX are
C
C  A : draw Axis (X axis is horizontal line Y=0, Y axis is vertical
C      line X=0).
C  B : draw bottom (X) or left (Y) edge of frame.
C  C : draw top (X) or right (Y) edge of frame.
C  G : draw Grid of vertical (X) or horizontal (Y) lines.
C  I : Invert the tick marks; ie draw them outside the viewport
C      instead of inside.
C  L : label axis Logarithmically.
C  N : write Numeric labels in the conventional location below the
C      viewport (X) or to the left of the viewport (Y).
C  P : extend ("Project") major tick marks outside the box (ignored if
C      option I is specified).
C  M : write numeric labels in the unconventional location above the
C      viewport (X) or to the right of the viewport (Y).
C  T : draw major Tick marks at the major coordinate interval.
C  S : draw minor tick marks (Subticks).
C  V : orient numeric labels Vertically. This is only applicable to Y.
C      The default is to write Y-labels parallel to the axis
C
C
C        ******************        EXCEPTIONS       *******************
C
C        Note that 
C          1) PGBOX option 'L' (log labels) is ignored with option 'Z'
C          2) The 'O' option will be ignored for the 'V' option as it 
C             makes it impossible to align the labels nicely
C          3) Option 'Y' is forced with option 'D'
C
C        ***************************************************************
C
C
C--
C 05-Sep-1988 - new routine (Neil Killeen)
C 20-Apr-1991 - add support for new DD (day) field and implement
C               labelling on any axis (bottom,top,left,right) [nebk]
C 10-Jun-1993 - add option 'O' for leading zeros, correctly deal with 
C               user ticks, fully support 'V' and 'NM' options, modify
C               slightly meaning of 'F' option [nebk]
C-----------------------------------------------------------------------
      REAL XTICKD, YTICKD, XMIN, XMAX, YMIN, YMAX
      INTEGER IPT, TSCALX, TSCALY, NXSUBD, NYSUBD
      CHARACTER XXOPT*15, YYOPT*15, SUPTYP*4
      LOGICAL XTIME, YTIME, FIRST, DODAYX, DODAYY, DO2, DOPARA
c_lss_s
      common /myticks/ xtickd,ytickd
c_lss_e
C------------------------------------------------------------------------
C
C  Copy inputs
C
      XTICKD = XTICK
      YTICKD = YTICK
      NXSUBD = NXSUB
      NYSUBD = NYSUB
C
C  Get window in world coordinates
C 
      CALL PGQWIN (XMIN, XMAX, YMIN, YMAX)
C
C  X-axis first
C
      CALL GRTOUP (XXOPT, XOPT)
      XTIME = .FALSE.
      IF (INDEX(XXOPT,'Z').NE.0) THEN
C
C  Work out units for labelling and find the tick increments.
C
        IF (ABS(XMAX-XMIN).LT.0.001) THEN
          CALL GRWARN ('PGTBOX: X-axis time interval too small '//
     *                 '(< 1 ms) for time labels')
        ELSE
          XTIME = .TRUE.
          DODAYX = .TRUE.
          IF (INDEX(XXOPT,'Y').NE.0 .OR. INDEX(XXOPT,'D').NE.0) 
     *        DODAYX = .FALSE.
C
          DOPARA = .TRUE.
          CALL PGTBX1 ('X', DODAYX, DOPARA, XMIN, XMAX, XTICKD, 
     *                 NXSUBD, TSCALX)
        END IF
      END IF
C
C  Same again for Y-axis
C
      CALL GRTOUP (YYOPT, YOPT)
      YTIME = .FALSE.
      IF (INDEX(YYOPT,'Z').NE.0) THEN
        IF (ABS(YMAX-YMIN).LT.0.001) THEN
          CALL GRWARN ('PGTBOX: Y-axis time interval too small '//
     *                 '(< 1ms) for time labels')
        ELSE
          YTIME = .TRUE.
          DODAYY = .TRUE.
          IF (INDEX(YYOPT,'Y').NE.0 .OR. INDEX(YYOPT,'D').NE.0)
     *        DODAYY = .FALSE.
C
          DOPARA = .TRUE.
          IF (INDEX(YYOPT,'V').NE.0) DOPARA = .FALSE.
C
          CALL PGTBX1 ('Y', DODAYY, DOPARA, YMIN, YMAX, YTICKD, 
     *                 NYSUBD, TSCALY)
        END IF
      END IF
C
C  Parse options list.  For call to PGBOX when doing time labelling, we 
C  don't want L (log), N or M (write numeric labels). 
C
      IF (XTIME) THEN
        IPT = INDEX(XXOPT,'L')
        IF (IPT.NE.0) XXOPT(IPT:IPT) = ' '
        IPT = INDEX(XXOPT,'N')
        IF (IPT.NE.0) XXOPT(IPT:IPT) = ' '
        IPT = INDEX(XXOPT,'M')
        IF (IPT.NE.0) XXOPT(IPT:IPT) = ' '
      END IF
C
      IF (YTIME) THEN
        IPT = INDEX(YYOPT,'L')
        IF (IPT.NE.0) YYOPT(IPT:IPT) = ' '
        IPT = INDEX(YYOPT,'N')
        IF (IPT.NE.0) YYOPT(IPT:IPT) = ' '
        IPT = INDEX(YYOPT,'M')
        IF (IPT.NE.0) YYOPT(IPT:IPT) = ' '
      END IF
C
C  Draw box and ticks
C
      CALL PGBOX (XXOPT, XTICKD, NXSUBD, YYOPT, YTICKD, NYSUBD)
C
C  Add (DD) HH MM SS labels if desired.  Go back to the original user
C  specified options list.
C
      XXOPT = ' '
      CALL GRTOUP (XXOPT, XOPT)
      IF (XTIME .AND. (INDEX(XXOPT,'N').NE.0 .OR.
     *                 INDEX(XXOPT,'M').NE.0)) THEN
        FIRST = .TRUE.
        IF (INDEX(XXOPT,'F').NE.0) FIRST = .FALSE.
C
        SUPTYP = 'NONE'
        IF (INDEX(XXOPT,'D').NE.0) SUPTYP = ' DMS'
        IF (INDEX(XXOPT,'H').NE.0) SUPTYP = 'DHMS'
C
        DO2 = .TRUE.
        IF (INDEX(XXOPT,'O').NE.0) DO2 = .FALSE.
C
        DOPARA = .TRUE.
C
        IF (INDEX(XXOPT,'N').NE.0)
     *    CALL PGTBX4 (DODAYX, SUPTYP, 'X', .TRUE., FIRST, 
     *      XMIN, XMAX, TSCALX, XTICKD, DO2, DOPARA)
C
        IF (INDEX(XXOPT,'M').NE.0)
     *    CALL PGTBX4 (DODAYX, SUPTYP, 'X', .FALSE., FIRST, 
     *       XMIN, XMAX, TSCALX, XTICKD, DO2, DOPARA)
      END IF
C
      YYOPT = ' '
      CALL GRTOUP (YYOPT, YOPT)
      IF (YTIME .AND. (INDEX(YYOPT,'N').NE.0 .OR.
     *                 INDEX(YYOPT,'M').NE.0)) THEN
        FIRST = .TRUE.
        IF (INDEX(YYOPT,'F').NE.0) FIRST = .FALSE.
C
        SUPTYP = 'NONE'
        IF (INDEX(YYOPT,'D').NE.0) SUPTYP = ' DMS'
        IF (INDEX(YYOPT,'H').NE.0) SUPTYP = 'DHMS'
C
        DOPARA = .TRUE.
        IF (INDEX(YYOPT,'V').NE.0) DOPARA = .FALSE.
C
        DO2 = .TRUE.
        IF (DOPARA .AND. INDEX(YYOPT,'O').NE.0) DO2 = .FALSE.
C
        IF (INDEX(YYOPT,'N').NE.0)
     *    CALL PGTBX4 (DODAYY, SUPTYP, 'Y', .TRUE., FIRST, 
     *       YMIN, YMAX, TSCALY, YTICKD, DO2, DOPARA)
C
        IF (INDEX(YYOPT,'M').NE.0)
     *    CALL PGTBX4 (DODAYY, SUPTYP, 'Y', .FALSE., FIRST, 
     *       YMIN, YMAX, TSCALY, YTICKD, DO2, DOPARA)
C

      END IF
C
      RETURN
      END
C PGTBX1 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX1 (AXIS, DODAY, DOPARA, TMIN, TMAX, TICK, 
     *                   NSUB, TSCALE)
C
      REAL TMIN, TMAX, TICK
      INTEGER NSUB, TSCALE
      LOGICAL DODAY, DOPARA
      CHARACTER AXIS*1
C
C Work out what the finest units the time labels will be in and
C return the tick increments if the user does not set them.
C
C This is a support routine for PGTBOX and should not 
C be called by the user.
C
C Input:
C  AXIS   :  'X' or 'Y' for use in determining if labels overwrite
C  TMIN   :  Start time in seconds 
C  TMAX   :  End   time in seconds
C  DOPARA :  True if label to be parallel to axis, else perpendicular
C Input/output:
C  DODAY  :  Write labels as DD HH MM SS.S else HH MM SS.S with
C            hours ranging above 24.  Useful for declination labels
C  TICK   :  Major tick interval in seconds.  If 0.0 on input, will 
C            be set here.
C  NSUB   :  Number of minor ticks between major ticks. If 0 on input
C            will be set here.
C Outputs:
C  TSCALE :  Determines finest unit of labelling 
C            (1 => ss, 60 => mm, 3600 => hh, 3600*24 => dd)
C
C 05-Sep-1988 - new routine (Neil Killeen)
C 08-Apr-1991 - correctly work out HH MM SS when the time > 60 h [nebk]
C 20-Apr-1991 - revise to add support for new DD (day) field and
C               do lots of work on tick algorithm [nebk]
C 10-Jun-1993 - deal with user given ticks & rename from PGTIME [nebk/jm]
C-----------------------------------------------------------------------
      INTEGER NLIST1, NLIST2, NLIST3, NLIST4, NTICMX
      PARAMETER (NLIST1 = 19, NLIST2 = 10, NLIST3 = 6, NLIST4 = 8,
     *           NTICMX = 8)
C
      REAL TICKS1(NLIST1), TICKS2(NLIST2), TICKS3(NLIST3), 
     *TICKS4(NLIST4), TOCK, TOCK2, TINT, TINTS, TMINS, TMAXS
      INTEGER NSUBS1(NLIST1), NSUBS2(NLIST2), NSUBS3(NLIST3), 
     *NSUBS4(NLIST4), NPL, NTICK, ITICK, STRLEN
      CHARACTER STR*15
C
      SAVE TICKS1, TICKS2, TICKS3, TICKS4
      SAVE NSUBS1, NSUBS2, NSUBS3, NSUBS4
C
      DATA TICKS1 /0.001,  0.002,                 0.005,
     *             0.01,   0.02,                  0.05,  
     *             0.1,    0.2,                   0.5,  
     *             1.0,    2.0,   3.0,    4.0,    5.0,
     *             6.0,   10.0,  15.0,   20.0,   30.0/
      DATA NSUBS1 / 4,      4,                     2,    
     *              4,      4,                     2,    
     *              4,      4,                     2,    
     *              4,      4,     3,      4,      5,
     *              3,      2,     3,      2,      3/
C
      DATA TICKS2 /1.0,    2.0,   3.0,    4.0,    5.0,
     *             6.0,   10.0,  15.0,   20.0,   30.0/
      DATA NSUBS2 / 4,      4,     3,      4,      5,
     *              3,      2,     3,      2,      3/
C
      DATA TICKS3 /1.0,    2.0,   3.0,    4.0,    6.0,   12.0/
      DATA NSUBS3 / 4,      4,     3,      4,      3,      2/
C
      DATA TICKS4 /1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 9.0/
      DATA NSUBS4 / 4,   4,   3,   4,   5,   3,   4,   3 /
C----------------------------------------------------------------------
C
C  Turn off DD (day) field if it has been unnecessarily asked for
C
      IF ((ABS(TMIN).LT.24.0*3600.0) .AND. (ABS(TMAX).LT.24.0*3600.0))
     *   DODAY = .FALSE.
C
C  If a tick size is provided, use it to determine TSCALE
C
      TINT = ABS(TMAX - TMIN)
      TICK = ABS(TICK)
      IF (TICK.NE.0.0) THEN
        IF (TICK.GE.TINT) THEN
          CALL GRWARN ('PGTBX1: user given tick bigger than time '
     *                 //'interval; will auto-tick')
          TICK = 0.0
        ELSE IF (TICK.LT.0.001) THEN
          CALL GRWARN ('PGTBX1: user given tick too small (< 1 ms); '
     *                 //'will auto-tick')
          TICK = 0.0
        ELSE 
          IF (MOD(TICK, 60.0) .NE. 0.0) THEN
            TSCALE = 1
          ELSE IF (MOD(TICK, 3600.0).NE.0.0) THEN
            TSCALE = 60
          ELSE IF (.NOT.DODAY) THEN
            TSCALE = 3600
          ELSE IF (MOD(TICK,(24.0*3600.0)).NE.0.0) THEN
            TSCALE = 3600
          ELSE
            TSCALE = 24 * 3600
          ENDIF
C
C  Make a simple default for the number of minor ticks and bug out
C
          IF (NSUB.EQ.0) NSUB = 2
          RETURN
        END IF
      END IF
C
C  Work out label units depending on time interval if user 
C  wants auto-ticking
C
      IF (TINT.LE.5*60) THEN
        TSCALE = 1
      ELSE IF (TINT.LE.5*3600) THEN
        TSCALE = 60
      ELSE 
        IF (.NOT.DODAY) THEN
          TSCALE = 3600
        ELSE
          IF (TINT.LE.5*24*3600) THEN
            TSCALE = 3600
          ELSE
            TSCALE = 3600*24
          END IF
        END IF
      END IF
C
CCCCC
C  Divide interval into NTICK major ticks and NSUB minor intervals
C  The tick choosing algorithm is not very robust, so watch out
C  if you fiddle anything. 
CCCCC
C
      TINTS = TINT / TSCALE
      IF (TSCALE.EQ.1) THEN
C
C  Time in seconds.  If the time interval is very small, may need to 
C  label with up to 3 decimal places.  Have less ticks to help prevent
C  label overwrite. STR is a dummy tick label to assess label 
C  overwrite potential
C
        IF (DOPARA) THEN
          IF (TINTS.LE.0.01) THEN
            NTICK = 4
            STR = '60.423'
            STRLEN = 6
          ELSE IF (TINTS.LE.0.1) THEN
            NTICK = 5
            STR = '60.42'
            STRLEN = 5
          ELSE IF (TINTS.LE.1.0) THEN
            NTICK = 6
            STR = '60.4'
            STRLEN = 4
          ELSE
            NTICK = 6
            STR = '60s'
            STRLEN = 3
          END IF
        ELSE
          NTICK = 6
          STR = ' '
          STRLEN = 1
        END IF
        TOCK = TINTS / NTICK
C
C  Select nearest tick to TOCK from list.
C
        CALL PGTBX2 (TOCK, NLIST1, TICKS1, NSUBS1, TICK, NSUB, ITICK)
C
C  Check label overwrite and/or too many ticks.
C
        CALL PGTBX3 (DODAY, 0, TSCALE, TINTS, NTICMX, NLIST1, TICKS1,
     *               NSUBS1, ITICK, AXIS, DOPARA, STR(1:STRLEN),
     *               TICK, NSUB)
      ELSE IF (TSCALE.EQ.60) THEN
C
C  Time in minutes 
C
        NTICK = 6
        TOCK = TINTS / NTICK
C
C  Select nearest tick from list
C
        CALL PGTBX2 (TOCK, NLIST2, TICKS2, NSUBS2, TICK, NSUB, ITICK)
C
C  Check label overwrite and/or too many ticks.
C
        IF (DOPARA) THEN
          STR = '42m'
          STRLEN = 3
        ELSE
          STR = ' '
          STRLEN = 1
        END IF
        CALL PGTBX3 (DODAY, 0, TSCALE, TINTS, NTICMX, NLIST2, TICKS2,
     *               NSUBS2, ITICK, AXIS, DOPARA, STR(1:STRLEN),
     *               TICK, NSUB)
      ELSE 
        IF (TSCALE.EQ.3600 .AND. DODAY) THEN
C
C  Time in hours with the day field 
C
          NTICK = 6
          TOCK = TINTS / NTICK
C
C  Select nearest tick from list
C
          CALL PGTBX2 (TOCK, NLIST3, TICKS3, NSUBS3, TICK, NSUB, ITICK)
C
C   Check label overwrite and/or too many ticks.
C
          IF (DOPARA) THEN
            STR = '42h'
            STRLEN = 3
          ELSE
            STR = ' '
            STRLEN = 1
          END IF
          CALL PGTBX3 (DODAY, 0, TSCALE, TINTS, NTICMX, NLIST3, TICKS3,
     *                 NSUBS3, ITICK, AXIS, DOPARA, STR(1:STRLEN),
     *                 TICK, NSUB)
        ELSE
C
C  Time in hours with no day field or time in days. Have less
C  ticks for big numbers or the parallel labels will overwrite.

          IF (DOPARA) THEN
            TMINS = ABS(TMIN) / TSCALE
            TMAXS = ABS(TMAX) / TSCALE            
            CALL PGNPL (-1, NINT(MAX(TINTS,TMINS,TMAXS)), NPL)
            IF (NPL.LE.3) THEN
              NTICK = 6
            ELSE IF (NPL.EQ.4) THEN
              NTICK = 5
            ELSE
              NTICK = 4
            END IF
            STR = '345678912'
            STR(NPL+1:) = 'd'
            STRLEN = NPL + 1
          ELSE
            STR = ' '
            STRLEN = 1
            NTICK = 6
          END IF
          TOCK = TINTS / NTICK
C
C   Select nearest tick from list; 1 choose nearest nice integer 
C   scaled by the appropriate power of 10
C
          CALL PGNPL (-1, NINT(TOCK), NPL)
          TOCK2 = TOCK / 10**(NPL-1)
C
          CALL PGTBX2 (TOCK2, NLIST4, TICKS4, NSUBS4, TICK, NSUB, ITICK)
          TICK = TICK * 10**(NPL-1)
C
C  Check label overwrite and/or too many ticks.
C
          CALL PGTBX3 (DODAY, NPL, TSCALE, TINTS, NTICMX, NLIST4, 
     *                 TICKS4, NSUBS4, ITICK, AXIS, DOPARA,
     *                 STR(1:STRLEN), TICK, NSUB)
        END IF
      END IF
C
C  Convert tick to seconds
C
      TICK = TICK * TSCALE
C
      RETURN
      END
C PGTBX2 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX2 (TOCK, NTICKS, TICKS, NSUBS, TICK, NSUB, ITICK)
C
      INTEGER NTICKS, NSUBS(NTICKS), NSUB, ITICK
      REAL TOCK, TICKS(NTICKS), TICK
C
C Find the nearest tick in a list to a given value.
C
C This is a support routine for PGTBOX and should not be called
C by the user.
C
C Input:
C  TOCK   :  Try to find the nearest tick in the list to TOCK
C  NTICKS :  Number of ticks in list
C  TICKS  :  List of ticks
C  NSUBS  :  List of number of minor ticks between ticks to go with TICKS
C Output:
C  TICK   :  The selected tick
C  ITICK  :  The index of the selected tick from the list TICKS
C Input/output
C  NSUB   :  Number of minor ticks between major ticks. If 0 on input
C            will be set here.
C
C 10-Jun-1993 - new routine [nebk]
C-----------------------------------------------------------------------
      INTEGER I, NSUBD
      REAL DMIN, DIFF
C----------------------------------------------------------------------
      NSUBD = NSUB
      DMIN = 1.0E30
      DO 100 I = 1, NTICKS
        DIFF = ABS(TOCK - TICKS(I))
        IF (DIFF.LT.DMIN) THEN
          TICK = TICKS(I)
          IF (NSUBD.EQ.0) NSUB = NSUBS(I)
          ITICK = I
C
          DMIN = DIFF
        END IF
 100  CONTINUE
C
      RETURN
      END
C PGTBX3 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX3 (DODAY, NPL, TSCALE, TINTS, NTICMX, NTICKS,
     *                   TICKS, NSUBS, ITICK, AXIS, DOPARA, STR,
     *                   TICK, NSUB)
C
      INTEGER TSCALE, NTICMX, NTICKS, ITICK, NSUB, NSUBS(NTICKS), NPL
      REAL TINTS, TICKS(NTICKS), TICK
      CHARACTER AXIS*1, STR*(*)
      LOGICAL DODAY, DOPARA
C
C Try to see if label overwrite is going to occur with this tick 
C selection, or if there are going to be more than a reasonable
C number of ticks in the displayed time range.  If so, choose, 
C if available, the next tick (bigger separation) up in the list.
C If the overwrite requires that we would need to go up to the bext
C TSCALE, give up.  They will need to choose a smaller character size
C
C This is a support routine for PGTBOX and should not 
C be called by the user.
C
C Input:
C  DODAY  :  True if day field being used
C  NPL    :  Number of characters needed to format TICK on input
C  TSCALE :  Dictates what the finest units of the labelling are.
C            1 = sec, 60 = min, 3600 = hr, 24*3600 = days
C  TINTS  :  Absolute time interval in units of TSCALE
C  NTICMX :  Max. reasonable number of ticks to allow in the time range
C  NTICKS :  Number of ticks in list of ticks to choose from
C  TICKS  :  List of ticks from which the current tick was chosen
C  NSUBS  :  List of number of minor ticks/major tick to choose NSUB from
C  ITICK  :  Index of chosen tick in list TICKS
C  AXIS   :  'X' or 'Y' axis
C  DOPARA :  Labels parallel or perpendicualr to axis
C  STR    :  A typical formatted string used for checking overwrite
C Input/output:
C  TICK   :  Current major tick interval in units of TSCALE. May be 
C            made larger if possible if overwrite likely.
C  NSUB   :  Number of minor ticks between major ticks. 
C
C 10-Jun-1993 - new routine [nebk]
C-----------------------------------------------------------------------
      INTEGER NTICK
      REAL LENS, LENX, LENY
C----------------------------------------------------------------------
      CALL PGLEN (4, STR, LENX, LENY)
      LENS = LENX
      IF ( (DOPARA .AND. AXIS.EQ.'Y') .OR.
     *     (.NOT.DOPARA .AND. AXIS.EQ.'X') ) LENS = LENY
C
      IF (TSCALE.EQ.1 .OR. TSCALE.EQ.60 .OR.
     *    (TSCALE.EQ.3600 .AND. DODAY)) THEN
C
C  Time in seconds or minutes, or in hours with a day field
C
        NTICK = INT(TINTS / TICK)
        IF ( (ITICK.LT.NTICKS)  .AND. 
     *       ((DOPARA .AND. (LENS/TSCALE).GT.0.9*TICK) .OR. 
     *       (NTICK.GT.NTICMX)) ) THEN
          IF (TICKS(ITICK+1).LT.TINTS) THEN
            NSUB = NSUBS(ITICK+1)
            TICK = TICKS(ITICK+1)
          END IF
        END IF
      ELSE
C
C  Time in hours and no day field or time in days
C
        NTICK = INT(TINTS / TICK)
        IF ( (DOPARA .AND. (LENS/TSCALE).GT.0.9*TICK) .OR. 
     *       (NTICK.GT.NTICMX) ) THEN
          IF (ITICK.LT.NTICKS) THEN
            IF (TICKS(ITICK+1)*10**(NPL-1).LT.TINTS) THEN
              NSUB = NSUBS(ITICK+1)
              TICK = TICKS(ITICK+1) * 10**(NPL-1)
            END IF
          ELSE
            IF (TICKS(1)*10**NPL.LT.TINTS) THEN
              NSUB = NSUBS(1)
              TICK = TICKS(1) * 10**NPL
            END IF
          END IF
        END IF
      END IF
C
      RETURN
      END
C PGTBX4 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX4 (DODAY, SUPTYP, AXIS, CONVTL, FIRST, TMIN,
     *                   TMAX, TSCALE, TICK, DO2, DOPARA)
C
      REAL TMIN, TMAX, TICK
      INTEGER TSCALE
      CHARACTER AXIS*(*), SUPTYP*(*)
      LOGICAL FIRST, DODAY, CONVTL, DO2, DOPARA
C
C Label an axis in (DD) HH MM SS.S style.    This is the main 
C workhorse of the PGTBOX routines.
C
C This is a support subroutine for PGTBOX and should not be 
C called by the user. 
C
C Inputs:
C  DODAY  :  Write labels as DD HH MM SS.S else HH MM SS.S with
C            hours ranging above 24.  Useful for declination labels
C  SUPTYP :  If 'DHMS' then superscript the fields with d, h, m, & s
C            If ' DMS' then superscript the fields with    o, '  & '' 
C              Good for declination plots.  You should obviously not 
C              ask for the day field for this to do anything sensible. 
C            If '    ' then no superscripting is done.
C  AXIS   :  'X' for x-axis, 'Y' for y-axis
C  CONVTL :  If .true., write the labels in the conventional axis 
C            locations (bottom and left for 'X' and 'Y').  Otherwise
C            write them on the top and right axes ('X' and 'Y')
C  FIRST  :  If .false. then omit the first label.
C  TMIN   :  Start time (seconds)
C  TMAX   :  End time (seconds)
C  TSCALE :  Determines finest units of axis
C              1 => ss, 60 => mm, 3600 => hh, 3600*24 => dd
C  TICK   :  Major tick interval in seconds
C  DO2    :  If .true., write labels less than 10 with a leading zero.
C  DOPARA :  Y axis label parallel to axis, else perpendicular
C
C 05-Sep-1988 - new routine (Neil Killeen)
C 20-Apr-1991 - add support for new DD (day) field [nebk]
C 10-Jun-1993 - complete rewrite & rename from PGTLAB. Fixes user given 
C               ticks bug too [nebk]
C-----------------------------------------------------------------------
      INTEGER MAXTIK
      LOGICAL T, F
      PARAMETER (MAXTIK = 1000, T = .TRUE., F = .FALSE.)
C
      REAL SS(MAXTIK), TFRAC(MAXTIK)
      INTEGER DD(MAXTIK), HH(MAXTIK), MM(MAXTIK)
      CHARACTER*1 ASIGN(MAXTIK), ASIGNL
C
      REAL TIME, XLEN, YLEN, COORD, FJUST, RVAL, SSL, DISP,
     *XLEN2, YLEN2
      INTEGER IS, SD, NT, IZERO, IPOS, INEG, IT, I, J, K, SPREC,
     *JST(2), JEND(2), TLEN, LAST, IVAL(3), IVALO(3), IVALZ(3),
     *IVALF(3), IVALL(3), NPASS, INC, DDL, HHL, MML
      CHARACTER SIGNF*1, TEXT*80, AXLOC*2
      LOGICAL WRIT(4)
C-----------------------------------------------------------------------
C
C  Direction signs
C
      SD = 1
      IF (TMAX.LT.TMIN) SD = -1
      IS = 1
      IF (TMIN.LT.0.0) IS = -1
C
C  Find first tick.  Return if none.
C
      NT = TMIN / TICK
      IF (IS*SD.EQ.1 .AND. ABS(TMIN).GT.ABS(NT)*TICK) NT = NT + SD
      TIME = NT * TICK
      IF ( (SD.EQ. 1.AND.(TIME.LT.TMIN.OR.TIME.GT.TMAX)) .OR.
     *     (SD.EQ.-1.AND.(TIME.GT.TMIN.OR.TIME.LT.TMAX)) ) RETURN
C
C  Now step through time range in TICK increments and convert
C  times in seconds at each tick to  +/- (DD) HH MM SS.S
C
      IZERO = 0
      IT = 1
 100  IF ( (SD.EQ.1  .AND. TIME.GT.(TMAX+1.0E-5)) .OR.
     *     (SD.EQ.-1 .AND. TIME.LT.(TMAX-1.0E-5)) ) GOTO 200
        IF (IT.GT.MAXTIK) THEN
          CALL GRWARN ('PGTBX4: storage exhausted -- you have'
     *                 //'asked for far too many ticks')
          GOTO 200
        END IF
C
C  Convert to (DD) HH MM SS.S and find fraction of window that this
C  tick falls at
C
        CALL PGTBX5 (DODAY, TIME, ASIGN(IT), DD(IT), HH(IT),
     *               MM(IT), SS(IT))
        TFRAC(IT) = (TIME - TMIN) / (TMAX - TMIN)
C
C  Note zero tick
C
        IF (NT.EQ.0) IZERO = IT
C
C  Increment time
C
        NT = NT + SD
        TIME = NT * TICK
        IT = IT + 1
C
        GOTO 100
 200  CONTINUE
      IT = IT - 1
C
C   Work out the precision with which to write fractional seconds 
C   labels into the SS.S field.   All other fields have integer labels.
C
      SPREC = 0
      IF (TSCALE.EQ.1) THEN
        IF (TICK.LT.0.01) THEN
          SPREC = 3
        ELSE IF (TICK.LT.0.1) THEN
          SPREC = 2
        ELSE IF (TICK.LT.1.0) THEN
          SPREC = 1
        END IF
      END IF
C
C  Label special case of first tick.  Prepare fields and label
C
      CALL PGTBX6 (DODAY, TSCALE, DD(1), HH(1), MM(1), SS(1), IVALF,
     *             RVAL, WRIT)
      SIGNF = 'H'
      IF (DODAY) SIGNF = 'D'
      CALL PGTBX7 (SUPTYP, SIGNF, ASIGN(1), IVALF, RVAL, WRIT,
     *             SPREC, DO2, TEXT, TLEN, LAST)
C
C   Set label displacements from axes.  This is messy for labels oriented
C   perpendicularly on the right hand axis as we need to know how long
C   the longest string we are going to write is before we write any 
C   labels as they are right justified.
C
      IF (AXIS.EQ.'X') THEN
        IF (CONVTL) THEN
          AXLOC = 'B'
          DISP = 2.0
        ELSE
          AXLOC = 'T'
          DISP = 1.0
        END IF
      ELSE IF (AXIS.EQ.'Y') THEN
        IF (CONVTL) THEN
          AXLOC = 'LV'
          IF (DOPARA) AXLOC = 'L'
          DISP = 1.0
        ELSE
          IF (DOPARA) THEN
            AXLOC = 'R'
            DISP = 2.0
          ELSE
C
C  Work out number of characters in first label
C
            AXLOC = 'RV'
            IF (ASIGN(1).NE.'-' .AND. TMIN*TMAX.LT.0.0) THEN
              CALL PGLEN (2, ' -'//TEXT(1:TLEN), XLEN, YLEN)
            ELSE
              CALL PGLEN (2, ' '//TEXT(1:TLEN), XLEN, YLEN)
            END IF
            CALL PGQCS (2, XLEN2, YLEN2)
            DISP = (XLEN/XLEN2)
          END IF
        END IF
      END IF
C
C  Now write the label to the plot.  The X-axis label for the first tick is
C  centred such that the last field of the label is centred on the tick
C
      IF (FIRST) THEN
        CALL PGLEN (5, TEXT(LAST:TLEN), XLEN, YLEN)
C
        IF (AXIS.EQ.'X') THEN
          COORD = TFRAC(1) + XLEN / 2.0
          FJUST = 1.0
        ELSE IF (AXIS.EQ.'Y') THEN
          IF (DOPARA) THEN
            COORD = TFRAC(1) + YLEN / 2.0
            FJUST = 1.0
          ELSE
            FJUST = 1.0
            COORD = TFRAC(1)
          END IF
        END IF
        CALL PGMTXT (AXLOC, DISP, COORD, FJUST, TEXT(1:TLEN))
      END IF
      IF (IT.EQ.1) RETURN
C
C   Designate which field out of DD or HH will carry the sign, depending
C   on whether you want the day field or not for the rest of the ticks
C
      SIGNF = 'H'
      IF (DODAY) SIGNF = 'D'
C
C  Set up labelling justifications for the rest of the labels
C
      IF (AXIS.EQ.'X') THEN
        FJUST = 0.5
      ELSE IF (AXIS.EQ.'Y') THEN
        IF (DOPARA) THEN
          FJUST = 0.5
        ELSE
          FJUST = 1.0
        END IF
      END IF
C
C  Note zero crossings; IPOS is the first positive tick and
C  INEG is the first negative tick on either side of 0
C
      IPOS = 0
      INEG = 0
C
      IF (IZERO.NE.0) THEN
        J = IZERO - 1
        IF (J.GE.1) THEN
          IF (ASIGN(J).EQ.'-') THEN
            INEG = J
          ELSE IF (ASIGN(J).EQ.' ') THEN
            IPOS = J
          END IF
        END IF
        J = IZERO + 1
        IF (J.LE.IT) THEN
          IF (ASIGN(J).EQ.'-') THEN
            INEG = J
          ELSE IF (ASIGN(J).EQ.' ') THEN
            IPOS = J
          END IF
        END IF
      END IF
C
C  Now label special case of zero tick. It carries the sign change
C  when going from positive to negative time, left to right.
C
      IF (IZERO.NE.0 .AND. IZERO.NE.1) THEN
        CALL PGTBX6 (DODAY, TSCALE, DD(IZERO), HH(IZERO), MM(IZERO),
     *               SS(IZERO), IVALZ, RVAL, WRIT)
C
        IF (ASIGN(IZERO-1).EQ.' ') ASIGN(IZERO) = '-'
        CALL PGTBX7 (SUPTYP, SIGNF, ASIGN(IZERO), IVALZ, RVAL, WRIT,
     *               SPREC, DO2, TEXT, TLEN, LAST)
C
        COORD = TFRAC(IZERO)
        CALL PGMTXT (AXLOC, DISP, COORD, FJUST, TEXT(1:TLEN))
      END IF
C
C   We may need an extra "virtual" tick if there is no zero crossing
C   and SD=-1 & IS=1 or SD=1 & IS=-1.  It is used to work out which
C   fields to label on the right most tick which is labelled first.
C
      IF (IZERO.EQ.0) THEN
        IF (SD*IS.EQ.-1) THEN 
          IF ( (SD.EQ.-1 .AND. TIME.LE.0.0) .OR.
     *         (SD.EQ. 1 .AND. TIME.GE.0.0) ) TIME = 0.0
          CALL PGTBX5 (DODAY, TIME, ASIGNL, DDL, HHL, MML, SSL)
          CALL PGTBX6 (DODAY, TSCALE, DDL, HHL, MML, SSL,
     *                 IVALL, RVAL, WRIT)
        END IF
      END IF
C
C  We want to label in the direction(s) away from zero, so we may  need
C  two passes. Determine the start and end ticks for each required pass.
C
      JST(2) = 0
      JEND(2) = 0
      NPASS = 1
      IF (IZERO.EQ.0) THEN
        IF (IS*SD.EQ.1) THEN
          JST(1) = 1
          JEND(1) = IT
        ELSE
          JST(1) = IT
          JEND(1) = 1
        END IF
      ELSE
        IF (INEG.EQ.0 .OR. IPOS.EQ.0) THEN
          JST(1) = IZERO
          JEND(1) = IT
          IF (IZERO.EQ.IT) JEND(1) = 1
        ELSE
          NPASS = 2
          JST(1) = IZERO
          JEND(1) = 1
          JST(2) = IZERO
          JEND(2) = IT
        END IF
      END IF
C
C  Now label the rest of the ticks.  Always label away from 0
C
      DO 400 I = 1, NPASS
C
C  Initialize previous tick values.  Use virtual tick if labelling
C  left to right without a zero (one pass)
C
        DO 250 K = 1, 3
          IVALO(K) = IVALZ(K)
          IF (IZERO.EQ.0) THEN
            IVALO(K) = IVALL(K)
            IF (JST(I).EQ.1) IVALO(K) = IVALF(K)
          END IF
  250   CONTINUE
C
        INC = 1
        IF (JEND(I).LT.JST(I)) INC = -1
        DO 300 J = JST(I), JEND(I), INC
C
C  First and zero tick already labelled
C
          IF (J.NE.1 .AND. J.NE.IZERO) THEN
C
C  Prepare fields
C
            CALL PGTBX6 (DODAY, TSCALE, DD(J), HH(J), MM(J),
     *                   SS(J), IVAL, RVAL, WRIT)
C
C  Don't write unchanging fields
C
            DO 275 K = 1, 3
              IF (IVAL(K).EQ.IVALO(K)) WRIT(K) = F
 275        CONTINUE
C
C  Prepare label
C
            CALL PGTBX7 (SUPTYP, SIGNF, ASIGN(J), IVAL, RVAL, WRIT,
     *                   SPREC, DO2, TEXT, TLEN, LAST)
C
C  Write label
C
            COORD = TFRAC(J)
            CALL PGMTXT (AXLOC, DISP, COORD, FJUST, TEXT(1:TLEN))
C
C  Update old values
C
            DO 280 K = 1, 3
              IVALO(K) = IVAL(K)
  280       CONTINUE
          END IF
 300    CONTINUE
 400  CONTINUE
C 
      RETURN
      END
C PGTBX5 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX5 (DODAY, TSEC, ASIGN, D, H, M, S)
C      
      REAL S, TSEC
      INTEGER  D, H, M
      LOGICAL DODAY
      CHARACTER*1 ASIGN
C
C  Convert time in seconds to (DD) HH MM SS.S
C
C Input
C  DODAY  :  Use day field if true, else hours accumulates beyond 24
C  TSEC   :  Time in seconds (signed)
C Output
C  ASIGN  :  Sign, ' ' or '-'
C  D,H,M  :  DD, HH, MM (unsigned)
C  S      :  SS.S       (unsigned)
C
C 10-Jun-1993 - new routine [nebk]
C-----------------------------------------------------------------------
      INTEGER IT
C----------------------------------------------------------------------
      ASIGN = ' '
      IF (TSEC.LT.0.0) ASIGN = '-'
C
      S = MOD(ABS(TSEC),60.0)
C
      IT = NINT(ABS(TSEC)-S) / 60
      M = MOD(IT,60)
C
      IT = (IT - M) / 60
      IF (DODAY) THEN
        H = MOD(IT,24)
        D = (IT-H) / 24
      ELSE
        H = IT
        D = 0
      END IF
C
      RETURN
      END
C PGTBX6 -- support routine for PGTBOX
C
      SUBROUTINE PGTBX6 (DODAY, TSCALE, DD, HH, MM, SS, IVAL, 
     *                   RVAL, WRIT)
C
      INTEGER TSCALE, IVAL(3), DD, HH, MM
      REAL SS, RVAL
      LOGICAL WRIT(4), DODAY
C
C   Find out which of the DD HH MM SS.S fields we want to write
C   into the label according to TSCALE and make a round off
C   error check.
C
C  Input:
C    DODAY  :  Use day field if true else hours accrue beyond 24
C    TSCALE :  Dictates which fields appear in labels
C    DD     :  Day of time  (will be 0 if DODAY=F and HH will compensate)
C    HH     :  Hour of time
C    MM     :  Minute of time
C    SS     :  Second of time
C  Output:
C    IVAL(3):  DD HH MM to write into label
C    RVAL   :  SS.S to write into label
C    WRIT(4):  T or F if DD,HH,MM,SS are to be written into the label
C              or not.  IVAL and RVAL fields are set explicitly to
C              zero if the corresponding WRIT field is false.
C              This really is overkill.
C
C  10-Jun-1993 - New routine [nebk]
C-----------------------------------------------------------------------
      LOGICAL T, F
      PARAMETER (T = .TRUE., F = .FALSE.)
      INTEGER WM
C-----------------------------------------------------------------------
      IVAL(1) = DD
      IVAL(2) = HH
      IVAL(3) = MM
      RVAL    = SS
C
C  SS should be 0.0; round off may get us 59.999 or the like but
C  not 60.001 (see PGTBX5)
C
      IF (TSCALE.GT.1) THEN
        WM = NINT(SS/60.0)
        IVAL(3) = IVAL(3) + WM
        IF (IVAL(3).EQ.60) THEN
          IVAL(3) = 0
          IVAL(2) = IVAL(2) + 1
          IF (DODAY .AND. IVAL(2).EQ.24) THEN
            IVAL(2) = 0
            IVAL(1) = IVAL(1) + 1
          END IF
        END IF
      END IF
C
      IF (TSCALE.EQ.1) THEN
C
C  Label contains (DD) HH MM SS.S
C
        WRIT(1) = DODAY
        WRIT(2) = T
        WRIT(3) = T
        WRIT(4) = T
      ELSE IF (TSCALE.EQ.60) THEN
C
C  Label contains (DD) HH MM
C
        WRIT(1) = DODAY
        WRIT(2) = T
        WRIT(3) = T
C        
        RVAL    = 0.0
        WRIT(4) = F
      ELSE IF (TSCALE.EQ.3600) THEN
C
C  Label contains (DD) HH
C
        WRIT(1) = DODAY
        WRIT(2) = T
C
        IVAL(3) = 0
        WRIT(3) = F
C  
        RVAL    = 0.0
        WRIT(4) = F
      ELSE IF (TSCALE.EQ.3600*24) THEN
C
C  Label contains DD
C
        WRIT(1) = T
C
        IVAL(2) = 0
        WRIT(2) = F
C
        IVAL(3) = 0
        WRIT(3) = F
C
        RVAL    = 0.0
        WRIT(4) = F
      END IF
C
      RETURN
      END
      SUBROUTINE PGTBX7 (SUPTYP, SIGNF, ASIGN, IVAL, RVAL, WRIT,
     *                   SPREC, DO2, TEXT, TLEN, LAST)
C
      REAL RVAL
      INTEGER IVAL(3), TLEN, SPREC, LAST
      CHARACTER ASIGN*1, TEXT*(*), SIGNF*1, SUPTYP*4
      LOGICAL WRIT(4), DO2
C
C Write (DD) HH MM SS.S time labels into a string
C
C This is a support routine for PGTBOX and should not be
C called by the user
C
C Inputs
C  SUPTYP :  '    ', 'DHMS', or ' DMS' for no superscript labelling,
C            d,h,m,s   or   o,','' superscripting
C  SIGNF  :  Tells which field the sign is associated with.  
C            One of 'D', 'H', 'M', or 'S'    
C  ASIGN  :  ' ' or '-' for positive or negative times
C  IVAL(3):  Day, hour, minutes of time
C  RVAL   :  Seconds of time
C  WRIT(4):  If .true. then write DD, HH, MM, SS  into label
C  SPREC  :  Number of places after the decimal to write seconds 
C            string to.  Must be in the range 0-3
C  DO2    :  If true, add a leading zero to numbers < 10
C Outputs
C  TEXT   :  Label
C  TLEN   :  Length of label
C  LAST   :  Is the location of the start character of the last 
C            field written into TEXT
C
C  05-Sep-1989 -- New routine (Neil Killeen)
C  20-Apr-1991 -- Complete rewrite; support for new DD (day) field and 
C                 superscripted labels [nebk]
C  14-May-1991 -- Removed BSL as a parameter (Char(92)) and made it
C                 a variable to appease Cray compiler [mjs/nebk]
C  10-Jun-1993 -- Rename from PGTLB1, add code to label superscript 
C                 seconds above the '.' and add DO2 option [nebk/jm]
C-----------------------------------------------------------------------
      INTEGER FLEN, FST, FMAX, TRLEN(3), SUPPNT, TMPNT, TLEN2, 
     *IR1, IR2, IP
      CHARACTER FIELD*30, FRMAT2(3)*2, SUPER(4,3)*11, TMP*100, 
     *BSL*1, FRMAT*30
C
      SAVE FRMAT2
      SAVE TRLEN
C
      DATA FRMAT2 /'I1', 'I2', 'I3'/
      DATA TRLEN /5, 11, 5/
C-----------------------------------------------------------------------
C
C   Initialize
C
      BSL = CHAR(92)
      TLEN = 0
      TEXT = ' '
C
C   Assign superscripting strings.  Use CHAR(92) for backslash as the
C   latter must be escaped on SUNs thus requiring preprocessing.  The
C   concatenator operator precludes the use of a data statement
C
      SUPER(1,1) = BSL//'ud'//BSL//'d'
      SUPER(2,1) = BSL//'uh'//BSL//'d'
      SUPER(3,1) = BSL//'um'//BSL//'d'
      SUPER(4,1) = BSL//'us'//BSL//'d'
C
      SUPER(1,2) = BSL//'u'//BSL//'(2199)'//BSL//'d'
      SUPER(2,2) = BSL//'u'//BSL//'(2729)'//BSL//'d'
      SUPER(3,2) = BSL//'u'//BSL//'(2727)'//BSL//'d'
      SUPER(4,2) = BSL//'u'//BSL//'(2728)'//BSL//'d'
C      
      SUPER(1,3) = BSL//'u'//' '//BSL//'d'
      SUPER(2,3) = BSL//'u'//' '//BSL//'d'
      SUPER(3,3) = BSL//'u'//' '//BSL//'d'
      SUPER(4,3) = BSL//'u'//' '//BSL//'d'
C
C   Point at correct superscript strings
C
      IF (SUPTYP.EQ.'DHMS') THEN
        SUPPNT = 1
      ELSE IF (SUPTYP.EQ.' DMS') THEN
        SUPPNT = 2
      ELSE
        SUPPNT = 3
      END IF
C
CCCC
C   Days field
CCCC
C
      IF (WRIT(1)) THEN
        LAST = TLEN + 1
C
C   Write into temporary field
C
        FIELD = ' '
        CALL PGNPL (0, IVAL(1), FLEN)
        WRITE (FIELD, '(I6)') IVAL(1)
        FMAX = 6
        FST = FMAX - FLEN + 1
C
C   Write output text string with desired superscripting
C
        TMPNT = 2
        IF (SIGNF.EQ.'D' .AND. ASIGN.NE.' ') TMPNT = 1
C
        TMP = ASIGN//FIELD(FST:FMAX)//SUPER(1,SUPPNT)
        TLEN2 = (2 - TMPNT) + FLEN + TRLEN(SUPPNT)
C
        TEXT(TLEN+1:) = TMP(TMPNT:TMPNT+TLEN2-1)
        TLEN = TLEN + TLEN2
      END IF
C
CCCC 
C   Hours field
CCCC
C
      IF (WRIT(2)) THEN
        LAST = TLEN + 1
C
C   Write into temporary field
C
        FIELD = ' '
        CALL PGNPL (0, IVAL(2), FLEN)
        WRITE (FIELD, '(I6)') IVAL(2)
        FMAX = 6
        FST = FMAX - FLEN + 1
C
        IF (DO2 .AND. FLEN.EQ.1) THEN
          FLEN = FLEN + 1
          FST = FST - 1
          FIELD(FST:FST) = '0'
        END IF
C
C   Write output text string with desired superscripting
C
        TMPNT = 2
        IF (SIGNF.EQ.'H' .AND. ASIGN.NE.' ') TMPNT = 1
C
        TMP = ASIGN//FIELD(FST:FMAX)//SUPER(2,SUPPNT)
        TLEN2 = (2 - TMPNT) + FLEN + TRLEN(SUPPNT)
C
        TEXT(TLEN+1:) = TMP(TMPNT:TMPNT+TLEN2-1)
        TLEN = TLEN + TLEN2
      END IF
C
CCCC
C   Minutes field
CCCC
C
      IF (WRIT(3)) THEN
        LAST = TLEN + 1
C
C   Write into temporary field with desired superscripting
C
        FIELD = ' '
        WRITE (FIELD, '(I2, A)') IVAL(3), 
     *                           SUPER(3,SUPPNT)(1:TRLEN(SUPPNT))
        FMAX = 2 + TRLEN(SUPPNT)
C
        FST = 1
        IF (FIELD(FST:FST).EQ.' ') THEN
          IF (DO2) THEN
            FIELD(FST:FST) = '0'
          ELSE
            FST = FST + 1
          END IF
        END IF
        FLEN = FMAX - FST + 1
C
C   Write output text string
C
        TMPNT = 2
        IF (SIGNF.EQ.'M' .AND. ASIGN.NE.' ') TMPNT = 1
C
        TMP = ASIGN//FIELD(FST:FMAX)
        TLEN2 = (2 - TMPNT) + FLEN
C
        TEXT(TLEN+1:) = TMP(TMPNT:TMPNT+TLEN2-1)
        TLEN = TLEN + TLEN2
      END IF
C
CCCC
C   Seconds field
CCCC
C
      IF (WRIT(4)) THEN
        LAST = TLEN + 1
C
C   Write into temporary field
C 
        FIELD = ' '
        FST = 1
        IF (SPREC.GE.1) THEN
C
C   Fractional label.  Upto 3 places after the decimal point allowed
C   Muck around to get the superscript on top of the decimal point
C
          IR1 = INT(RVAL)
          IR2 = NINT((RVAL - IR1) * 10**SPREC)
          FRMAT = '(I2, A1, A, '//FRMAT2(SPREC)//')'
          WRITE (FIELD, FRMAT(1:15)) 
     *                       IR1, '.',
     *                       BSL//'b'//SUPER(4,SUPPNT)(1:TRLEN(SUPPNT)),
     *                       IR2
          IP = 5 + TRLEN(SUPPNT) + 1
          IF (FIELD(IP:IP).EQ.' ') FIELD(IP:IP) = '0'
          IF (FIELD(IP+1:IP+1).EQ.' ') FIELD(IP+1:IP+1) = '0'
          FMAX = 1 + 2 + SPREC
        ELSE
C
C   Integer label.  
C
          WRITE (FIELD, '(I2,A)') NINT(RVAL), 
     *                            SUPER(4,SUPPNT)(1:TRLEN(SUPPNT))
          FMAX = 0
        END IF
        FMAX = FMAX + 2 + TRLEN(SUPPNT)
C
        IF (FIELD(FST:FST).EQ.' ') THEN
          IF (DO2) THEN
            FIELD(FST:FST) = '0'
          ELSE
            FST = FST + 1
          END IF
        END IF
        FLEN = FMAX - FST + 1
C
C   Write output text string
C
        TMPNT = 2
        IF (SIGNF.EQ.'S' .AND. ASIGN.NE.' ') TMPNT = 1
        TMP = ASIGN//FIELD(FST:FMAX)
        TLEN2 = (3 - TMPNT) + FLEN
C
        TEXT(TLEN+1:) = TMP(TMPNT:TMPNT+TLEN2-1)
        TLEN = TLEN + TLEN2
      END IF
C  
C   A trailing blank will occur if no superscripting wanted
C
      IF (TLEN.GE.5 .AND. TEXT(TLEN-4:TLEN).EQ.BSL//'u'//' '//BSL//'d')
     *   TLEN = TLEN - 5
C      
      RETURN
      END
