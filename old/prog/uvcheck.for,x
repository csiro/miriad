c**********************************************************************c
	program uvcheck
	implicit none
c= UVCHECK - check uv-data selection and uv-variable values.
c& mchw
c: uv analysis, checking, flagging
c+
c	UVCHECK is a Miriad program to check the uv-data.
c	The default is to read through the selected uv-data and report the
c	times when the source, freq, or number of channels change. 
c       The number of records read and the uv and date range are listed.
c       The range of values and statistics of a selected variable can 
c	also be listed. uv-data may be flagged directly if a variable is 
c	out of range or the amplitude of a reference channel is out of range.
c@ vis
c	The input visibility file. No default.
c@ select
c	This selects which visibilities to be used. Default is
c	all visibilities. See the Users Guide for information about
c	how to specify uv data selection.
c@ line
c	Linetype of the data in the format line,nchan,start,width,step
c	"line" can be `channel', `wide' or `velocity'.
c	Default is channel,0,1,1,1, which returns actual number of spectral
c	channels. Use line=wide to check number of wideband correlations.
c	If the linetype requested is not present it will NOT be listed.
c@ ref
c	Reference line for flagging data.
c	Allowed values are:
c	    channel,start,width
c           wide,start,width
c       with 'start' and 'width' integers
c	Default: no reference line.
c@ refamp
c       Range of amplitude in the reference line used to set the flags
c       of all the data in that record outside this refamp range to the
c       value given by flagval.
c       Two values, reflo and refhi, must be given.
c       Default: 0,0
c@ flagval
c       Either 'flag' or  'unflag' the data based on out-of-range refamp.
c       Default: none.
c@ var
c	Name of uv-variable to check the range of values. Default is none.
c	List mean and rms for values of variable within the range.
c@ range
c	The min and max values for var. Times and values are listed when var
c	is OUTSIDE this range (excluding zero). The mean and rms are listed
c	for values of var INSIDE this range. Default is all data.
c@ log
c	The output log file. Default is the terminal.
c--
c  ToDo:
c	problems flagging the wide band 
c
c  History:
c    mchw 29jun90  Initial version.
c    mchw 29nov90  Used defaults for uvvariables.
c    mchw 20dec90  Check the range in selected uv-variables.
c    mchw 03jan91  Check the range in uv coverage.
c    mchw 09jan91  Changed uvset so uvread returns number of channels.
c    mchw 19mar91  Initialized some variables for cray.
c    mchw 25jun92  Fixed bug for integer variables in checkvar.
c    mchw 22jan93  Changed to keyf('vis'..)
c    mchw 06oct93  Increased MAXLEN in subroutine checkvar.
c    mchw 26oct93  Added checking of ascii variables.
c    rjs  12nov93  Call logclose.
c    mchw 24nov93  Added check on known problems.
c    mchw 15aug94  Increased MAXLEN=144 for systemp(9,16)
c mchw/pjt 21dec94  Added flagging options (ref=, flagval=, refamp=)
c    mchw 22jan95  Tell user how many records flagged.
c    pjt  15mar95  fix decl. order for ansi f2c (linux)
c    mchw 30aug95  List mean and rms for selected variable.
c    mchw 15mar96  uvclose to flush out last flags is needed.
c    rjs  19mar96  minor FORTRAN standardisation.
c    mchw 10aug96  Dimension var buffers (MAXANT*MAXWIDE). Check nwide.
c    mchw 22oct96  Added message about on-line flagging.
c    mchw 12nov96  another MAXWIDE needed in subroutine uvxflag.
c----------------------------------------------------------------------c
	include 'maxdim.h'
	character*(*) version
	parameter(version='UVCHECK: version 1.0 12-NOV-96')
	integer maxsels, ochan, nbugs, nflag, nwflag
	parameter(MAXSELS=512)
	real sels(MAXSELS)
	complex data(MAXCHAN)
	double precision preamble(4),freq,ofreq
	integer lIn,nchan,nread,nvis,nspect,onspect,varlen,nwide,onwide
	real start,width,step,varmin,varmax,uvdist,uvmin,uvmax
	real refstart, refwidth, reflo, refhi
	character vis*64,log*64,line*80,date*18,var*9,vartype*1
	character source*9,osource*9,linetype*20,refline*20,flagval*10
	logical flags(MAXCHAN),varcheck,updated,doflag,varflag,newflag
	logical dowide
	integer nvar
	real ave,rms
c
c  Externals and data
c
	integer len1
	data osource,ochan,onspect,onwide,ofreq/' ',0,0,0,0./
	data nvar,ave,rms/0,0.,0./
c
c  Get the parameters given by the user.
c
	call output(version)
	call keyini
	call keyf ('vis',vis,' ')
	call keyline(linetype,nchan,start,width,step)
	call keyrline(refline,refstart,refwidth)
	call keya ('flagval',flagval,' ')
	call keyr ('refamp',reflo,0.0)
	call keyr ('refamp',refhi,0.0)
	call SelInput ('select',sels,maxsels)
	call keya ('var',var,' ')
	call keyr ('range',varmin,0.)
	call keyr ('range',varmax,0.)
	call keya ('log',log,' ')
	call keyfin
c
c  Check that the inputs are reasonable.
c
	if (vis.eq.' ') call bug ('f', 'Input name must be given')
	if (nchan.gt.0) nchan = min (nchan,maxchan)
	if (nchan.lt.0) call bug ('f', 'Bad number of channels')
	if (width.le.0.0) call bug ('f','Negative width is useless')
	if (step.eq.0.0) call bug ('f', 'Step=0.0 is useless') 
        doflag = flagval.eq.'flag' .or. flagval.eq.'unflag'
        newflag = flagval.eq.'unflag'
c
c  Open an old visibility file, and apply selection criteria.
c
	call uvopen (lIn,vis,'old')
c
	varcheck=var.ne.' '
	if(varcheck)call uvprobvr(lIn,var,vartype,varlen,updated)
	if(vartype.eq.' ')then
	  write(line,'(a)') '"'//var//'" is not in uv-data'
	  call bug('f',line(1:len1(line)))
	endif
c
	if(linetype.ne.' ')
     *	  call uvset(lIn,'data',linetype,nchan,start,width,step)
	call uvset (lIn,'coord','nanosec',0, 0.0, 0.0, 0.0)
	call uvset (lIn,'planet', ' ', 0, 0.0, 0.0, 0.0)
	call SelApply(lIn,sels,.true.)
c
c  Open log file and write title.
c
	call LogOpen(log,'q')
	call LogWrit(version)
	line = 'File: '//vis
	call LogWrit(line(1:len1(line)))
	call LogWrit(' ')
c
c  Append history if flagging was going to occur
c
        call hisopen(lin,'append')
        call hiswrite(lin, version)
        call hisinput(lin, 'UVCHECK')

c
c  Miscelaneous initialization.
c
	nvis = 0
	uvmin = 1.e9
	uvmax = 0.
	nbugs = 0
	nflag = 0
	nwflag = 0
c
c  Read the first record.
c
	call uvread (lIn, preamble, data, flags, maxchan, nread)
	if(nread.le.0) call bug('f','No data found in the input.')
c
c  Read the selected data.
c
	do while(nread.gt.0)
	  call JulDay(preamble(3),'H',date)
	  call uvrdvra(lIn,'source',source,' ')
	  call uvrdvri(lIn,'nspect',nspect,0)
	  call uvrdvri(lIn,'nwide',nwide,0)
	  call uvrdvrd(lIn,'freq',freq,0.d0)
c
c  Check if source, freq, or number of channels or spectra change.
c
	  if(source.ne.osource .or. nread.ne.ochan .or.
     *		nspect.ne.onspect .or.nwide.ne.onwide .or.
     *		freq.ne.ofreq) then
	    write(line,'(a,x,a,a,i6,a,i4,a,i4,a,f10.6)') date,source,
     *	    ' nchan=',nread,' nspect=',nspect,' nwide=',nwide,
     *	    ' freq=',freq
	    call LogWrit(line)
	    osource = source
	    onspect = nspect
	    onwide = nwide
	    ofreq = freq
	    ochan = nread
	  endif
c
c  Get uvrange.
c
	  uvdist = sqrt(preamble(1)*preamble(1)+preamble(2)*preamble(2))
	  uvmin = min(uvdist,uvmin)
	  uvmax = max(uvdist,uvmax)
c
c  Check variables if requested.
c
          varflag = .FALSE.
	  if(varcheck) call checkvar(
     *			lIn,date,var,varmin,varmax,varflag,nvar,ave,rms)
c
c  Check for known problems in the data.
c
	  call uvprobvr(lIn,'time',vartype,varlen,updated)
	  if(updated)call checkbug(lin,date,nbugs)
c
c  Flag the data, if requested
c
          if (doflag) then
	     call uvprobvr(lIn,'wcorr',vartype,varlen,dowide)
             dowide = dowide .and. linetype.eq.'channel'
	     call uvxflag(lIn, data, flags, nread, dowide,
     *              refline, refstart, refwidth, reflo, refhi, newflag,
     *              varflag, nflag, nwflag)
	  endif
c
c  Loop the loop (get next record)
c
	  call uvread(lIn, preamble, data, flags, maxchan, nread)
	  nvis = nvis + 1
	enddo
c
c  Write summary.
c
      write(line,'(a,a,i6)') date,' number of records= ',nvis
      call LogWrit(line)
      write(line,'(a,2f10.0,a)') ' uvrange=(',uvmin,uvmax,') nanosecs'
      call LogWrit(line)
      write(line,'(i6,a)') nbugs, ' known problems in this data'
      call LogWrit(line)
      write(line,'(i10,a)') nflag,  ' channels flagged'
      call LogWrit(line)
      write(line,'(i10,a)') nwflag, ' wideband flagged'
      call LogWrit(line)
	if(nvar.gt.0)then
	  ave = ave/nvar
	  rms = sqrt(rms/nvar - ave*ave)
	  call LogWrit(' ')
	  write(line,'(a,a,i6,a,a,g13.3,a,g13.3)') 
     *      var,' :', nvar,' in range.', ' Average=', ave, ' rms=', rms
	  call LogWrit(line)
	endif
      call LogClose
c
	call hisclose (lIn)
	call uvclose (lIn)
      end
c********1*********2*********3*********4*********5*********6*********7**
	subroutine checkvar(
     *			lIn,date,var,varmin,varmax,varflag,nvar,ave,rms)
	implicit none
	character*(*) date,var
	integer lIn,nvar
	real varmin,varmax,ave,rms
        logical varflag
c
c  Check range of values in uv-variable.
c
c  Input:
c    lIn	Handle of the input uv-data file.
c    date	Date and time of current record.
c    var	Name of uv-variable.
c    varmin	Minimum acceptable value.
c    varmax	Maximum acceptable value.
c  Output
c    varflag    variable out of range?
c    nvar	number of variable in range.
c    ave	sum for variable in range.
c    rms	sum of squares for variable in range.
c-----------------------------------------------------------------------
        include 'maxdim.h'
	integer varlen,i
	real data(MAXANT*MAXWIDE)
	integer idata(MAXANT*MAXWIDE)
 	double precision ddata(MAXANT*MAXWIDE)
	character vartype*1,line*80,avar*20,avar1*20
	logical updated
c
c  External.
c
	integer len1
	data avar1/'                   '/

      varflag = .FALSE.
c
c  Get the type and length of the variable to be checked.
c
      call uvprobvr(lIn,var,vartype,varlen,updated)
      if(updated.and.varlen.gt.MAXANT*MAXWIDE)then
         write(line,'(a,i3,a,i3,a)')
     *	 'checking first ',MAXANT*MAXWIDE,' out of ',varlen,' values'
         call LogWrit(line)
         varlen=MAXANT*MAXWIDE
      else if(.not.updated)then
         return
      endif
c
c  Get the data to be checked.
c
      if(vartype.eq.'d') then
	  call uvgetvrd(lIn,var,ddata,varlen)
      else if(vartype.eq.'r') then
	  call uvgetvrr(lIn,var,data,varlen)
	  do i=1,varlen
	    ddata(i)=data(i)
	  enddo
      else if(vartype.eq.'i') then
	  call uvgetvri(lIn,var,idata,varlen)
	  do i=1,varlen
	    ddata(i)=idata(i)
          enddo
      else if(vartype.eq.'a') then
	  call uvgetvra(lIn,var,avar)
      else
	  call output('unknown variable type')
      endif
c
c  Check the values.
c
      if(vartype.eq.'a') then
          varflag = .TRUE.
	  if(avar.ne.avar1)then
	    write(line,'(a,x,a,a,a)')
     *			date,var(1:len1(var)),' = ',avar
	    call LogWrit(line)
	    avar1 = avar
	  endif
      else
	 do i=1,varlen
	  if(ddata(i).ne.0.d0 .and.
	  ((ddata(i).le.dble(varmin).or.ddata(i).ge.dble(varmax)))then
            varflag = .TRUE.
	    write(line,'(a,x,a,a,i3,a,g13.5)')
     *			date,var(1:len1(var)),'(',i,') = ',ddata(i)
	    call LogWrit(line)
	  endif
c
c  Accumulate mean and rms inside range.
c
	  if((varmin.eq.varmax).or.
     *	    (ddata(i).gt.dble(varmin).and.ddata(i).lt.dble(varmax)))then
	    nvar = nvar + 1
	    ave = ave + ddata(i)
	    rms = rms + ddata(i)*ddata(i)
	  endif
	 enddo
      endif

      end
c********1*********2*********3*********4*********5*********6*********7**
      subroutine checkbug(tvis,date,nbugs)
	implicit none
	integer tvis,nbugs
	character*(*) date
c
c  Check for known problems in the data.
c
c  Input:
c    tvis	Handle of the visibility file.
c    date	Date and time of current record.
c    nbugs	Number of bugs
c-----------------------------------------------------------------------
	character line*120
	double precision time
	integer length,i,nants
	double precision antpos(27),taudot(9)
	double precision longitude,latitude,lst,obsdec,obsra,hdot
	logical ok,updated,notify/.true./
	real cosh,sinh,cosd,sind
	character telescop*9,type*1
	parameter(HDOT = 7.272205216e-5 * 1.002737894)
c
c  Get the telescope parameters
c
	call uvrdvra(tvis,'telescop',telescop,'UNKNOWN')
	call obspar(telescop,'longitude',longitude,ok)
	call obspar(telescop,'latitude',latitude,ok)
	call uvgetvrd(tvis,'time',time,1)
	if(telescop.eq.'HATCREEK'.and.notify
     *		.and.(time.lt.2450373.5))then
	  notify=.false.
	  line='shadowed data was not flagged on-line before 96OCT17'
          call LogWrit(line)
	else if(telescop.eq.'HATCREEK'
     *		.and.(time.gt.244900.5.and.time.lt.2449314.5))then
	  call uvgetvri(tvis,'nants',nants,1)
	  call uvgetvrd(tvis,'antpos',antpos,3*nants)
	  call uvprobvr(tvis,'lst',type,length,updated)
	  if(type.eq.'d')then
	    call uvrdvrd(tvis,'lst',lst,0.d0)
	  else
	    call obspar(telescop,'longitude',longitude,ok)
	    if(ok)then
	      call JulLst(time,longitude,lst)
	    else
	      lst = 0.d0
	    endif
	  endif
	  call uvrdvrd(tvis,'obsra',obsra,0.d0)
	  call uvrdvrd(tvis,'obsdec',obsdec,0.d0)
	  cosh = cos(lst-obsra)
	  sinh = sin(lst-obsra)
	  cosd = cos(obsdec)
	  sind = sin(obsdec)
	  do i=1,nants
	    taudot(i) = -HDOT*
     *		(-antpos(i)*cosd*sinh-antpos(i+nants)*cosd*cosh)
	    if(abs(taudot(i)).gt.0. .and. abs(taudot(i)).lt.1e-6)then
	      nbugs = nbugs+1
	      write(line,'(a,a,x,a,i1,a)')
     *			 'bad delay> ', date, 'ant(', i, ')'
	      call LogWrit(line)
	    endif
	  enddo
	endif
	end
c********1*********2*********3*********4*********5*********6*********7*c
        subroutine uvxflag(lIn, data, flags, nread, dowide,
     *              refline, refstart, refwidth, reflo, refhi, newflag,
     *              varflag, nflag, nwflag)
	implicit none
        integer lIn, nread, nflag, nwflag
        complex data(nread)
        logical flags(nread), varflag, newflag, dowide
        character refline*(*)
        real refstart, refwidth, reflo, refhi
c
c  flag data based on out of range variable or out of range amp of ref line
c
c--
	include 'maxdim.h'
        complex wdata(MAXWIDE)
        logical ampflag, wflags(MAXWIDE), refamp
        integer nwread, i
        character lrefline*10

	if (dowide) call uvwread(lIn,wdata,wflags,MAXWIDE,nwread)

        ampflag = refline.ne.' '
        if (.not.varflag .and. ampflag) then
            if (refline.eq.'wide') then
               ampflag = refamp(nwread,wdata,wflags,
     *                          refstart,refwidth,reflo,refhi)
            else if (refline.eq.'channel') then
               ampflag = refamp(nread,data,flags,
     *                          refstart,refwidth,reflo,refhi)
            else 
               lrefline = refline
               call bug('f','ref= not channel or wide: '//lrefline)
            endif
        endif


        if (varflag .or. ampflag) then
c+debug
c      write(*,*) '### Flagging record',varflag,ampflag,newflag,dowide
           do i=1,nread
              flags(i) = newflag
           enddo
           call uvflgwr(lIn,flags)
	   nflag = nflag + nread
	   if (dowide) then
              do i=1,nwread
                 wflags(i) = newflag
              enddo
              call uvwflgwr(lIn,wflags)
	      nwflag = nwflag + nwread
	   endif
        endif
      end
c********1*********2*********3*********4*********5*********6*********7*c
      logical function refamp(nread,data,flags,
     *                          refstart,refwidth,reflo,refhi)
	implicit none
        integer nread
        complex data(nread)
        logical flags(nread)
        real refstart, refwidth, reflo, refhi
c
c  return TRUE if the reference amplitude of ref line is out of range
c  currently kludged for integer arithmetic on the contruction of the
c  line
c--
        integer istart, iwidth, cnt, i
        real amp
        complex sum
      
        istart = refstart
        iwidth = refwidth

        sum = cmplx(0.0,0.0)
        cnt = 0
        do i=istart,istart+iwidth-1
          if (flags(i)) then
            sum = sum + data(i)
            cnt = cnt + 1
          endif
        enddo
        if (cnt.gt.0) then
          sum = sum / float(cnt)
          amp = cabs(sum)
          refamp = amp.lt.reflo .or. amp.gt.refhi
        else
          refamp = .TRUE.
        endif
      end
c********1*********2*********3*********4*********5*********6*********7*c
