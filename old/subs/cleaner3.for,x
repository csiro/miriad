c************************************************************************
	subroutine Cleaner3(tScr,nvis,ipol,npol,Map,nx,ny,nz,
     *			Bm,bnx,bny,bnz,gain,cutoff,maxiters,minor,
     *			cdelt1,cdelt2,cdelt3,xymax,zmax,xymin,zmin)
c
	implicit none
	integer tScr,ipol,npol,nvis,nx,ny,nz,bnx,bny,bnz,maxiters,minor
	real gain,cutoff,cdelt1,cdelt2,cdelt3
	real xymax,zmax,xymin,zmin
	integer Map
	real Bm(bnx,bny,bnz)
c
c  Do a series of MX cycles.
c------------------------------------------------------------------------
	include 'maxdim.h'
	include 'mem.h'
	include 'mirconst.h'
	integer MAXCMP,MAXPATCH,MINPATCH
	parameter(MAXCMP=50000,MAXPATCH=65,MINPATCH=33)
	integer iCmp,jCmp,kCmp,nCmp,tCmp,rCmp,cCmp
	real Histo(MAXPATCH/2+1)
c
	real totflux,amax,xyfwhm,zfwhm
	integer niters
	logical more
c
	totflux = 0
	niters = 0
	tCmp = 0
c
c  Fit the beam first off.
c
	call fit3(Bm,bnx,bny,bnz,xyfwhm,zfwhm)
c
c  Allocate memory for the components.
c
	call memAlloc(iCmp,MAXCMP+MAXITERS,'i')
	call memAlloc(jCmp,MAXCMP+MAXITERS,'i')
	call memAlloc(kCmp,MAXCMP+MAXITERS,'i')
	call memAlloc(cCmp,MAXCMP+MAXITERS,'r')
	call memAlloc(rCmp,MAXCMP,         'r')
c
c  Determine the histogram of the beam.
c
	call BmHisto3(Bm,bnx,bny,bnz,Histo,MAXPATCH)
c
c  Start to CLEAN.
c
	call output(' ')
	call output('Forming the initial dirty image ...')
	call Mapper3(ipol+1,Map)
	call Stats3(memr(Map),nx*ny*nz,amax,totflux,niters)
c
	more = amax.gt.cutoff
	dowhile(more)
c
c  Do the minor cycles.
c
	  call Clark3(nx,ny,nz,memr(Map),bnx,bny,bnz,Bm,
     *	    Histo,MAXPATCH,MINPATCH,niters,min(maxiters,niters+minor),
     *	    cutoff,gain,
     *	    totflux,memi(iCmp+tCmp),memi(jCmp+tCmp),memi(kCmp+tCmp),
     *	    memr(rCmp),memr(cCmp+tCmp),MAXCMP,nCmp,
     *	    xymax,zmax,xymin,zmin)
c
c  Subtract the components.
c
	  call output('Subtracting the components ...')
	  call Sub3(tScr,nvis,ipol,npol,
     *	    memi(iCmp+tCmp),memi(jCmp+tCmp),memi(kCmp+tCmp),
     *	    memr(cCmp+tCmp),memr(rCmp),nCmp,
     *	    cdelt1,cdelt2,cdelt3)
c
	  tCmp = tCmp + nCmp
c
c  Form the residuals, and give statistics.
c
	  call output('Forming residuals ...')
	  call Mapper3(ipol+1,Map)
	  call Stats3(memr(Map),nx*ny*nz,amax,totflux,niters)
c
c  Loop?
c
	  more = amax.gt.cutoff.and.niters.lt.maxiters
	enddo
c
c  Now restore it.
c
	call output('Finished CLEANing, now restoring ...')
	call rest3(memr(Map),nx,ny,nz,xyfwhm,zfwhm,
     *		memi(iCmp),memi(jCmp),memi(kCmp),memr(cCmp),tCmp)
c
c  Release the saved residuals list.
c
c
c  Allocate memory for the components.
c
	call memFree(iCmp,MAXCMP+MAXITERS,'i')
	call memFree(jCmp,MAXCMP+MAXITERS,'i')
	call memFree(kCmp,MAXCMP+MAXITERS,'i')
	call memFree(cCmp,MAXCMP+MAXITERS,'r')
	call memFree(rCmp,MAXCMP,         'r')
c
	end
c************************************************************************
	subroutine Stats3(Resid,n,amax,totflux,niters)
c
	implicit none
	integer n,niters
	real Resid(n),amax,totflux
c
c------------------------------------------------------------------------
	integer i,length
	character line*72
	real maxv,minv,rms2
c
c  Externals.
c
	integer len1
	character itoaf*8
c
	maxv = Resid(1)
	minv = Resid(1)
	rms2 = 0
	do i=1,n
	  maxv = max(maxv,Resid(i))
	  minv = min(minv,Resid(i))
	  rms2 = rms2 + Resid(i)*Resid(i)
	enddo
	rms2 = sqrt(rms2/n)
c
	amax = max(abs(maxv),abs(minv))
	write(line,10)totflux
  10	format('Total CLEANed flux of',1pe10.3)
	length = len1(line)
	line(length+1:) = ' Jy after '//itoaf(niters)
	length = len1(line)
	line(length+1:) = ' iterations'
	call output(line)
	write(line,20)maxv,minv,rms2
  20	format('Residual Max:',1pe10.3,', Min:',1pe11.3,
     *						', Rms:',1pe10.3)
	call output(line)
	call output(' ')
	end
c************************************************************************
	subroutine Sub3(tScr,nvis,ipol,npol,iCmp,jCmp,kCmp,cCmp,
     *	  tmp,nCmp,cdelt1,cdelt2,cdelt3)
c
	implicit none
	integer tScr,ipol,npol,nCmp,nvis
	integer iCmp(nCmp),jCmp(nCmp),kCmp(nCmp)
	real cCmp(nCmp),tmp(nCmp)
	real cdelt1,cdelt2,cdelt3
c
c  Subtract the components from the visibility data.
c
c  Input:
c    tScr	Handle of the visibility scratch file.
c    nvis	Number of visibilities.
c    ipol	Polarisation number to process.
c    npol	Total number of poarlisations.
c    nCmp	Total number of components.
c    i,j,kCmp	Pixel coordinates of the components.
c    cCmp	Flux of the components.
c    cdelt	Increment between pixels (radians).
c  Scratch:
c    tmp
c------------------------------------------------------------------------
	include 'mirconst.h'
	integer MAXRUN
	parameter(MAXRUN=4096)
	integer InU,InV,InW,InSMat,InRms2,InDisk,InWt,InData
	parameter(InU=0,InV=1,InW=2,InSMat=3,InRms2=4,InDisk=4)
	parameter(InWt=6,InData=8)
c
	integer size,step,k,l,m,n,idx,InRp,InIp,i,sidx
	real uu,vv,ww,theta,Wt,Vis(MAXRUN)
	real csum,ssum
c
c  Externals.
c
	logical plShadow
c
	size = InData + 2*npol
	step = MAXRUN/size
	if(step.le.0)call bug('f','Something is screwy in Sub')
	InRp = InData + 2*(ipol-1)
	InIp = InRp + 1
c
c  Do the real work.
c
	sidx = 0
	do l=1,nvis,step
	  n = min(nvis-l+1,step)
	  call scrread(tscr,Vis,(l-1)*size,n*size)
	  k = 1
	  do m=1,n
	    uu = 2*pi*Vis(k+InU)
	    vv = 2*pi*Vis(k+InV)
	    ww = 2*pi*Vis(k+InW)
	    Wt = Vis(k+InWt)
	    idx = nint(Vis(k+InSMat))
c
c  Determine the shadowed flux. Save this in case we need it next sample.
c
	    if(idx.ne.sidx)then
	      do i=1,nCmp
		if(plShadow(idx,cdelt1*iCmp(i),
     *		 cdelt2*jCmp(i),cdelt3*kCmp(i)))then
		  tmp(i) = 0
		else
		  tmp(i) = cCmp(i)
		endif
	      enddo
	      sidx = idx
	    endif
c
c  Generate the model visibility.
c
	    csum = 0
	    ssum = 0
	    do i=1,nCmp
	      theta = iCmp(i)*uu + jCmp(i)*vv + kCmp(i)*ww
	      csum = csum + tmp(i)*cos(theta)
	      ssum = ssum + tmp(i)*sin(theta)
	    enddo
	    Vis(k+InRp) = Vis(k+InRp) - Wt*csum
	    Vis(k+InIp) = Vis(k+InIp) - Wt*ssum
	    k = k + size
	  enddo
	  call scrwrite(tscr,Vis,(l-1)*size,n*size)
	enddo
c
	end
c************************************************************************
	subroutine BmHisto3(Beam,bnx,bny,bnz,Histo,maxPatch)
c
	implicit none
	integer bnx,bny,bnz,maxPatch
	real Histo(maxPatch/2+1)
	real Beam(bnx,bny,bnz)
c
c------------------------------------------------------------------------
	integer imin,imax,jmin,jmax,kmin,kmax,i,j,k,n,ic,jc,kc,l
c
	n = MaxPatch/2
	ic = bnx/2 + 1
	jc = bny/2 + 1
	kc = bnz/2 + 1
	imin = max(1, ic-n)
	imax = min(ic+n,bnx)
	jmin = max(1, jc-n)
	jmax = min(jc+n,bny)
	kmin = max(1, kc-n)
	kmax = min(kc+n,bnz)
c
	do l=1,n+1
	  Histo(l) = 0
	enddo
c
	do k=kmin,kmax
	  do j=jmin,jmax
	    do i=imin,imax
	      l = max(abs(i-ic),abs(j-jc),abs(k-kc)) + 1
	      Histo(l) = max(Histo(l),abs(Beam(i,j,k)))
	    enddo
	  enddo
	enddo
c
c  Now Histo(l) contains the max abs value occuring at a distance l.
c  Collapse this so that Histo(l) contains the max abs value
c  occuring at a distance greater or equal to l.
c
	do l=n,1,-1
	  Histo(l) = max(Histo(l),Histo(l+1))
	enddo
c
c  Check that Histo(1) is 1.
c
	if(abs(Histo(1)-1).gt.0.001)
     *	  call bug('f','Max value in the beam is not at the centre')
	end
c************************************************************************
	subroutine GetComp3(Resid,nx,ny,nz,Limit,
     *	  iCmp,jCmp,kCmp,rCmp,maxCmp,nCmp,xymax,zmax,xymin,zmin)
c
	implicit none
	integer nx,ny,nz,maxCmp,nCmp
	integer iCmp(maxCmp),jCmp(maxCmp),kCmp(maxCmp)
	real Resid(nx,ny,nz),rCmp(maxCmp)
	real xymax,zmax,xymin,zmin,Limit
c
c  Extract those pixels that are greater than a threshold.
c
c------------------------------------------------------------------------
	integer i,j,k,ic,jc,kc,ka,ja,ia
c
	kc = nz/2 + 1
	jc = ny/2 + 1
	ic = nx/2 + 1
c
	nCmp = 0
	do k=1,nz
	  ka = abs(k-kc)
	  if(ka.lt.zmax)then
	    do j=1,ny
	      ja = abs(j-jc)
	      if(ja.lt.xymax)then
	        do i=1,nx
		  ia = abs(i-ic)
		  if((abs(Resid(i,j,k)).gt.Limit).and.
     *		     (ja*ja+ia*ia.le.xymax*xymax).and.
     *		     (ka/zmin)**2+(ja/xymin)**2+(ia/xymin)**2.gt.1)then
		    nCmp = nCmp + 1
		    if(nCmp.gt.maxCmp)
     *			call bug('f','Clark comp buffer overflow')
		    rCmp(nCmp) = Resid(i,j,k)
		    iCmp(nCmp) = i - ic
		    jCmp(nCmp) = j - jc
		    kCmp(nCmp) = k - kc
		  endif
	        enddo
	      endif
	    enddo
	  endif
	enddo
c
	end
c************************************************************************
	subroutine GetLim3(Resid,nx,ny,nz,maxCmp,Histo,maxPatch,
     *	  nPatch,Limit,xymax,zmax,xymin,zmin)
c
	implicit none
	integer nx,ny,nz,maxCmp,maxPatch,nPatch
	real Resid(nx,ny,nz),Histo(maxPatch/2+1),Limit
	real xymax,zmax,xymin,zmin
c
c  Determine the threshold for components to CLEAN.
c
c------------------------------------------------------------------------
	integer HistSize
	parameter(HistSize=512)
c
	integer i,j,k,m,Acc,ic,jc,kc,ia,ja,ka
	real a,b,ResHis(HistSize),amax,amin,x
c
	ic = nx/2 + 1
	jc = ny/2 + 1 
	kc = nz/2 + 1
c
c  Determine the abs max residual.
c
	amax = 0
	do k=1,nz
	  ka = abs(k-kc)
	  if(ka.lt.zmax)then
	    do j=1,ny
	      ja = abs(j-jc)
	      if(ja.lt.xymax)then
	        do i=1,nx
		  ia = abs(i-ic)
		  if((ja*ja+ia*ia.le.xymax*xymax).and.
     *		     (ka/zmin)**2+(ja/xymin)**2+(ia/xymin)**2.gt.1)then
		    amax = max(amax,abs(Resid(i,j,k)))
		  endif
	        enddo
	      endif
	    enddo
	  endif
	enddo
c
	amin = amax * Histo(maxPatch/2+1)
	a =(HistSize-2)/(amax-amin)
	b = 2 - a * amin
c
	do i=1,HistSize
	  ResHis(i) = 0
	enddo
c
	do k=1,nz
	  ka = abs(k-kc)
	  if(ka.lt.zmax)then
	    do j=1,ny
	      ja = abs(j-jc)
	      if(ja.lt.xymax)then
	        do i=1,nx
		  ia = abs(i-ic)
		  if((ja*ja+ia*ia.le.xymax*xymax).and.
     *		     (ka/zmin)**2+(ja/xymin)**2+(ia/xymin)**2.gt.1)then
		    m = max(int(a*abs(Resid(i,j,k))+b), 1)
		    ResHis(m) = ResHis(m) + 1
		  endif
	        enddo
	      endif
	    enddo
	  endif
	enddo
c
c  Now work out where to set the limit.
c
	Acc = 0
	m = HistSize + 1
	dowhile(Acc.le.maxCmp.and.m.gt.0)
	  m = m - 1
	  Acc = Acc + ResHis(m)
	enddo
	m = m + 1
	Limit = (m - b) / a
c
c  Now work out what the corresponding beam patch size is.
c
	nPatch = 1
	x = Limit / amax
	dowhile(nPatch.lt.maxPatch/2.and.x.lt.Histo(nPatch))
	  nPatch = nPatch + 1
	enddo
c
	end
c************************************************************************
	subroutine SubComp3(bnx,bny,bnz,Beam,
     *	  iCmp,jCmp,kCmp,rCmp,cCmp,nCmp,
     *	  niters,maxiters,npatch,limit,gain,totflux)
c
	implicit none
	integer bnx,bny,bnz,nPatch,nCmp,niters,MAXITERS
	integer iCmp(nCmp),jCmp(nCmp),kCmp(nCmp)
	real rCmp(nCmp),cCmp(nCmp),Beam(bnx,bny,bnz)
	real limit,gain,totflux
c
c  The inner iterations of a Clark Clean.
c------------------------------------------------------------------------
	integer l,ic,ipkd,jc,jpkd,kc,kpkd,pk
	integer imin,imax,jmin,jmax,kmin,kmax
	real flux,fac

c
	ic = bnx/2 + 1
	jc = bny/2 + 1
	kc = bnz/2 + 1
	fac = 1
c
	call GetPk3(nCmp,rCmp,pk)
	flux = rCmp(pk)
c
	dowhile(abs(flux).gt.fac*limit.and.niters.lt.MAXITERS)
	  niters = niters + 1
	  fac = fac + 1.0/real(niters)
	  flux = gain * flux
	  cCmp(pk) = cCmp(pk) + flux
	  totflux = totflux + flux
	  ipkd = iCmp(pk) - ic
	  jpkd = jCmp(pk) - jc
	  kpkd = kCmp(pk) - kc
	  imin = iCmp(pk) - npatch
	  imax = iCmp(pk) + npatch
	  jmin = jCmp(pk) - npatch
	  jmax = jCmp(pk) + npatch
	  kmin = kCmp(pk) - npatch
	  kmax = kCmp(pk) + npatch
	  do l=1,nCmp
	    if(iCmp(l).ge.imin.and.iCmp(l).le.imax.and.
     *	       jCmp(l).ge.jmin.and.jCmp(l).le.jmax.and.
     *	       kCmp(l).ge.kmin.and.kCmp(l).le.kmax)then
	      rCmp(l) = rCmp(l) - flux *
     *		Beam(iCmp(l)-ipkd,jCmp(l)-jpkd,kCmp(l)-kpkd)
	    endif
	  enddo
	  call Getpk3(nCmp,rCmp,pk)
	  flux = rCmp(pk)
	enddo
c
	end
c************************************************************************
	subroutine GetPk3(nCmp,rCmp,pk)
c
	implicit none
	integer nCmp,pk
	real rCmp(nCmp)
c------------------------------------------------------------------------
	integer i
	real t
c
	t = abs(rCmp(1))
	pk = 1
	do i=2,nCmp
	  if(abs(rCmp(i)).gt.t)then
	    pk = i
	    t = abs(rCmp(i))
	  endif
	enddo
c
	end
c************************************************************************
	subroutine Clark3(nx,ny,nz,Resid,bnx,bny,bnz,Beam,
     *	  Histo,maxPatch,minPatch,niters,MAXITERS,cutoff,gain,totflux,
     *	  iCmp,jCmp,kCMp,rCmp,cCmp,maxCmp,nCmp,
     *	  xymax,zmax,xymin,zmin)
c
	implicit none
	integer nx,ny,nz,bnx,bny,bnz,minPatch,maxPatch
	integer niters,MAXITERS
	real cutoff,gain,totflux
	real Resid(nx,ny,nz),Beam(bnx,bny,bnz)
	real Histo(maxPatch/2+1)
	integer maxCmp,nCmp,iCmp(maxCmp),jCmp(maxCmp),kCmp(maxCmp)
	real rCmp(maxCmp),cCmp(maxCmp)
	real xymax,zmax,xymin,zmin
c
c  Perform the minor iterations of a Clark Clean.
c
c  Input:
c    nx,ny,nz	 Residual image size.
c    Resid	 The residual image.
c    bnx,bny,bnz Beam size.
c    Beam	 The dirty beam.
c    Histo	 Histogram information on the beam.
c    maxPatch	 Max patch size.
c    minPatch    Min patch size.
c    MAXITERS	 Maximum number of iterations.
c    cutoff	 Cutoff limit.
c    gain	 Loop gain.
c    maxCmp	 Max number of components.
c    xymax,zmax	 Max extent, in pixels, of the region to be cleaned.
c    xymin,zmin  Hole in the center containing no emission.
c  Input/Output:
c    niters	 Total number of iterations.
c    totflux	 Total flux CLEANed.
c  Output:
c    iCmp )	 Location of components.
c    jCmp )
c    kCmp )
c    cCmp	 Flux of components.
c    nCmp	 Number of components.
c  Scratch:
c    rCmp	 Used to hold residuals.
c------------------------------------------------------------------------
	real limit
	integer i,n,npatch
	character line*80
c
c  Get the limiting residual and the patch size. Adjust these to agree
c  with what the user has asked for.
c
	call GetLim3(Resid,nx,ny,nz,maxCmp,Histo,maxPatch,npatch,limit,
     *	  xymax,zmax,xymin,zmin)
	npatch = max(npatch,minpatch/2)
	limit = max(limit,0.5*cutoff)
c
c  Extract the residuals above the limit.
c
	call GetComp3(Resid,nx,ny,nz,limit,
     *	  iCmp,jCmp,kCmp,rCmp,maxCmp,nCmp,xymax,zmax,xymin,zmin)
c
c  Initialise the component array.
c
	do i=1,nCmp
	  cCmp(i) = 0
	enddo
c
	write(line,10)nCmp,2*npatch+1
  10	format('Starting minor cycles with',i6,
     *	  ' high pixels and beam patch',i3,' pixels wide')
	call output(line)
c
c  Do the minor cycles.
c
	call SubComp3(bnx,bny,bnz,Beam,iCmp,jCmp,kCmp,rCmp,cCmp,nCmp,
     *	  niters,maxiters,npatch,limit,gain,totflux)
c
c  Squeeze out zero components.
c
	n = 0
	do i=1,nCmp
	  if(cCmp(i).ne.0)then
	    n = n + 1
	    iCmp(n) = iCmp(i)
	    jCmp(n) = jCmp(i)
	    kCmp(n) = kCmp(i)
	    cCmp(n) = cCmp(i)
	  endif
	enddo
c
	nCmp = n
c
	end
c************************************************************************
	subroutine rest3(Resid,nx,ny,nz,xyfwhm,zfwhm,
     *					iCmp,jCmp,kCmp,cCmp,nCmp)
c
	implicit none
	integer nx,ny,nz,nCmp
	integer iCmp(nCmp),jCmp(nCmp),kCmp(nCmp)
	real Resid(nx,ny,nz),cCmp(nCmp),xyfwhm,zfwhm
c
c  Restore the planet.
c------------------------------------------------------------------------
	integer WIDTH
	parameter(WIDTH=13)
	real fx(WIDTH),fz(WIDTH),fxyz(WIDTH,WIDTH,WIDTH)
	integer ioff,joff,koff,hc,hw,l
	integer i,j,k,ic,jc,kc,imin,imax,jmin,jmax,kmin,kmax
	real xscal,zscal,t
c
c  Generate the clean beam.
c
	hc = WIDTH/2 + 1
	xscal = -4*log(2.0)/xyfwhm/xyfwhm
	zscal = -4*log(2.0)/zfwhm/zfwhm
	do i=1,WIDTH
	  fx(i) = exp(xscal*(i-hc)*(i-hc))
	  fz(i) = exp(zscal*(i-hc)*(i-hc))
	enddo
c
	do k=1,WIDTH
	  do j=1,WIDTH
	    do i=1,WIDTH
	      fxyz(i,j,k) = fx(i)*fx(j)*fz(k)
	    enddo
	  enddo
	enddo
c
c  Some constants.
c
	ic = nx/2 + 1
	jc = ny/2 + 1
	kc = nz/2 + 1
c
c  Add the clean beam into the components.
c
	hw = WIDTH/2
	do l=1,nCmp
	  imin = max(iCmp(l) + ic - hw,1)
	  imax = min(iCmp(l) + ic + hw,nx)
	  jmin = max(jCmp(l) + jc - hw,1)
	  jmax = min(jCmp(l) + jc + hw,ny)
	  kmin = max(kCmp(l) + kc - hw,1)
	  kmax = min(kCmp(l) + kc + hw,nz)
	  ioff = iCmp(l) + ic - hw - 1
	  joff = jCmp(l) + jc - hw - 1
	  koff = kCmp(l) + kc - hw - 1
	  t = cCmp(l)
c
	  do k=kmin,kmax
	    do j=jmin,jmax
	      do i=imin,imax
		Resid(i,j,k) = Resid(i,j,k) +
     *			t*fxyz(i-ioff,j-joff,k-koff)
	      enddo
	    enddo
	  enddo
	enddo
c
	end
c************************************************************************
	subroutine fit3(Bm,bnx,bny,bnz,xyfwhm,zfwhm)
c
	implicit none
	integer bnx,bny,bnz
	real Bm(bnx,bny,bnz),xyfwhm,zfwhm
c
c  Fit a gaussian to the beam.
c
c  Input:
c    Bm		 The beam.
c    bnx,bny,bnz Dimensions of the beam.
c  Output:
c    xyfwhm	 Beam FWHM in the x and Y dimensions, in pixels.
c    zfwhm	 Beam FWHM in the z direction, in pixels.
c------------------------------------------------------------------------
	include 'cleaner3.h'
	real THRESH
	parameter(THRESH=0.1)
	integer hw,i,ifail1,ifail2
	real covar(2,2),x(2),t,det,rms
	double precision sum1,sum2,sum11,sum12,sum22
c
c  Externals.
c
	external FCN3
c
c
c  Extract points from the central lobe that are above the threshold.
c
	npnt = 0
	hw = WIDTH/2
	call doxyz3(Bm,bnx,bny,bnz,THRESH,hw)
	if(npnt.eq.0)call bug('f','Failed to find beam main lobe!')
c
c  Solve the log equations to get initial estimates of the solution.
c
	sum1 = 0
	sum2 = 0
	sum11 = 0
	sum12 = 0
	sum22 = 0
c
	do i=1,npnt
	  t = log(f(i))
	  sum1 = sum1 + xy(i)*t
	  sum2 = sum2 + z(i)*t
	  sum11 = sum11 + xy(i)*xy(i)
	  sum12 = sum12 + xy(i)*z(i)
	  sum22 = sum22 + z(i)*z(i)
	enddo
c
	det = sum11*sum22 - sum12*sum12
	x(1) = (Sum22*Sum1 - Sum12*Sum2) / det
	x(2) = (Sum11*Sum2 - Sum12*Sum1) / det
c
c  Call a proper least-squares solver now.
c
	call lsqfit(FCN3,npnt,2,x,covar,rms,ifail1,ifail2)
	if(ifail1.ne.0)call bug('w','Beam fitter failed to converge')
	xyfwhm = sqrt(abs(4*log(2.0)/x(1)))
	zfwhm  = sqrt(abs(4*log(2.0)/x(2)))
c
	end
c************************************************************************
	subroutine fcn3(m,n,x,fvec,iflag)
c
	implicit none
	integer m,n,iflag
	real x(n),fvec(m)
c
c  Determine the mismatch.
c------------------------------------------------------------------------
	include 'cleaner3.h'
	integer i
c
	if(n.ne.2.and.m.ne.npnt)
     *	  call bug('f','Somthing is screwy in FCN')
c
	do i=1,npnt
	  fvec(i) = f(i) - exp(x(1)*xy(i)+x(2)*z(i))
	enddo
c
	end
c************************************************************************
	subroutine doxyz3(Bm,bnx,bny,bnz,THRESH,hw)
c
	implicit none
	integer bnx,bny,bnz,hw
	real Bm(bnx,bny,bnz),THRESH
c------------------------------------------------------------------------
	integer ic,jc,kc,k
	logical ok
c
	ic = bnx/2 + 1
	jc = bny/2 + 1
	kc = bnz/2 + 1
c
	k = kc
	ok = .true.
	dowhile(k.le.min(bnz,kc+hw))
	  ok = Bm(ic,jc,k).gt.THRESH
	  if(ok)call doxy3(Bm(1,1,k),bnx,bny,k-kc,THRESH,hw)
	  k = k + 1
	enddo
c
	k = kc - 1
	ok = .true.
	dowhile(ok.and.k.ge.max(1,kc-hw))
	  ok = Bm(ic,jc,k).gt.THRESH
	  if(ok)call doxy3(Bm(1,1,k),bnx,bny,k-kc,THRESH,hw)
	  k = k - 1
	enddo
c
	end
c************************************************************************
	subroutine doxy3(Bm,bnx,bny,k0,THRESH,hw)
c
	implicit none
	integer bnx,bny,k0,hw
	real Bm(bnx,bny),THRESH
c------------------------------------------------------------------------
	integer ic,jc,j
	logical ok
c
	ic = bnx/2 + 1
	jc = bny/2 + 1
c
	j = jc
	ok = .true.
	dowhile(ok.and.j.le.min(bny,jc+hw))
	  ok = Bm(ic,j).gt.THRESH
	  if(ok)call dox3(Bm(1,j),bnx,j-jc,k0,THRESH,hw)
	  j = j + 1
	enddo
c
	j = jc - 1
	ok = .true.
	dowhile(ok.and.j.ge.max(1,jc-hw))
	  ok = Bm(ic,j).gt.THRESH
	  if(ok)call dox3(Bm(1,j),bnx,j-jc,k0,THRESH,hw)
	  j = j - 1
	enddo
c
	end
c************************************************************************
	subroutine dox3(Bm,bnx,j0,k0,THRESH,hw)
c
	implicit none
	integer bnx,j0,k0,hw
	real Bm(bnx),THRESH
c------------------------------------------------------------------------
	include 'cleaner3.h'
	integer ic,i
	logical ok
c
	ic = bnx/2 + 1
c
	i = ic
	ok = .true.
	dowhile(i.le.min(bnx,ic+hw))
	  ok = Bm(i).gt.THRESH
	  if(ok)then
	    npnt = npnt + 1
	    xy(npnt) = real((i-ic)**2 + j0**2)
	    z(npnt)  = k0*k0
	    f(npnt)  = Bm(i)
	  endif
	  i = i + 1
	enddo
c
	i = ic - 1
	ok = .true.
	dowhile(ok.and.i.ge.max(1,ic-hw))
	  ok = Bm(i).gt.THRESH
	  if(ok)then
	    npnt = npnt + 1
	    xy(npnt) = (i-ic)**2 + j0**2
	    z(npnt)  = k0*k0
	    f(npnt)  = Bm(i)
	  endif
	  i = i - 1
	enddo
c
	end
