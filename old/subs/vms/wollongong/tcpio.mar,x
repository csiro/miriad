	.title	TCPIO

; VMS/Wollongong routines to behave somewhat like BSD socket interface.
; These routines either return 0 (indicating success) or a normal
; VMS condition code (indicating failure).

; History:
;  rjs Dark-ages Original version
;  rjs 24aug89   Changed some subroutine names. Corrected some comments.

	$iodef
io$_socket  	= io$_access
io$_bind	= io$_access ! <1@io$s_fcode>
io$_listen	= io$_access ! <2@io$s_fcode>
io$_accept	= io$_access ! <3@io$s_fcode>
io$_connect	= io$_access ! <4@io$s_fcode>
io$_setsockopt	= io$_access ! <5@io$s_fcode>
io$_accept_wait	= io$_access ! <10@io$s_fcode>
io$_getsockname	= io$_access ! <13@io$s_fcode>

af_inet	    = 2				; Internet socket.
sock_stream = 1				; Stream socket.
sol_socket  = ^xffff
so_keepalive= ^x08

	.psect	$local,rd,wrt,pic,noshr,noexe,long
dev:	.ascid	"INET0:"
iosb:	.blkw	4

namlen:	.long	0
socket:	.word	af_inet				; TCP/IP.
port:	.word	0				; Fill in port number.
addr:	.long	0				; Fill in address.
	.long	0,0				; Spare.

	.psect	$code,rd,nowrt,pic,shr,exe,long

; integer function tcphostn(name,length)

; Return the name of the current host.

name   = 4
length = 8

arpa:	.ascii	"ARPANET_HOST_NAME"
larpa	= .-arpa

	.entry	tcphostn,^m<>
	pushab	arpa
	pushl	#larpa
	movaq	(sp),r0
	$trnlog_s (r0),@length(ap),@name(ap)
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpsock(channel)

; This performs the equivalent of a UNIX socket() call.

channel = 4

	.entry	tcpsock,^m<>
	$assign_s dev,@channel(ap)
	bsbw	ret_on_err
	movl	#af_inet,r0
	$qiow_s	,@channel(ap),#io$_socket,-
		iosb,,,(r0),#sock_stream
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpconn(channel,address,port)

channel	= 4
address = 8
portno	=12

	.entry	tcpconn,^m<>
	movaw	@portno(ap),r0
	movb	1(r0),port
	movb	(r0),port+1
	movl	@address(ap),addr
	$qiow_s	,@channel(ap),#io$_connect,-
		iosb,,,socket,#16
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpbind(channel,address,portno)

channel	= 4
address = 8
portno    =12

	.entry	tcpbind,^m<>
	movaw	@portno(ap),r0
	movb	1(r0),port
	movb	(r0),port+1
	movl	@address(ap),addr
	$qiow_s	,@channel(ap),#io$_bind,-
		iosb,,,socket,#16
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcplist(channel,backlog)

channel = 4
backlog = 8

	.entry	tcplist,^m<>
	movl	@backlog(ap),r0
	$qiow_s	,@channel(ap),#io$_listen,-
		iosb,,,(r0)
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret
	
; integer function tcpaccpt(channel,nchannel)

channel  = 4
nchannel = 8

	.entry	tcpaccpt,^m<>
	$qiow_s	,@channel(ap),#io$_accept_wait,-
		iosb
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err

	$assign_s dev,@nchannel(ap)
	bsbw	ret_on_err
	$qiow_s	,@nchannel(ap),#io$_accept,-
		iosb,,,,,@channel(ap)
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret
	
; integer function tcpsockn(channel,address,portno)

; Returns the socket inet address and port number.
channel	= 4
address = 8
portno	=12

	.entry	tcpsockn,^m<>
	moval	namlen,r0
	movl	#16,(r0)
	$qiow_s	,@channel(ap),#io$_getsockname,-
		iosb,,,socket,r0

	movl	addr,@address(ap)
	clrl	@portno(ap)
	movaw	@portno(ap),r1
	movb	port,1(r1)
	movb	port+1,(r1)
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpwrite(channel,buffer,length)

; Write to the TCP channel.

channel	= 4
buffer	= 8
length	= 12

	.entry	tcpwrite,^m<>
	$qiow_s	,@channel(ap),#io$_writevblk,-
		iosb,,,@buffer(ap),@length(ap)
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpread(channel,buffer,length,return)

; Read from the TCP channel.

channel	= 4
buffer	= 8
length	= 12
return  = 16

	.entry	tcpread,^m<>
	$qiow_s	,@channel(ap),#io$_readvblk,-
		iosb,,,@buffer(ap),@length(ap)
	movzwl	iosb+2,@return(ap)
	bsbw	ret_on_err
	movzwl	iosb,r0
	bsbw	ret_on_err
	clrl	r0
	ret

; integer function tcpclose(channel)

; Tidy up the TCP/IP socket

	.entry	tcpclose,^m<>
	$dassgn_s @channel(ap)
	bsbw	ret_on_err
	clrl	r0
	ret

; Error handling.

ret_on_err:
	blbs	r0,10$			; Skip on no error.
	bbc	#15,r0,5$		; Branch if its a VMS error.

; Convert a Wollongong error into the corresponding VMS error.
	extzv	#3,#7,r0,r0
	movl	wollongong_error[r0],r0
5$:	ret
10$:	rsb

	.psect	$local,rd,wrt,pic,noshr,noexe,long
wollongong_error:
	.long	0
	.long	WIN_PERM
	.long	WIN_NOENT
	.long	WIN_SRCH
	.long	WIN_INTR
	.long	WIN_IO
	.long	WIN_NXIO
	.long	WIN_TOOBIG
	.long	WIN_NOEXEC
	.long	WIN_BADF
	.long	WIN_CHILD
	.long	WIN_AGAIN
	.long	WIN_NOMEM
	.long	WIN_ACCES
	.long	WIN_FAULT
	.long	WIN_NOTBLK
	.long	WIN_BUSY
	.long	WIN_EXIT
	.long	WIN_XDEV
	.long	WIN_NODEV
	.long	WIN_NOTDIR
	.long	WIN_ISDIR
	.long	WIN_INVAL
	.long	WIN_NFILE
	.long	WIN_MFILE
	.long	WIN_NOTTY
	.long	WIN_TXTBSY
	.long	WIN_FBIG
	.long	WIN_NOSPC
	.long	WIN_SPIPE
	.long	WIN_ROFS
	.long	WIN_MLINK
	.long	WIN_PIPE
	.long	WIN_DOM
	.long	WIN_RANGE
	.long	WIN_WOULDBLOCK
	.long	WIN_INPROGRESS
	.long	WIN_ALREADY
	.long	WIN_NOTSOCK
	.long	WIN_DESTADDRREQ
	.long	WIN_MSGSIZZE
	.long	WIN_PROTOTYPE
	.long	WIN_NOPROTOOPT
	.long	WIN_PROTONOSUPPORT
	.long	WIN_SOCKTNOSUPPORT
	.long	WIN_OPNOTSUPP
	.long	WIN_PFNOSUPPORT
	.long	WIN_AFNOSUPPORT
	.long	WIN_ADDRINUSE
	.long	WIN_ADDRNOTAVAIL
	.long	WIN_NETDOWN
	.long	WIN_NETUNREACH
	.long	WIN_NETRESET
	.long	WIN_CONNABORTED
	.long	WIN_CONNRESET
	.long	WIN_NOBUFS
	.long	WIN_ISCONN
	.long	WIN_NOTCONN
	.long	WIN_SHUTDOWN
	.long	0
	.long	WIN_TIMEDOUT
	.long	WIN_CONNREFUSED
	.long	WIN_LOOP
	.long	WIN_NAMETOOLONG
	.long	WIN_NOTEMPTY

	.end
