$ verify = 'f$verify("NO")'
$!***********************************************************************
$!	update.com
$
$! This determines which files are newer in Werongs microVAX directories
$! than on some other machine.
$
$! Inputs:
$!  p1	  Machine name.
$!***********************************************************************
$
$! The following defines the file types that we are interested in.
$
$	file_types = "..FOR.C.H.MAR.S.MSG.MACRO.DOC.TXT.LATEX.ICON.CSH." + -
	"TOC.AUX.NUL.AWK.F.COM.TEX.F2C."
$
$! Get the last update time. If there is an error, set the last update at
$! long ago.
$! set verify
$
$	on severe_error then goto 90
$	on control_y then goto 90
$	set_message_quals = f$environment("message")
$
$	status = 1
$	lock_created = 0
$	if p1.nes."" then goto 4
$	write sys$output "%UPDATE-F-NO_HOST, a host name must be given"
$	goto 90
$4:	if f$search("mirupd:update.lock").eqs."" then goto 5
$	write sys$output "%UPDATE-F-COLLISION, UPDATE is being run elsewhere"
$	goto 90
$5:	create mirupd:update.lock
$	lock_created = 1
$
$	host = p1
$	dolist = 0
$	if f$locate("_LIST",p1).nes.f$length(p1) then dolist = 1
$	if dolist then host = host - "_LIST"
$	last_update = "1-JAN-1900 0:00:00.00"
$	if dolist then goto 10
$	open/read/error=10 file mirupd:last_update.'p1'
$	read file last_update
$	close file
$
$! Determine the directories to search thru for files.
$
$10:	open/read hierarchy mirupd:hierarchy.'host'
$	open/write process junk.tmp3
$	nfound = 0
$20:	read/end=70 hierarchy line
$	output = f$element(0," ",line)
$	path = f$element(1," ",line)
$25:	if f$extract(f$length(path)-1,1,path).nes."-" then goto 27
$	read hierarchy line
$	path = f$edit(f$extract(0,f$length(path)-1,path)+line,"collapse")
$	goto 25
$
$! Open the file list giving the directories to be searched for files to
$! update.
$! Loop through the file hierarchy, checking for new files.
$! Create a file, junk.tmp1 of files that are new since the last update.
$
$! Determine directories to search.
$
$27:	set message/notext/noseverity/nofacility/noidentification
$	directory/noheader/notrailer/output=junk.tmp1/versions=1/modify -
	  /since="''last_update'"/exclude=junk* 'path'
$	status = '$status'
$	set message'set_message_quals'
$	if status.eq.%x10018290 then goto 20
$	if .not.status then goto 90
$
$! We have some new files. Filter through the list of new files, keeping
$! only those that we want. These involves:
$!  1. Discard repetitions.
$!  2. Keep only source files (.for,.c,.h,.mar,.s,.msg,.macro)
$!  3. Discard those which have another version of the file higher up the
$!     hierarchy.
$
$	sort junk.tmp1 junk.tmp2
$	delete junk.tmp1;
$	open/read newer junk.tmp2
$	previous = ""
$
$40:	read/end=60 newer file
$	if file.eqs.previous then goto 40
$	previous = file
$	type = f$parse(file,,,"type") + "."
$	if f$locate(type,file_types).eq.f$length(file_types) then goto 40
$	default = f$parse(file,,,"name") + ".*;"
$	n = 0
$50:	leaf = f$element(n,",",path)
$	if leaf.eqs."," then goto 40
$	n = n + 1
$55:	tmp = f$search(f$parse(leaf,default))
$	if tmp .eqs. "" then goto 50
$	type = f$parse(tmp,,,"type") + "."
$	if f$locate(type,file_types).eq.f$length(file_types) then goto 55
$	if f$parse(tmp,,,"name")      .nes. f$parse(file,,,"name")      then -
		goto 50
$	if f$parse(tmp,,,"directory") .nes. f$parse(file,,,"directory") then -
		goto 40
$	
$	nfound = nfound + 1
$	type = f$parse(file,,,"type")
$	if type.eqs."." then type = ""
$	out = output + f$parse(file,,,"name") + type
$	out = f$edit(out,"lowercase")
$	write process file," ",out
$	goto 40
$
$! Finish up searching this branch, and loop back for the next branch.
$
$60:	close newer
$	delete junk.tmp2;
$	goto 20
$
$! We now have a list of files to be processed. Call the machine dependent
$! update procedure.
$
$70:	close process
$	close hierarchy
$	$status = 1
$	if nfound.ne.0.and..not.dolist then -
	  @mirupd:update_com.'host' junk.tmp3 'host'
$	if dolist then copy junk.tmp3 [werong.mirth.notes]source_'host'.txt
$	status = '$status'
$	if .not.status then goto 90
$	if nfound.eq.0 then write sys$output -
		"%UPDATE-W-UPTODATE, this machine is up to date"
$	open/write file mirupd:last_update.'p1'
$	write file f$time()
$	close file
$	purge/keep=2 mirupd:last_update.'p1'
$
$! Keep track of when and what things were updated.
$
$	if f$search("mirupd:updates.dat").eqs."" then create mirupd:updates.dat
$	open/append file mirupd:updates.dat
$	open/read process junk.tmp3
$	write file "*** Updates to ",p1," at ",f$time()
$	if dolist then goto 85
$80:	read/end=85 process line
$	write file line
$	goto 80
$85:	close process
$	close file
$	delete junk.tmp3;
$
$! Reset everything in sight, in case I got here by foul means.
$
$	status = 1
$90:	if f$logical("newer").nes."" then close newer
$	if lock_created then delete mirupd:update.lock;*
$	if f$logical("hierarchy").nes."" then close hierarchy
$	if f$logical("process").nes."" then close process
$	if f$logical("file").nes. "" then close file
$	if .not.status then write sys$output f$message(status)
$	set message'set_message_quals'
$	if verify then set verify
$ set noverify
